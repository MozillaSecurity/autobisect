## Compile SpiderMonkey using compileShell

To compile a SpiderMonkey shell, run:

`funfuzz/js/compileShell.py -b "--enable-debug --enable-more-deterministic --enable-nspr-build -R ~/trees/mozilla-central"`

in order to get a debug 64-bit deterministic shell with NSPR compiled, off the **Mercurial** repository located at ~/trees/mozilla-central.

Clone the repository to that location using:

`hg clone https://hg.mozilla.org/mozilla-central/ ~/trees/mozilla-central`

assuming the ~/trees folder is created and present.

The options accepted by -b are also available via funfuzz/js/buildOptions.py:

```
  --random              Chooses sensible random build options. Defaults to
                        "False".
  -R REPODIR, --repoDir REPODIR
                        Sets the source repository.
  -P PATCHFILE, --patch PATCHFILE
                        Define the path to a single JS patch. Ensure mq is
                        installed.
  --32                  Build 32-bit shells, but if not enabled, 64-bit shells
                        are built.
  --enable-debug        Build shells with --enable-debug. Defaults to "False".
  --disable-debug       Build shells with --disable-debug. Defaults to
                        "False".
  --enable-optimize     Build shells with --enable-optimize. Defaults to
                        "False".
  --disable-optimize    Build shells with --disable-optimize. Defaults to
                        "False".
  --enable-profiling    Build shells with --enable-profiling. Defaults to
                        "False".
  --build-with-asan     Build with clang AddressSanitizer support. Defaults to
                        "False".
  --build-with-valgrind
                        Build with valgrind.h bits. Defaults to "False".
                        Requires --enable-hardfp for ARM platforms.
  --run-with-valgrind   Run the shell under Valgrind. Requires --build-with-
                        valgrind.
  --enable-nspr-build   Build the shell using (in-tree) NSPR. This is the
                        default on Windows. On POSIX platforms, shells default
                        to --enable-posix-nspr-emulation. Using --enable-nspr-
                        build creates a JS shell that is more like the
                        browser. Defaults to "False".
  --enable-more-deterministic
                        Build shells with --enable-more-deterministic.
                        Defaults to "False".
  --enable-simulator=arm
                        Build shells with --enable-simulator=arm, only
                        applicable to 32-bit shells. Defaults to "False".
  --enable-simulator=arm64
                        Build shells with --enable-simulator=arm64, only
                        applicable to 64-bit shells. Defaults to "False".
```


### More examples:

To compile a debug 64-bit deterministic shell used for profiling, do:

`funfuzz/js/compileShell.py -b "--enable-debug --enable-more-deterministic --enable-nspr-build -R ~/trees/mozilla-central"`

To compile an optimized 32-bit shell, do:

`funfuzz/js/compileShell.py -b "--32 --enable-optimize --enable-nspr-build -R ~/trees/mozilla-central"`

By default, js should compile an optimized shell even without --enable-optimize explicitly specified.

To compile a debug 32-bit ARM-simulator shell, do:

`funfuzz/js/compileShell.py -b "--32 --enable-debug --enable-nspr-build --enable-simulator=arm -R ~/trees/mozilla-central"`

To compile a debug 64-bit shell with AddressSanitizer (ASan) support, do:

`funfuzz/js/compileShell.py -b "--enable-debug --enable-nspr-build --build-with-asan -R ~/trees/mozilla-central"`

Note that this uses git to clone a specific known working revision of LLVM into `~/llvm`, compiles it, then uses this specific revision to compile SpiderMonkey.

To compile an optimized 64-bit shell with Valgrind support, do:

`funfuzz/js/compileShell.py -b "--enable-optimize --enable-nspr-build --build-with-valgrind -R ~/trees/mozilla-central"`

To test a patch with a debug 64-bit deterministic shell, do:

`funfuzz/js/compileShell.py -b "--enable-debug --enable-more-deterministic --enable-nspr-build -R ~/trees/mozilla-central -P <path to patch>"`

Note that this **requires mq to be activated** in Mercurial and assumes that there are **no patches** in the patch queue.

To compile a debug 64-bit deterministic shell from a specific mozilla-central revision, do:

`funfuzz/js/compileShell.py -b "--enable-debug --enable-more-deterministic --enable-nspr-build -R ~/trees/mozilla-central" -r <mercurial revision hash>`


### FAQ:

Q: Why is "--enable-more-deterministic" recommended?

A: Fuzzing with this mode on allows us to run compareJIT, which runs testcases generated by jsfunfuzz using different flags and compares the output. In order to compare successfully, the shell should generate consistent output everytime with a fixed input. Since we do not ship deterministic shells by default, if testing deterministic shells, we do not run with compareJIT.

Q: Is "--enable-nspr-build" needed?

A: Moving forward, NSPR is compiled along with SpiderMonkey in the js build system. However, prior to sometime in Spring 2014, it was not, and it had to be compiled separately from SpiderMonkey in order to compile a threadsafe shell.

This flag is usually recommended for bisection and compatibility purposes, where the earliest possible revision that could be compiled is still prior to this change.

Q: What are average build times for SpiderMonkey?

A: On a decent Linux machine or a powerful Mac, both with 4 or more cores, 3-4 minutes on average. On Windows, probably 5-10 minutes. On an ARM ODROID board, up to an hour.

Q: Do these build configure flags get passed into the js configure scripts?

No, they are independent. We only implemented the flags that are most useful for fuzzing in the harness.

Q: Will the gecko-dev Git mirror of mozilla-central be supported?

A: The "-R" flag assumes a Mercurial clone of mozilla-central is passed in as an argument. Git repositories are not yet supported fully, and especially not for autoBisect. See issue #2.

Q: Can I run multiple instances of compileShell?

This is not recommended as it will slow down your computer. Running one instance of compileShell will use the maximum number of cores as found by cpu_count() from the Python multiprocessing module, with the exception of ARM boards that tend to have slower cores.

Q: What kind of build does compileShell do, and what files do it store on my machine?

A: It creates a clobber build, compiling in the ~/shell-cache directory by default. There may also be a bunch of tempfiles created in the system temporary directory.

Q: How do I check if the SpiderMonkey build created is the one I specified?

A: Post-compilation, the harness does a bunch of verification tests to ensure that the desired build is created. To double check, run `getBuildConfiguration();` within the SpiderMonkey shell. If compileShell isn't compiling as desired, file an issue!

Q: What happens if the build I want to compile causes a compilation error?

A: A .busted file is created in the shell-cache directory. This will notify the harness not to retry in the future since it is busted. However, if there is an error in the harness, file an issue detailing the build configurations and steps to reproduce, and once it is fixed, remove the corresponding file/directory in ~/shell-cache and retry again.

Q: After compiling many shells, I'm now running out of disk space! What should I do?

A: Oops! You can remove the ~/shell-cache directory to reclaim space, and reboot to clear system temporary directories.


## Running jsfunfuzz

To test an existing SpiderMonkey shell called `./js`, run:

`funfuzz/js/loopjsfunfuzz.py --random-flags --comparejit 20 mozilla-central ./js`

* `--random-flags` tells it to use [shellFlags.py](shellFlags.py) to
* `--comparejit` tells it to run [compareJIT.py](compareJIT.py) on most of the generated code, detecting bugs where adding optimization flags like --ion-eager changes the output.
* `20` tells it to kill any instance that runs for more than 20 seconds
* `mozilla-central` tells it to use the known-bugs lists (for assertions and crashes) in [known/mozilla-central/](../known/mozilla-central/).

If loopjsfunfuzz detects a new bug, it will run [Lithium](https://github.com/MozillaSecurity/lithium/) to reduce the testcase. It will call Lithium with either [jsInteresting.py](jsInteresting.py) or [compareJIT.py](compareJIT.py) as the "interestingness test".

Using [bot.py](../bot.py) --test-type=js, you can automate downloading or building new versions of the SpiderMonkey shell, and running several instances of loopjsfunfuzz.py for parallelism.

Through randorderfuzz, if the harness detects tests in the mozilla-central tree, it may load or incorporate tests into its fuzzing input in a random order.


## What jsfunfuzz does

*jsfunfuzz* creates random JavaScript function bodies (including invalid ones) to test many parts of JavaScript engines.

The largest module of jsfunfuzz is [gen-grammar.js](jsfunfuzz/gen-grammar.js).  thinking loosely in terms of "statements", "expressions", "lvalues", "literals", etc. It's almost a context-free grammar fuzzer... |cat| and |totallyRandom| especially make it seem like one.

Once it creates a function body, it does the following things with it:
* Splits it in half and tries to compile each half, mostly to find bugs in the compiler's error-handling.
* Compiles it
* Executes it
* If executing returned a generator, loops through the generator.

## Contributors

* [Jesse Ruderman](https://twitter.com/jruderman) wrote most of the fuzzer
* [Gary Kwong](https://twitter.com/nth10sd) wrote a lot of the Python
* [Christian Holler](https://twitter.com/mozdeco) improved the compilation scripts
* [Jan de Mooij](https://twitter.com/jandemooij) prototyped [stress-testing objects and PICs](https://bugzilla.mozilla.org/show_bug.cgi?id=6309960)
* [David Keeler](https://twitter.com/mozkeeler) modified the regular expression generator to also generate (almost-)matching strings, based on an idea from [Oliver Hunt](https://twitter.com/ohunt).
* [The SpiderMonkey team](https://twitter.com/SpiderMonkeyJS) fixed over 2000 of our bugs, so we could keep fuzzing!
