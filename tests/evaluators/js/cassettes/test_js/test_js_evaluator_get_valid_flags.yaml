interactions:
- request:
    body: null
    headers:
      Accept:
      - '*/*'
      Accept-Encoding:
      - gzip, deflate
      Connection:
      - keep-alive
      User-Agent:
      - python-requests/2.27.1
    method: GET
    uri: https://hg.mozilla.org/mozilla-unified/raw-file/tip/js/src/shell/js.cpp
  response:
    body:
      string: "/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset:
        2 -*-\n * vim: set ts=8 sts=2 et sw=2 tw=80:\n * This Source Code Form is
        subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy
        of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.
        */\n\n/* JS shell. */\n\n#include \"mozilla/ArrayUtils.h\"\n#include \"mozilla/Atomics.h\"\n#include
        \"mozilla/Attributes.h\"\n#include \"mozilla/DebugOnly.h\"\n#include \"mozilla/EnumSet.h\"\n#include
        \"mozilla/IntegerPrintfMacros.h\"\n#include \"mozilla/mozalloc.h\"\n#include
        \"mozilla/PodOperations.h\"\n#include \"mozilla/RandomNum.h\"\n#include \"mozilla/RefPtr.h\"\n#include
        \"mozilla/ScopeExit.h\"\n#include \"mozilla/Sprintf.h\"\n#include \"mozilla/TimeStamp.h\"\n#include
        \"mozilla/UniquePtrExtensions.h\"  // UniqueFreePtr\n#include \"mozilla/Utf8.h\"\n#include
        \"mozilla/Variant.h\"\n\n#include <algorithm>\n#include <chrono>\n#ifdef XP_WIN\n#
        \ include <direct.h>\n#  include <process.h>\n#endif\n#include <errno.h>\n#include
        <fcntl.h>\n#if defined(XP_WIN)\n#  include <io.h> /* for isatty() */\n#endif\n#include
        <locale.h>\n#if defined(MALLOC_H)\n#  include MALLOC_H /* for malloc_usable_size,
        malloc_size, _msize */\n#endif\n#include <ctime>\n#include <math.h>\n#ifndef
        __wasi__\n#  include <signal.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include
        <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <utility>\n#ifdef
        XP_UNIX\n#  ifndef __wasi__\n#    include <sys/mman.h>\n#    include <sys/wait.h>\n#
        \ endif\n#  include <sys/stat.h>\n#  include <unistd.h>\n#endif\n#ifdef XP_LINUX\n#
        \ include <sys/prctl.h>\n#endif\n\n#include \"jsapi.h\"\n#include \"jsfriendapi.h\"\n#include
        \"jstypes.h\"\n#ifndef JS_WITHOUT_NSPR\n#  include \"prerror.h\"\n#  include
        \"prlink.h\"\n#endif\n\n#include \"builtin/Array.h\"\n#include \"builtin/MapObject.h\"\n#include
        \"builtin/ModuleObject.h\"\n#include \"builtin/RegExp.h\"\n#include \"builtin/TestingFunctions.h\"\n#include
        \"builtin/TestingUtility.h\"  // js::ParseCompileOptions, js::ParseDebugMetadata,
        js::CreateScriptPrivate\n#include \"debugger/DebugAPI.h\"\n#include \"frontend/BytecodeCompilation.h\"\n#include
        \"frontend/BytecodeCompiler.h\"\n#include \"frontend/CompilationStencil.h\"\n#ifdef
        JS_ENABLE_SMOOSH\n#  include \"frontend/Frontend2.h\"\n#endif\n#include \"frontend/FrontendContext.h\"
        \ // AutoReportFrontendContext\n#include \"frontend/ModuleSharedContext.h\"\n#include
        \"frontend/Parser.h\"\n#include \"frontend/ScopeBindingCache.h\"  // js::frontend::ScopeBindingCache\n#include
        \"frontend/SourceNotes.h\"  // SrcNote, SrcNoteType, SrcNoteIterator\n#include
        \"gc/PublicIterators.h\"\n#ifdef DEBUG\n#  include \"irregexp/RegExpAPI.h\"\n#endif\n#include
        \"gc/GC-inl.h\"  // ZoneCellIter\n\n#ifdef JS_SIMULATOR_ARM\n#  include \"jit/arm/Simulator-arm.h\"\n#endif\n#ifdef
        JS_SIMULATOR_MIPS32\n#  include \"jit/mips32/Simulator-mips32.h\"\n#endif\n#ifdef
        JS_SIMULATOR_MIPS64\n#  include \"jit/mips64/Simulator-mips64.h\"\n#endif\n#ifdef
        JS_SIMULATOR_LOONG64\n#  include \"jit/loong64/Simulator-loong64.h\"\n#endif\n#ifdef
        JS_SIMULATOR_RISCV64\n#  include \"jit/riscv64/Simulator-riscv64.h\"\n#endif\n#include
        \"jit/CacheIRHealth.h\"\n#include \"jit/InlinableNatives.h\"\n#include \"jit/Ion.h\"\n#include
        \"jit/JitcodeMap.h\"\n#include \"jit/shared/CodeGenerator-shared.h\"\n#include
        \"js/Array.h\"        // JS::NewArrayObject\n#include \"js/ArrayBuffer.h\"
        \ // JS::{CreateMappedArrayBufferContents,NewMappedArrayBufferWithContents,IsArrayBufferObject,GetArrayBufferLengthAndData}\n#include
        \"js/BuildId.h\"      // JS::BuildIdCharVector, JS::SetProcessBuildIdOp\n#include
        \"js/CallAndConstruct.h\"  // JS::Call, JS::IsCallable, JS_CallFunction, JS_CallFunctionValue\n#include
        \"js/CharacterEncoding.h\"  // JS::StringIsASCII\n#include \"js/CompilationAndEvaluation.h\"\n#include
        \"js/CompileOptions.h\"\n#include \"js/ContextOptions.h\"  // JS::ContextOptions{,Ref}\n#include
        \"js/Debug.h\"\n#include \"js/Equality.h\"                   // JS::SameValue\n#include
        \"js/ErrorReport.h\"                // JS::PrintError\n#include \"js/Exception.h\"
        \                 // JS::StealPendingExceptionStack\n#include \"js/experimental/CodeCoverage.h\"
        \ // js::EnableCodeCoverage\n#include \"js/experimental/CTypes.h\"        //
        JS::InitCTypesClass\n#include \"js/experimental/Intl.h\"  // JS::AddMoz{DateTimeFormat,DisplayNames}Constructor\n#include
        \"js/experimental/JitInfo.h\"  // JSJit{Getter,Setter,Method}CallArgs, JSJitGetterInfo,
        JSJit{Getter,Setter}Op, JSJitInfo\n#include \"js/experimental/JSStencil.h\"
        \ // JS::Stencil, JS::CompileToStencilOffThread, JS::FinishCompileToStencilOffThread\n#include
        \"js/experimental/SourceHook.h\"  // js::{Set,Forget,}SourceHook\n#include
        \"js/experimental/TypedData.h\"   // JS_NewUint8Array\n#include \"js/friend/DumpFunctions.h\"
        \    // JS::FormatStackDump\n#include \"js/friend/ErrorMessages.h\"     //
        js::GetErrorMessage, JSMSG_*\n#include \"js/friend/StackLimits.h\"       //
        js::AutoCheckRecursionLimit\n#include \"js/friend/WindowProxy.h\"  // js::IsWindowProxy,
        js::SetWindowProxyClass, js::ToWindowProxyIfWindow, js::ToWindowIfWindowProxy\n#include
        \"js/GCAPI.h\"               // JS::AutoCheckCannotGC\n#include \"js/GCVector.h\"\n#include
        \"js/GlobalObject.h\"\n#include \"js/Initialization.h\"\n#include \"js/Interrupt.h\"\n#include
        \"js/JSON.h\"\n#include \"js/MemoryCallbacks.h\"\n#include \"js/MemoryFunctions.h\"\n#include
        \"js/Modules.h\"  // JS::GetModulePrivate, JS::SetModule{DynamicImport,Metadata,Resolve}Hook,
        JS::SetModulePrivate\n#include \"js/Object.h\"  // JS::GetClass, JS::GetCompartment,
        JS::GetReservedSlot, JS::SetReservedSlot\n#include \"js/Principals.h\"\n#include
        \"js/Printer.h\"  // QuoteString\n#include \"js/Printf.h\"\n#include \"js/PropertyAndElement.h\"
        \ // JS_DefineElement, JS_DefineFunction, JS_DefineFunctions, JS_DefineProperties,
        JS_DefineProperty, JS_GetElement, JS_GetProperty, JS_GetPropertyById, JS_HasProperty,
        JS_SetElement, JS_SetProperty, JS_SetPropertyById\n#include \"js/PropertySpec.h\"\n#include
        \"js/Realm.h\"\n#include \"js/RegExp.h\"  // JS::ObjectIsRegExp\n#include
        \"js/ScriptPrivate.h\"\n#include \"js/SourceText.h\"\n#include \"js/StableStringChars.h\"\n#include
        \"js/Stack.h\"\n#include \"js/StreamConsumer.h\"\n#include \"js/StructuredClone.h\"\n#include
        \"js/SweepingAPI.h\"\n#include \"js/Transcoding.h\"  // JS::TranscodeBuffer,
        JS::TranscodeRange\n#include \"js/Warnings.h\"     // JS::SetWarningReporter\n#include
        \"js/WasmModule.h\"   // JS::WasmModule\n#include \"js/Wrapper.h\"\n#include
        \"proxy/DeadObjectProxy.h\"  // js::IsDeadProxyObject\n#include \"shell/jsoptparse.h\"\n#include
        \"shell/jsshell.h\"\n#include \"shell/OSObject.h\"\n#include \"shell/ShellModuleObjectWrapper.h\"\n#include
        \"shell/WasmTesting.h\"\n#include \"threading/ConditionVariable.h\"\n#include
        \"threading/ExclusiveData.h\"\n#include \"threading/LockGuard.h\"\n#include
        \"threading/Thread.h\"\n#include \"util/CompleteFile.h\"  // js::FileContents,
        js::ReadCompleteFile\n#include \"util/DifferentialTesting.h\"\n#include \"util/StringBuffer.h\"\n#include
        \"util/Text.h\"\n#include \"util/WindowsWrapper.h\"\n#include \"vm/ArgumentsObject.h\"\n#include
        \"vm/Compression.h\"\n#include \"vm/ErrorObject.h\"\n#include \"vm/ErrorReporting.h\"\n#include
        \"vm/HelperThreads.h\"\n#include \"vm/JSAtom.h\"\n#include \"vm/JSContext.h\"\n#include
        \"vm/JSFunction.h\"\n#include \"vm/JSObject.h\"\n#include \"vm/JSScript.h\"\n#include
        \"vm/ModuleBuilder.h\"  // js::ModuleBuilder\n#include \"vm/Modules.h\"\n#include
        \"vm/Monitor.h\"\n#include \"vm/MutexIDs.h\"\n#include \"vm/PromiseObject.h\"
        \ // js::PromiseObject\n#include \"vm/Shape.h\"\n#include \"vm/SharedArrayObject.h\"\n#include
        \"vm/StencilObject.h\"  // js::StencilObject\n#include \"vm/Time.h\"\n#include
        \"vm/ToSource.h\"  // js::ValueToSource\n#include \"vm/TypedArrayObject.h\"\n#include
        \"vm/WrapperObject.h\"\n#include \"wasm/WasmJS.h\"\n\n#include \"vm/Compartment-inl.h\"\n#include
        \"vm/ErrorObject-inl.h\"\n#include \"vm/Interpreter-inl.h\"\n#include \"vm/JSObject-inl.h\"\n#include
        \"vm/Realm-inl.h\"\n#include \"vm/Stack-inl.h\"\n\nusing namespace js;\nusing
        namespace js::cli;\nusing namespace js::shell;\n\nusing JS::AutoStableStringChars;\nusing
        JS::CompileOptions;\n\nusing js::shell::RCFile;\n\nusing mozilla::ArrayEqual;\nusing
        mozilla::AsVariant;\nusing mozilla::Atomic;\nusing mozilla::MakeScopeExit;\nusing
        mozilla::Maybe;\nusing mozilla::Nothing;\nusing mozilla::NumberEqualsInt32;\nusing
        mozilla::TimeDuration;\nusing mozilla::TimeStamp;\nusing mozilla::Utf8Unit;\nusing
        mozilla::Variant;\n\nbool InitOptionParser(OptionParser& op);\nbool SetGlobalOptionsPreJSInit(const
        OptionParser& op);\nbool SetGlobalOptionsPostJSInit(const OptionParser& op);\nbool
        SetContextOptions(JSContext* cx, const OptionParser& op);\nbool SetContextWasmOptions(JSContext*
        cx, const OptionParser& op);\nbool SetContextJITOptions(JSContext* cx, const
        OptionParser& op);\nbool SetContextGCOptions(JSContext* cx, const OptionParser&
        op);\nbool InitModuleLoader(JSContext* cx, const OptionParser& op);\n\n#ifdef
        FUZZING_JS_FUZZILLI\n#  define REPRL_CRFD 100\n#  define REPRL_CWFD 101\n#
        \ define REPRL_DRFD 102\n#  define REPRL_DWFD 103\n\n#  define SHM_SIZE 0x100000\n#
        \ define MAX_EDGES ((SHM_SIZE - 4) * 8)\n\nstruct shmem_data {\n  uint32_t
        num_edges;\n  unsigned char edges[];\n};\n\nstruct shmem_data* __shmem;\n\nuint32_t
        *__edges_start, *__edges_stop;\nvoid __sanitizer_cov_reset_edgeguards() {\n
        \ uint64_t N = 0;\n  for (uint32_t* x = __edges_start; x < __edges_stop &&
        N < MAX_EDGES; x++)\n    *x = ++N;\n}\n\nextern \"C\" void __sanitizer_cov_trace_pc_guard_init(uint32_t*
        start,\n                                                    uint32_t* stop)
        {\n  // Avoid duplicate initialization\n  if (start == stop || *start) return;\n\n
        \ if (__edges_start != NULL || __edges_stop != NULL) {\n    fprintf(stderr,\n
        \           \"Coverage instrumentation is only supported for a single module\\n\");\n
        \   _exit(-1);\n  }\n\n  __edges_start = start;\n  __edges_stop = stop;\n\n
        \ // Map the shared memory region\n  const char* shm_key = getenv(\"SHM_ID\");\n
        \ if (!shm_key) {\n    puts(\"[COV] no shared memory bitmap available, skipping\");\n
        \   __shmem = (struct shmem_data*)malloc(SHM_SIZE);\n  } else {\n    int fd
        = shm_open(shm_key, O_RDWR, S_IREAD | S_IWRITE);\n    if (fd <= -1) {\n      fprintf(stderr,
        \"Failed to open shared memory region: %s\\n\",\n              strerror(errno));\n
        \     _exit(-1);\n    }\n\n    __shmem = (struct shmem_data*)mmap(0, SHM_SIZE,
        PROT_READ | PROT_WRITE,\n                                       MAP_SHARED,
        fd, 0);\n    if (__shmem == MAP_FAILED) {\n      fprintf(stderr, \"Failed
        to mmap shared memory region\\n\");\n      _exit(-1);\n    }\n  }\n\n  __sanitizer_cov_reset_edgeguards();\n\n
        \ __shmem->num_edges = stop - start;\n  printf(\"[COV] edge counters initialized.
        Shared memory: %s with %u edges\\n\",\n         shm_key, __shmem->num_edges);\n}\n\nextern
        \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t* guard) {\n  // There's
        a small race condition here: if this function executes in two\n  // threads
        for the same edge at the same time, the first thread might disable\n  // the
        edge (by setting the guard to zero) before the second thread fetches\n  //
        the guard value (and thus the index). However, our instrumentation ignores\n
        \ // the first edge (see libcoverage.c) and so the race is unproblematic.\n
        \ uint32_t index = *guard;\n  // If this function is called before coverage
        instrumentation is properly\n  // initialized we want to return early.\n  if
        (!index) return;\n  __shmem->edges[index / 8] |= 1 << (index % 8);\n  *guard
        = 0;\n}\n#endif /* FUZZING_JS_FUZZILLI */\n\nenum JSShellExitCode {\n  EXITCODE_RUNTIME_ERROR
        = 3,\n  EXITCODE_FILE_NOT_FOUND = 4,\n  EXITCODE_OUT_OF_MEMORY = 5,\n  EXITCODE_TIMEOUT
        = 6\n};\n\n/*\n * Limit the timeout to 30 minutes to prevent an overflow on
        platfoms\n * that represent the time internally in microseconds using 32-bit
        int.\n */\nstatic const double MAX_TIMEOUT_SECONDS = 1800.0;\n\n// Not necessarily
        in sync with the browser\n#ifdef ENABLE_SHARED_MEMORY\n#  define SHARED_MEMORY_DEFAULT
        1\n#else\n#  define SHARED_MEMORY_DEFAULT 0\n#endif\n\n// Fuzzing support
        for JS runtime fuzzing\n#ifdef FUZZING_INTERFACES\n#  include \"shell/jsrtfuzzing/jsrtfuzzing.h\"\nstatic
        bool fuzzDoDebug = !!getenv(\"MOZ_FUZZ_DEBUG\");\nstatic bool fuzzHaveModule
        = !!getenv(\"FUZZER\");\n#endif  // FUZZING_INTERFACES\n\n// Code to support
        GCOV code coverage measurements on standalone shell\n#ifdef MOZ_CODE_COVERAGE\n#
        \ if defined(__GNUC__) && !defined(__clang__)\nextern \"C\" void __gcov_dump();\nextern
        \"C\" void __gcov_reset();\n\nvoid counters_dump(int) { __gcov_dump(); }\n\nvoid
        counters_reset(int) { __gcov_reset(); }\n#  else\nvoid counters_dump(int)
        { /* Do nothing */\n}\n\nvoid counters_reset(int) { /* Do nothing */\n}\n#
        \ endif\n\nstatic void InstallCoverageSignalHandlers() {\n#  ifndef XP_WIN\n
        \ fprintf(stderr, \"[CodeCoverage] Setting handlers for process %d.\\n\",\n
        \         getpid());\n\n  struct sigaction dump_sa;\n  dump_sa.sa_handler
        = counters_dump;\n  dump_sa.sa_flags = SA_RESTART;\n  sigemptyset(&dump_sa.sa_mask);\n
        \ mozilla::DebugOnly<int> r1 = sigaction(SIGUSR1, &dump_sa, nullptr);\n  MOZ_ASSERT(r1
        == 0, \"Failed to install GCOV SIGUSR1 handler\");\n\n  struct sigaction reset_sa;\n
        \ reset_sa.sa_handler = counters_reset;\n  reset_sa.sa_flags = SA_RESTART;\n
        \ sigemptyset(&reset_sa.sa_mask);\n  mozilla::DebugOnly<int> r2 = sigaction(SIGUSR2,
        &reset_sa, nullptr);\n  MOZ_ASSERT(r2 == 0, \"Failed to install GCOV SIGUSR2
        handler\");\n#  endif\n}\n#endif\n\n// An off-thread parse or decode job.\nclass
        js::shell::OffThreadJob {\n  enum State {\n    RUNNING,   // Working; no token.\n
        \   DONE,      // Finished; have token.\n    CANCELLED  // Cancelled due to
        error.\n  };\n\n public:\n  using Source = mozilla::Variant<JS::UniqueTwoByteChars,
        JS::TranscodeBuffer>;\n\n  OffThreadJob(ShellContext* sc, Source&& source);\n
        \ ~OffThreadJob();\n\n  void cancel();\n  void markDone(JS::OffThreadToken*
        newToken);\n  JS::OffThreadToken* waitUntilDone(JSContext* cx);\n\n  char16_t*
        sourceChars() { return source.as<UniqueTwoByteChars>().get(); }\n  JS::TranscodeBuffer&
        xdrBuffer() { return source.as<JS::TranscodeBuffer>(); }\n\n public:\n  const
        int32_t id;\n\n private:\n  js::Monitor& monitor;\n  State state;\n  JS::OffThreadToken*
        token;\n  Source source;\n};\n\nstatic OffThreadJob* NewOffThreadJob(JSContext*
        cx, CompileOptions& options,\n                                     OffThreadJob::Source&&
        source) {\n  ShellContext* sc = GetShellContext(cx);\n  UniquePtr<OffThreadJob>
        job(cx->new_<OffThreadJob>(sc, std::move(source)));\n  if (!job) {\n    return
        nullptr;\n  }\n\n  if (!sc->offThreadJobs.append(job.get())) {\n    job->cancel();\n
        \   JS_ReportErrorASCII(cx, \"OOM adding off-thread job\");\n    return nullptr;\n
        \ }\n\n  return job.release();\n}\n\nstatic OffThreadJob* GetSingleOffThreadJob(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  const auto& jobs = sc->offThreadJobs;\n
        \ if (jobs.empty()) {\n    JS_ReportErrorASCII(cx, \"No off-thread jobs are
        pending\");\n    return nullptr;\n  }\n\n  if (jobs.length() > 1) {\n    JS_ReportErrorASCII(\n
        \       cx, \"Multiple off-thread jobs are pending: must specify job ID\");\n
        \   return nullptr;\n  }\n\n  return jobs[0];\n}\n\nstatic OffThreadJob* LookupOffThreadJobByID(JSContext*
        cx, int32_t id) {\n  if (id <= 0) {\n    JS_ReportErrorASCII(cx, \"Bad off-thread
        job ID\");\n    return nullptr;\n  }\n\n  ShellContext* sc = GetShellContext(cx);\n
        \ const auto& jobs = sc->offThreadJobs;\n  if (jobs.empty()) {\n    JS_ReportErrorASCII(cx,
        \"No off-thread jobs are pending\");\n    return nullptr;\n  }\n\n  OffThreadJob*
        job = nullptr;\n  for (auto someJob : jobs) {\n    if (someJob->id == id)
        {\n      job = someJob;\n      break;\n    }\n  }\n\n  if (!job) {\n    JS_ReportErrorASCII(cx,
        \"Off-thread job not found\");\n    return nullptr;\n  }\n\n  return job;\n}\n\nstatic
        OffThreadJob* LookupOffThreadJobForArgs(JSContext* cx,\n                                               const
        CallArgs& args,\n                                               size_t arg)
        {\n  // If the optional ID argument isn't present, get the single pending
        job.\n  if (args.length() <= arg) {\n    return GetSingleOffThreadJob(cx);\n
        \ }\n\n  // Lookup the job using the specified ID.\n  int32_t id = 0;\n  RootedValue
        value(cx, args[arg]);\n  if (!ToInt32(cx, value, &id)) {\n    return nullptr;\n
        \ }\n\n  return LookupOffThreadJobByID(cx, id);\n}\n\nstatic void DeleteOffThreadJob(JSContext*
        cx, OffThreadJob* job) {\n  ShellContext* sc = GetShellContext(cx);\n  for
        (size_t i = 0; i < sc->offThreadJobs.length(); i++) {\n    if (sc->offThreadJobs[i]
        == job) {\n      sc->offThreadJobs.erase(&sc->offThreadJobs[i]);\n      js_delete(job);\n
        \     return;\n    }\n  }\n\n  MOZ_CRASH(\"Off-thread job not found\");\n}\n\nstatic
        void CancelOffThreadJobsForContext(JSContext* cx) {\n  // Parse jobs may be
        blocked waiting on GC.\n  gc::FinishGC(cx);\n\n  // Wait for jobs belonging
        to this context.\n  ShellContext* sc = GetShellContext(cx);\n  while (!sc->offThreadJobs.empty())
        {\n    OffThreadJob* job = sc->offThreadJobs.popCopy();\n    job->waitUntilDone(cx);\n
        \   js_delete(job);\n  }\n}\n\nstatic void CancelOffThreadJobsForRuntime(JSContext*
        cx) {\n  // Parse jobs may be blocked waiting on GC.\n  gc::FinishGC(cx);\n\n
        \ // Cancel jobs belonging to this runtime.\n  CancelOffThreadParses(cx->runtime());\n
        \ ShellContext* sc = GetShellContext(cx);\n  while (!sc->offThreadJobs.empty())
        {\n    js_delete(sc->offThreadJobs.popCopy());\n  }\n}\n\nmozilla::Atomic<int32_t>
        gOffThreadJobSerial(1);\n\nOffThreadJob::OffThreadJob(ShellContext* sc, Source&&
        source)\n    : id(gOffThreadJobSerial++),\n      monitor(sc->offThreadMonitor),\n
        \     state(RUNNING),\n      token(nullptr),\n      source(std::move(source))
        {\n  MOZ_RELEASE_ASSERT(id > 0, \"Off-thread job IDs exhausted\");\n}\n\nOffThreadJob::~OffThreadJob()
        { MOZ_ASSERT(state != RUNNING); }\n\nvoid OffThreadJob::cancel() {\n  MOZ_ASSERT(state
        == RUNNING);\n  MOZ_ASSERT(!token);\n\n  state = CANCELLED;\n}\n\nvoid OffThreadJob::markDone(JS::OffThreadToken*
        newToken) {\n  AutoLockMonitor alm(monitor);\n  MOZ_ASSERT(state == RUNNING);\n
        \ MOZ_ASSERT(!token);\n  MOZ_ASSERT(newToken);\n\n  token = newToken;\n  state
        = DONE;\n  alm.notifyAll();\n}\n\nJS::OffThreadToken* OffThreadJob::waitUntilDone(JSContext*
        cx) {\n  AutoLockMonitor alm(monitor);\n  MOZ_ASSERT(state != CANCELLED);\n\n
        \ while (state != DONE) {\n    alm.wait();\n  }\n\n  MOZ_ASSERT(token);\n
        \ return token;\n}\n\nstruct ShellCompartmentPrivate {\n  GCPtr<ArrayObject*>
        blackRoot;\n  GCPtr<ArrayObject*> grayRoot;\n};\n\nstruct MOZ_STACK_CLASS
        EnvironmentPreparer\n    : public js::ScriptEnvironmentPreparer {\n  explicit
        EnvironmentPreparer(JSContext* cx) {\n    js::SetScriptEnvironmentPreparer(cx,
        this);\n  }\n  void invoke(JS::HandleObject global, Closure& closure) override;\n};\n\nconst
        char* shell::selfHostedXDRPath = nullptr;\nbool shell::encodeSelfHostedCode
        = false;\nbool shell::enableCodeCoverage = false;\nbool shell::enableDisassemblyDumps
        = false;\nbool shell::offthreadCompilation = false;\nJS::DelazificationOption
        shell::defaultDelazificationMode =\n    JS::DelazificationOption::OnDemandOnly;\nbool
        shell::enableAsmJS = false;\nbool shell::enableWasm = false;\nbool shell::enableSharedMemory
        = SHARED_MEMORY_DEFAULT;\nbool shell::enableWasmBaseline = false;\nbool shell::enableWasmOptimizing
        = false;\n\n#define WASM_DEFAULT_FEATURE(NAME, ...) bool shell::enableWasm##NAME
        = true;\n#define WASM_EXPERIMENTAL_FEATURE(NAME, ...) \\\n  bool shell::enableWasm##NAME
        = false;\nJS_FOR_WASM_FEATURES(WASM_DEFAULT_FEATURE, WASM_DEFAULT_FEATURE,\n
        \                    WASM_EXPERIMENTAL_FEATURE);\n#undef WASM_DEFAULT_FEATURE\n#undef
        WASM_EXPERIMENTAL_FEATURE\n\nbool shell::enableWasmVerbose = false;\nbool
        shell::enableTestWasmAwaitTier2 = false;\nbool shell::enableSourcePragmas
        = true;\nbool shell::enableAsyncStacks = false;\nbool shell::enableAsyncStackCaptureDebuggeeOnly
        = false;\nbool shell::enableWeakRefs = false;\nbool shell::enableToSource
        = false;\nbool shell::enablePropertyErrorMessageFix = false;\nbool shell::enableIteratorHelpers
        = false;\nbool shell::enableShadowRealms = false;\nbool shell::enableArrayFromAsync
        = true;\n#ifdef NIGHTLY_BUILD\nbool shell::enableArrayGrouping = false;\n//
        Pref for String.prototype.{is,to}WellFormed() methods.\nbool shell::enableWellFormedUnicodeStrings
        = false;\n#endif\nbool shell::enableChangeArrayByCopy = false;\n#ifdef ENABLE_NEW_SET_METHODS\nbool
        shell::enableNewSetMethods = true;\n#endif\nbool shell::enableImportAssertions
        = false;\n#ifdef JS_GC_ZEAL\nuint32_t shell::gZealBits = 0;\nuint32_t shell::gZealFrequency
        = 0;\n#endif\nbool shell::printTiming = false;\nRCFile* shell::gErrFile =
        nullptr;\nRCFile* shell::gOutFile = nullptr;\nbool shell::reportWarnings =
        true;\nbool shell::compileOnly = false;\nbool shell::disableOOMFunctions =
        false;\nbool shell::defaultToSameCompartment = true;\n\nbool shell::useFdlibmForSinCosTan
        = false;\n\n#ifdef DEBUG\nbool shell::dumpEntrainedVariables = false;\nbool
        shell::OOM_printAllocationCount = false;\n#endif\n\nUniqueChars shell::processWideModuleLoadPath;\n\nstatic
        bool SetTimeoutValue(JSContext* cx, double t);\n\nstatic void KillWatchdog(JSContext*
        cx);\n\nstatic bool ScheduleWatchdog(JSContext* cx, double t);\n\nstatic void
        CancelExecution(JSContext* cx);\n\nenum class ShellGlobalKind {\n  GlobalObject,\n
        \ WindowProxy,\n};\n\nstatic JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions&
        options,\n                                 JSPrincipals* principals, ShellGlobalKind
        kind,\n                                 bool immutablePrototype);\n\n/*\n
        * A toy WindowProxy class for the shell. This is intended for testing code\n
        * where global |this| is a WindowProxy. All requests are forwarded to the\n
        * underlying global and no navigation is supported.\n */\nconst JSClass ShellWindowProxyClass
        =\n    PROXY_CLASS_DEF(\"ShellWindowProxy\", JSCLASS_HAS_RESERVED_SLOTS(1));\n\nJSObject*
        NewShellWindowProxy(JSContext* cx, JS::HandleObject global) {\n  MOZ_ASSERT(global->is<GlobalObject>());\n\n
        \ js::WrapperOptions options;\n  options.setClass(&ShellWindowProxyClass);\n\n
        \ JSAutoRealm ar(cx, global);\n  JSObject* obj =\n      js::Wrapper::New(cx,
        global, &js::Wrapper::singleton, options);\n  MOZ_ASSERT_IF(obj, js::IsWindowProxy(obj));\n
        \ return obj;\n}\n\n/*\n * A toy principals type for the shell.\n *\n * In
        the shell, a principal is simply a 32-bit mask: P subsumes Q if the\n * set
        bits in P are a superset of those in Q. Thus, the principal 0 is\n * subsumed
        by everything, and the principal ~0 subsumes everything.\n *\n * As a special
        case, a null pointer as a principal is treated like 0xffff.\n *\n * The 'newGlobal'
        function takes an option indicating which principal the\n * new global should
        have; 'evaluate' does for the new code.\n */\nclass ShellPrincipals final
        : public JSPrincipals {\n  uint32_t bits;\n\n  static uint32_t getBits(JSPrincipals*
        p) {\n    if (!p) {\n      return 0xffff;\n    }\n    return static_cast<ShellPrincipals*>(p)->bits;\n
        \ }\n\n public:\n  explicit ShellPrincipals(uint32_t bits, int32_t refcount
        = 0) : bits(bits) {\n    this->refcount = refcount;\n  }\n\n  bool write(JSContext*
        cx, JSStructuredCloneWriter* writer) override {\n    // The shell doesn't
        have a read principals hook, so it doesn't really\n    // matter what we write
        here, but we have to write something so the\n    // fuzzer is happy.\n    return
        JS_WriteUint32Pair(writer, bits, 0);\n  }\n\n  bool isSystemOrAddonPrincipal()
        override { return true; }\n\n  static void destroy(JSPrincipals* principals)
        {\n    MOZ_ASSERT(principals != &fullyTrusted);\n    MOZ_ASSERT(principals->refcount
        == 0);\n    js_delete(static_cast<const ShellPrincipals*>(principals));\n
        \ }\n\n  static bool subsumes(JSPrincipals* first, JSPrincipals* second) {\n
        \   uint32_t firstBits = getBits(first);\n    uint32_t secondBits = getBits(second);\n
        \   return (firstBits | secondBits) == firstBits;\n  }\n\n  static JSSecurityCallbacks
        securityCallbacks;\n\n  // Fully-trusted principals singleton.\n  static ShellPrincipals
        fullyTrusted;\n};\n\nJSSecurityCallbacks ShellPrincipals::securityCallbacks
        = {\n    nullptr,  // contentSecurityPolicyAllows\n    subsumes};\n\n// The
        fully-trusted principal subsumes all other principals.\nShellPrincipals ShellPrincipals::fullyTrusted(-1,
        1);\n\n#ifdef EDITLINE\nextern \"C\" {\nextern MOZ_EXPORT char* readline(const
        char* prompt);\nextern MOZ_EXPORT void add_history(char* line);\n}  // extern
        \"C\"\n#endif\n\nShellContext::ShellContext(JSContext* cx)\n    : isWorker(false),\n
        \     lastWarningEnabled(false),\n      trackUnhandledRejections(true),\n
        \     timeoutInterval(-1.0),\n      startTime(PRMJ_Now()),\n      serviceInterrupt(false),\n
        \     haveInterruptFunc(false),\n      interruptFunc(cx, NullValue()),\n      lastWarning(cx,
        NullValue()),\n      promiseRejectionTrackerCallback(cx, NullValue()),\n      unhandledRejectedPromises(cx),\n
        \     watchdogLock(mutexid::ShellContextWatchdog),\n      exitCode(0),\n      quitting(false),\n
        \     readLineBufPos(0),\n      errFilePtr(nullptr),\n      outFilePtr(nullptr),\n
        \     offThreadMonitor(mutexid::ShellOffThreadState),\n      finalizationRegistryCleanupCallbacks(cx)
        {}\n\nShellContext::~ShellContext() { MOZ_ASSERT(offThreadJobs.empty()); }\n\nShellContext*
        js::shell::GetShellContext(JSContext* cx) {\n  ShellContext* sc = static_cast<ShellContext*>(JS_GetContextPrivate(cx));\n
        \ MOZ_ASSERT(sc);\n  return sc;\n}\n\nstatic void TraceRootArrays(JSTracer*
        trc, gc::MarkColor color) {\n  JSRuntime* rt = trc->runtime();\n  for (ZonesIter
        zone(rt, SkipAtoms); !zone.done(); zone.next()) {\n    for (CompartmentsInZoneIter
        comp(zone); !comp.done(); comp.next()) {\n      auto priv = static_cast<ShellCompartmentPrivate*>(\n
        \         JS_GetCompartmentPrivate(comp.get()));\n      if (!priv) {\n        continue;\n
        \     }\n\n      GCPtr<ArrayObject*>& array =\n          (color == gc::MarkColor::Black)
        ? priv->blackRoot : priv->grayRoot;\n      TraceNullableEdge(trc, &array,
        \"shell root array\");\n\n      if (array) {\n        // Trace the array elements
        as part of root marking.\n        for (uint32_t i = 0; i < array->getDenseInitializedLength();
        i++) {\n          Value& value = const_cast<Value&>(array->getDenseElement(i));\n
        \         TraceManuallyBarrieredEdge(trc, &value, \"shell root array element\");\n
        \       }\n      }\n    }\n  }\n}\n\nstatic void TraceBlackRoots(JSTracer*
        trc, void* data) {\n  TraceRootArrays(trc, gc::MarkColor::Black);\n}\n\nstatic
        bool TraceGrayRoots(JSTracer* trc, SliceBudget& budget, void* data) {\n  TraceRootArrays(trc,
        gc::MarkColor::Gray);\n  return true;\n}\n\nstatic inline JSString* NewStringCopyUTF8(JSContext*
        cx, const char* chars) {\n  return JS_NewStringCopyUTF8N(cx, JS::UTF8Chars(chars,
        strlen(chars)));\n}\n\nstatic mozilla::UniqueFreePtr<char[]> GetLine(FILE*
        file, const char* prompt) {\n#ifdef EDITLINE\n  /*\n   * Use readline only
        if file is stdin, because there's no way to specify\n   * another handle.
        \ Are other filehandles interactive?\n   */\n  if (file == stdin) {\n    mozilla::UniqueFreePtr<char[]>
        linep(readline(prompt));\n    /*\n     * We set it to zero to avoid complaining
        about inappropriate ioctl\n     * for device in the case of EOF. Looks like
        errno == 251 if line is\n     * finished with EOF and errno == 25 (EINVAL
        on Mac) if there is\n     * nothing left to read.\n     */\n    if (errno
        == 251 || errno == 25 || errno == EINVAL) {\n      errno = 0;\n    }\n    if
        (!linep) {\n      return nullptr;\n    }\n    if (linep[0] != '\\0') {\n      add_history(linep.get());\n
        \   }\n    return linep;\n  }\n#endif\n\n  size_t len = 0;\n  if (*prompt
        != '\\0' && gOutFile->isOpen()) {\n    fprintf(gOutFile->fp, \"%s\", prompt);\n
        \   fflush(gOutFile->fp);\n  }\n\n  size_t size = 80;\n  mozilla::UniqueFreePtr<char[]>
        buffer(static_cast<char*>(malloc(size)));\n  if (!buffer) {\n    return nullptr;\n
        \ }\n\n  char* current = buffer.get();\n  do {\n    while (true) {\n      if
        (fgets(current, size - len, file)) {\n        break;\n      }\n      if (errno
        != EINTR) {\n        return nullptr;\n      }\n    }\n\n    len += strlen(current);\n
        \   char* t = buffer.get() + len - 1;\n    if (*t == '\\n') {\n      /* Line
        was read. We remove '\\n' and exit. */\n      *t = '\\0';\n      break;\n
        \   }\n\n    if (len + 1 == size) {\n      size = size * 2;\n      char* raw
        = buffer.release();\n      char* tmp = static_cast<char*>(realloc(raw, size));\n
        \     if (!tmp) {\n        free(raw);\n        return nullptr;\n      }\n
        \     buffer.reset(tmp);\n    }\n    current = buffer.get() + len;\n  } while
        (true);\n  return buffer;\n}\n\nstatic bool ShellInterruptCallback(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  if (!sc->serviceInterrupt)
        {\n    return true;\n  }\n\n  // Reset serviceInterrupt. CancelExecution or
        InterruptIf will set it to\n  // true to distinguish watchdog or user triggered
        interrupts.\n  // Do this first to prevent other interrupts that may occur
        while the\n  // user-supplied callback is executing from re-entering the handler.\n
        \ sc->serviceInterrupt = false;\n\n  bool result;\n  if (sc->haveInterruptFunc)
        {\n    bool wasAlreadyThrowing = cx->isExceptionPending();\n    JS::AutoSaveExceptionState
        savedExc(cx);\n    JSAutoRealm ar(cx, &sc->interruptFunc.toObject());\n    RootedValue
        rval(cx);\n\n    // Report any exceptions thrown by the JS interrupt callback,
        but do\n    // *not* keep it on the cx. The interrupt handler is invoked at
        points\n    // that are not expected to throw catchable exceptions, like at\n
        \   // JSOp::RetRval.\n    //\n    // If the interrupted JS code was already
        throwing, any exceptions\n    // thrown by the interrupt handler are silently
        swallowed.\n    {\n      Maybe<AutoReportException> are;\n      if (!wasAlreadyThrowing)
        {\n        are.emplace(cx);\n      }\n      result = JS_CallFunctionValue(cx,
        nullptr, sc->interruptFunc,\n                                    JS::HandleValueArray::empty(),
        &rval);\n    }\n    savedExc.restore();\n\n    if (rval.isBoolean()) {\n      result
        = rval.toBoolean();\n    } else {\n      result = false;\n    }\n  } else
        {\n    result = false;\n  }\n\n  if (!result && sc->exitCode == 0) {\n    static
        const char msg[] = \"Script terminated by interrupt handler.\\n\";\n    fputs(msg,
        stderr);\n\n    sc->exitCode = EXITCODE_TIMEOUT;\n  }\n\n  return result;\n}\n\nstatic
        void GCSliceCallback(JSContext* cx, JS::GCProgress progress,\n                            const
        JS::GCDescription& desc) {\n  if (progress == JS::GC_CYCLE_END) {\n#if defined(MOZ_MEMORY)\n
        \   // We call this here to match the browser's DOMGCSliceCallback.\n    jemalloc_free_dirty_pages();\n#endif\n
        \ }\n}\n\n/*\n * Some UTF-8 files, notably those written using Notepad, have
        a Unicode\n * Byte-Order-Mark (BOM) as their first character. This is useless
        (byte-order\n * is meaningless for UTF-8) but causes a syntax error unless
        we skip it.\n */\nstatic void SkipUTF8BOM(FILE* file) {\n  int ch1 = fgetc(file);\n
        \ int ch2 = fgetc(file);\n  int ch3 = fgetc(file);\n\n  // Skip the BOM\n
        \ if (ch1 == 0xEF && ch2 == 0xBB && ch3 == 0xBF) {\n    return;\n  }\n\n  //
        No BOM - revert\n  if (ch3 != EOF) {\n    ungetc(ch3, file);\n  }\n  if (ch2
        != EOF) {\n    ungetc(ch2, file);\n  }\n  if (ch1 != EOF) {\n    ungetc(ch1,
        file);\n  }\n}\n\nvoid EnvironmentPreparer::invoke(HandleObject global, Closure&
        closure) {\n  MOZ_ASSERT(JS_IsGlobalObject(global));\n\n  JSContext* cx =
        TlsContext.get();\n  MOZ_ASSERT(!JS_IsExceptionPending(cx));\n\n  AutoRealm
        ar(cx, global);\n  AutoReportException are(cx);\n  if (!closure(cx)) {\n    return;\n
        \ }\n}\n\nstatic bool RegisterScriptPathWithModuleLoader(JSContext* cx,\n
        \                                              HandleScript script,\n                                               const
        char* filename) {\n  // Set the private value associated with a script to
        a object containing the\n  // script's filename so that the module loader
        can use it to resolve\n  // relative imports.\n\n  RootedString path(cx, NewStringCopyUTF8(cx,
        filename));\n  if (!path) {\n    return false;\n  }\n\n  MOZ_ASSERT(JS::GetScriptPrivate(script).isUndefined());\n
        \ RootedObject infoObject(cx, js::CreateScriptPrivate(cx, path));\n  if (!infoObject)
        {\n    return false;\n  }\n\n  JS::SetScriptPrivate(script, ObjectValue(*infoObject));\n
        \ return true;\n}\n\nenum class CompileUtf8 {\n  InflateToUtf16,\n  DontInflate,\n};\n\n[[nodiscard]]
        static bool RunFile(JSContext* cx, const char* filename,\n                                  FILE*
        file, CompileUtf8 compileMethod,\n                                  bool compileOnly,
        bool fullParse) {\n  SkipUTF8BOM(file);\n\n  int64_t t1 = PRMJ_Now();\n  RootedScript
        script(cx);\n\n  {\n    CompileOptions options(cx);\n    options.setIntroductionType(\"js
        shell file\")\n        .setFileAndLine(filename, 1)\n        .setIsRunOnce(true)\n
        \       .setNoScriptRval(true);\n\n    if (fullParse) {\n      options.setForceFullParse();\n
        \   } else {\n      options.setEagerDelazificationStrategy(defaultDelazificationMode);\n
        \   }\n\n    if (compileMethod == CompileUtf8::DontInflate) {\n      script
        = JS::CompileUtf8File(cx, options, file);\n    } else {\n      fprintf(stderr,
        \"(compiling '%s' after inflating to UTF-16)\\n\", filename);\n\n      FileContents
        buffer(cx);\n      if (!ReadCompleteFile(cx, file, buffer)) {\n        return
        false;\n      }\n\n      size_t length = buffer.length();\n      auto chars
        = UniqueTwoByteChars(\n          UTF8CharsToNewTwoByteCharsZ(\n              cx,\n
        \             JS::UTF8Chars(reinterpret_cast<const char*>(buffer.begin()),\n
        \                           buffer.length()),\n              &length, js::MallocArena)\n
        \             .get());\n      if (!chars) {\n        return false;\n      }\n\n
        \     JS::SourceText<char16_t> source;\n      if (!source.init(cx, std::move(chars),
        length)) {\n        return false;\n      }\n\n      script = JS::Compile(cx,
        options, source);\n    }\n\n    if (!script) {\n      return false;\n    }\n
        \ }\n\n  if (!RegisterScriptPathWithModuleLoader(cx, script, filename)) {\n
        \   return false;\n  }\n\n#ifdef DEBUG\n  if (dumpEntrainedVariables) {\n
        \   AnalyzeEntrainedVariables(cx, script);\n  }\n#endif\n  if (!compileOnly)
        {\n    if (!JS_ExecuteScript(cx, script)) {\n      return false;\n    }\n
        \   int64_t t2 = PRMJ_Now() - t1;\n    if (printTiming) {\n      printf(\"runtime
        = %.3f ms\\n\", double(t2) / PRMJ_USEC_PER_MSEC);\n    }\n  }\n  return true;\n}\n\n[[nodiscard]]
        static bool RunModule(JSContext* cx, const char* filename,\n                                    bool
        compileOnly) {\n  ShellContext* sc = GetShellContext(cx);\n\n  RootedString
        path(cx, NewStringCopyUTF8(cx, filename));\n  if (!path) {\n    return false;\n
        \ }\n\n  path = ResolvePath(cx, path, RootRelative);\n  if (!path) {\n    return
        false;\n  }\n\n  return sc->moduleLoader->loadRootModule(cx, path);\n}\n\nstatic
        void ShellCleanupFinalizationRegistryCallback(JSFunction* doCleanup,\n                                                     JSObject*
        incumbentGlobal,\n                                                     void*
        data) {\n  // In the browser this queues a task. Shell jobs correspond to
        microtasks so\n  // we arrange for cleanup to happen after all jobs/microtasks
        have run. The\n  // incumbent global is ignored in the shell.\n\n  auto sc
        = static_cast<ShellContext*>(data);\n  AutoEnterOOMUnsafeRegion oomUnsafe;\n
        \ if (!sc->finalizationRegistryCleanupCallbacks.append(doCleanup)) {\n    oomUnsafe.crash(\"ShellCleanupFinalizationRegistryCallback\");\n
        \ }\n}\n\n// Run any FinalizationRegistry cleanup tasks and return whether
        any ran.\nstatic bool MaybeRunFinalizationRegistryCleanupTasks(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  MOZ_ASSERT(!sc->quitting);\n\n
        \ Rooted<ShellContext::FunctionVector> callbacks(cx);\n  std::swap(callbacks.get(),
        sc->finalizationRegistryCleanupCallbacks.get());\n\n  bool ranTasks = false;\n\n
        \ RootedFunction callback(cx);\n  for (JSFunction* f : callbacks) {\n    callback
        = f;\n\n    JS::ExposeObjectToActiveJS(callback);\n    AutoRealm ar(cx, callback);\n\n
        \   {\n      AutoReportException are(cx);\n      RootedValue unused(cx);\n
        \     (void)JS_CallFunction(cx, nullptr, callback, HandleValueArray::empty(),\n
        \                           &unused);\n    }\n\n    ranTasks = true;\n\n    if
        (sc->quitting) {\n      break;\n    }\n  }\n\n  return ranTasks;\n}\n\nstatic
        bool EnqueueJob(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  if (!IsFunctionObject(args.get(0))) {\n    JS_ReportErrorASCII(cx,
        \"EnqueueJob's first argument must be a function\");\n    return false;\n
        \ }\n\n  args.rval().setUndefined();\n\n  RootedObject job(cx, &args[0].toObject());\n
        \ return js::EnqueueJob(cx, job);\n}\n\nstatic void RunShellJobs(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  if (sc->quitting) {\n
        \   return;\n  }\n\n  while (true) {\n    // Run microtasks.\n    js::RunJobs(cx);\n
        \   if (sc->quitting) {\n      return;\n    }\n\n    // Run tasks (only finalization
        registry clean tasks are possible).\n    bool ranTasks = MaybeRunFinalizationRegistryCleanupTasks(cx);\n
        \   if (!ranTasks) {\n      break;\n    }\n  }\n}\n\nstatic bool DrainJobQueue(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (GetShellContext(cx)->quitting) {\n    JS_ReportErrorASCII(\n        cx,
        \"Mustn't drain the job queue when the shell is quitting\");\n    return false;\n
        \ }\n\n  RunShellJobs(cx);\n\n  if (GetShellContext(cx)->quitting) {\n    return
        false;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool GlobalOfFirstJobInQueue(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  RootedObject job(cx, cx->internalJobQueue->maybeFront());\n
        \ if (!job) {\n    JS_ReportErrorASCII(cx, \"Job queue is empty\");\n    return
        false;\n  }\n\n  RootedObject global(cx, &job->nonCCWGlobal());\n  if (!cx->compartment()->wrap(cx,
        &global)) {\n    return false;\n  }\n\n  args.rval().setObject(*global);\n
        \ return true;\n}\n\nstatic bool TrackUnhandledRejections(JSContext* cx, JS::HandleObject
        promise,\n                                     JS::PromiseRejectionHandlingState
        state) {\n  ShellContext* sc = GetShellContext(cx);\n  if (!sc->trackUnhandledRejections)
        {\n    return true;\n  }\n\n#if defined(DEBUG) || defined(JS_OOM_BREAKPOINT)\n
        \ if (cx->runningOOMTest) {\n    // When OOM happens, we cannot reliably track
        the set of unhandled\n    // promise rejections. Throw error only when simulated
        OOM is used\n    // *and* promises are used in the test.\n    JS_ReportErrorASCII(\n
        \       cx,\n        \"Can't track unhandled rejections while running simulated
        OOM \"\n        \"test. Call ignoreUnhandledRejections before using oomTest
        etc.\");\n    return false;\n  }\n#endif\n\n  if (!sc->unhandledRejectedPromises)
        {\n    sc->unhandledRejectedPromises = SetObject::create(cx);\n    if (!sc->unhandledRejectedPromises)
        {\n      return false;\n    }\n  }\n\n  RootedValue promiseVal(cx, ObjectValue(*promise));\n\n
        \ AutoRealm ar(cx, sc->unhandledRejectedPromises);\n  if (!cx->compartment()->wrap(cx,
        &promiseVal)) {\n    return false;\n  }\n\n  switch (state) {\n    case JS::PromiseRejectionHandlingState::Unhandled:\n
        \     if (!SetObject::add(cx, sc->unhandledRejectedPromises, promiseVal))
        {\n        return false;\n      }\n      break;\n    case JS::PromiseRejectionHandlingState::Handled:\n
        \     bool deleted = false;\n      if (!SetObject::delete_(cx, sc->unhandledRejectedPromises,
        promiseVal,\n                              &deleted)) {\n        return false;\n
        \     }\n      // We can't MOZ_ASSERT(deleted) here, because it's possible
        we failed to\n      // add the promise in the first place, due to OOM.\n      break;\n
        \ }\n\n  return true;\n}\n\nstatic void ForwardingPromiseRejectionTrackerCallback(\n
        \   JSContext* cx, bool mutedErrors, JS::HandleObject promise,\n    JS::PromiseRejectionHandlingState
        state, void* data) {\n  AutoReportException are(cx);\n\n  if (!TrackUnhandledRejections(cx,
        promise, state)) {\n    return;\n  }\n\n  RootedValue callback(cx,\n                       GetShellContext(cx)->promiseRejectionTrackerCallback);\n
        \ if (callback.isNull()) {\n    return;\n  }\n\n  AutoRealm ar(cx, &callback.toObject());\n\n
        \ FixedInvokeArgs<2> args(cx);\n  args[0].setObject(*promise);\n  args[1].setInt32(static_cast<int32_t>(state));\n\n
        \ if (!JS_WrapValue(cx, args[0])) {\n    return;\n  }\n\n  RootedValue rval(cx);\n
        \ (void)Call(cx, callback, UndefinedHandleValue, args, &rval);\n}\n\nstatic
        bool SetPromiseRejectionTrackerCallback(JSContext* cx, unsigned argc,\n                                               Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!IsFunctionObject(args.get(0)))
        {\n    JS_ReportErrorASCII(\n        cx,\n        \"setPromiseRejectionTrackerCallback
        expects a function as its sole \"\n        \"argument\");\n    return false;\n
        \ }\n\n  GetShellContext(cx)->promiseRejectionTrackerCallback = args[0];\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\n// clang-format off\nstatic
        const char* telemetryNames[static_cast<int>(JSMetric::Count)] = {\n#define
        LIT(NAME, _) #NAME,\n  FOR_EACH_JS_METRIC(LIT)\n#undef LIT\n};\n// clang-format
        on\n\n// Telemetry can be executed from multiple threads, and the callback
        is\n// responsible to avoid contention on the recorded telemetry data.\nstatic
        Mutex* telemetryLock = nullptr;\nclass MOZ_RAII AutoLockTelemetry : public
        LockGuard<Mutex> {\n  using Base = LockGuard<Mutex>;\n\n public:\n  AutoLockTelemetry()
        : Base(*telemetryLock) { MOZ_ASSERT(telemetryLock); }\n};\n\nusing TelemetryData
        = uint32_t;\nusing TelemetryVec = Vector<TelemetryData, 0, SystemAllocPolicy>;\nstatic
        mozilla::Array<TelemetryVec, size_t(JSMetric::Count)> telemetryResults;\nstatic
        void AccumulateTelemetryDataCallback(JSMetric id, uint32_t sample) {\n  AutoLockTelemetry
        alt;\n  // We ignore OOMs while writting teleemtry data.\n  if (telemetryResults[static_cast<int>(id)].append(sample))
        {\n    return;\n  }\n}\n\nstatic void WriteTelemetryDataToDisk(const char*
        dir) {\n  const int pathLen = 260;\n  char fileName[pathLen];\n  Fprinter
        output;\n  auto initOutput = [&](const char* name) -> bool {\n    if (SprintfLiteral(fileName,
        \"%s%s.csv\", dir, name) >= pathLen) {\n      return false;\n    }\n    FILE*
        file = fopen(fileName, \"a\");\n    if (!file) {\n      return false;\n    }\n
        \   output.init(file);\n    return true;\n  };\n\n  for (size_t id = 0; id
        < size_t(JSMetric::Count); id++) {\n    auto clear = MakeScopeExit([&] { telemetryResults[id].clearAndFree();
        });\n    if (!initOutput(telemetryNames[id])) {\n      continue;\n    }\n
        \   for (uint32_t data : telemetryResults[id]) {\n      output.printf(\"%u\\n\",
        data);\n    }\n    output.finish();\n  }\n}\n\n#undef MAP_TELEMETRY\n\nstatic
        bool BoundToAsyncStack(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  RootedValue function(cx, GetFunctionNativeReserved(&args.callee(),
        0));\n  RootedObject options(\n      cx, &GetFunctionNativeReserved(&args.callee(),
        1).toObject());\n\n  Rooted<SavedFrame*> stack(cx, nullptr);\n  bool isExplicit;\n\n
        \ RootedValue v(cx);\n\n  if (!JS_GetProperty(cx, options, \"stack\", &v))
        {\n    return false;\n  }\n  if (!v.isObject() || !v.toObject().is<SavedFrame>())
        {\n    JS_ReportErrorASCII(cx,\n                        \"The 'stack' property
        must be a SavedFrame object.\");\n    return false;\n  }\n  stack = &v.toObject().as<SavedFrame>();\n\n
        \ if (!JS_GetProperty(cx, options, \"cause\", &v)) {\n    return false;\n
        \ }\n  RootedString causeString(cx, ToString(cx, v));\n  if (!causeString)
        {\n    MOZ_ASSERT(cx->isExceptionPending());\n    return false;\n  }\n\n  UniqueChars
        cause = JS_EncodeStringToUTF8(cx, causeString);\n  if (!cause) {\n    MOZ_ASSERT(cx->isExceptionPending());\n
        \   return false;\n  }\n\n  if (!JS_GetProperty(cx, options, \"explicit\",
        &v)) {\n    return false;\n  }\n  isExplicit = v.isUndefined() ? true : ToBoolean(v);\n\n
        \ auto kind =\n      (isExplicit ? JS::AutoSetAsyncStackForNewCalls::AsyncCallKind::EXPLICIT\n
        \                 : JS::AutoSetAsyncStackForNewCalls::AsyncCallKind::IMPLICIT);\n\n
        \ JS::AutoSetAsyncStackForNewCalls asasfnckthxbye(cx, stack, cause.get(),
        kind);\n  return Call(cx, UndefinedHandleValue, function, JS::HandleValueArray::empty(),\n
        \             args.rval());\n}\n\nstatic bool BindToAsyncStack(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 2) {\n    JS_ReportErrorASCII(cx, \"bindToAsyncStack
        takes exactly two arguments.\");\n    return false;\n  }\n\n  if (!args[0].isObject()
        || !IsCallable(args[0])) {\n    JS_ReportErrorASCII(\n        cx, \"bindToAsyncStack's
        first argument should be a function.\");\n    return false;\n  }\n\n  if (!args[1].isObject())
        {\n    JS_ReportErrorASCII(\n        cx, \"bindToAsyncStack's second argument
        should be an object.\");\n    return false;\n  }\n\n  RootedFunction bound(cx,
        NewFunctionWithReserved(cx, BoundToAsyncStack, 0, 0,\n                                                   \"bindToAsyncStack
        thunk\"));\n  if (!bound) {\n    return false;\n  }\n  SetFunctionNativeReserved(bound,
        0, args[0]);\n  SetFunctionNativeReserved(bound, 1, args[1]);\n\n  args.rval().setObject(*bound);\n
        \ return true;\n}\n\n#ifdef JS_HAS_INTL_API\nstatic bool AddIntlExtras(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (!args.get(0).isObject()) {\n    JS_ReportErrorASCII(cx, \"addIntlExtras
        must be passed an object\");\n    return false;\n  }\n  JS::RootedObject intl(cx,
        &args[0].toObject());\n\n  static const JSFunctionSpec funcs[] = {\n      JS_SELF_HOSTED_FN(\"getCalendarInfo\",
        \"Intl_getCalendarInfo\", 1, 0),\n      JS_FS_END};\n\n  if (!JS_DefineFunctions(cx,
        intl, funcs)) {\n    return false;\n  }\n\n  if (!JS::AddMozDateTimeFormatConstructor(cx,
        intl)) {\n    return false;\n  }\n\n  if (!JS::AddMozDisplayNamesConstructor(cx,
        intl)) {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return
        true;\n}\n#endif  // JS_HAS_INTL_API\n\n[[nodiscard]] static bool EvalUtf8AndPrint(JSContext*
        cx, const char* bytes,\n                                           size_t
        length, int lineno,\n                                           bool compileOnly)
        {\n  // Eval.\n  JS::CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell interactive\")\n      .setIsRunOnce(true)\n      .setFileAndLine(\"typein\",
        lineno)\n      .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \ JS::SourceText<Utf8Unit> srcBuf;\n  if (!srcBuf.init(cx, bytes, length,
        JS::SourceOwnership::Borrowed)) {\n    return false;\n  }\n\n  RootedScript
        script(cx, JS::Compile(cx, options, srcBuf));\n  if (!script) {\n    return
        false;\n  }\n  if (compileOnly) {\n    return true;\n  }\n  RootedValue result(cx);\n
        \ if (!JS_ExecuteScript(cx, script, &result)) {\n    return false;\n  }\n\n
        \ if (!result.isUndefined() && gOutFile->isOpen()) {\n    // Print.\n    RootedString
        str(cx, JS_ValueToSource(cx, result));\n    if (!str) {\n      return false;\n
        \   }\n\n    UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, str);\n    if
        (!utf8chars) {\n      return false;\n    }\n    fprintf(gOutFile->fp, \"%s\\n\",
        utf8chars.get());\n  }\n  return true;\n}\n\n[[nodiscard]] static bool ReadEvalPrintLoop(JSContext*
        cx, FILE* in,\n                                            bool compileOnly)
        {\n  ShellContext* sc = GetShellContext(cx);\n  int lineno = 1;\n  bool hitEOF
        = false;\n\n  do {\n    /*\n     * Accumulate lines until we get a 'compilable
        unit' - one that either\n     * generates an error (before running out of
        source) or that compiles\n     * cleanly.  This should be whenever we get
        a complete statement that\n     * coincides with the end of a line.\n     */\n
        \   int startline = lineno;\n    typedef Vector<char, 32> CharBuffer;\n    RootedObject
        globalLexical(cx, &cx->global()->lexicalEnvironment());\n    CharBuffer buffer(cx);\n
        \   do {\n      ScheduleWatchdog(cx, -1);\n      sc->serviceInterrupt = false;\n
        \     errno = 0;\n\n      mozilla::UniqueFreePtr<char[]> line =\n          GetLine(in,
        startline == lineno ? \"js> \" : \"\");\n      if (!line) {\n        if (errno)
        {\n          if (UniqueChars error = SystemErrorMessage(cx, errno)) {\n            JS_ReportErrorUTF8(cx,
        \"%s\", error.get());\n          }\n          return false;\n        }\n        hitEOF
        = true;\n        break;\n      }\n\n      if (!buffer.append(line.get(), strlen(line.get()))
        ||\n          !buffer.append('\\n')) {\n        return false;\n      }\n\n
        \     lineno++;\n      if (!ScheduleWatchdog(cx, sc->timeoutInterval)) {\n
        \       hitEOF = true;\n        break;\n      }\n    } while (!JS_Utf8BufferIsCompilableUnit(cx,
        cx->global(), buffer.begin(),\n                                            buffer.length()));\n\n
        \   if (hitEOF && buffer.empty()) {\n      break;\n    }\n\n    {\n      //
        Report exceptions but keep going.\n      AutoReportException are(cx);\n      (void)EvalUtf8AndPrint(cx,
        buffer.begin(), buffer.length(), startline,\n                             compileOnly);\n
        \   }\n\n    // If a let or const fail to initialize they will remain in an
        unusable\n    // without further intervention. This call cleans up the global
        scope,\n    // setting uninitialized lexicals to undefined so that they may
        still\n    // be used. This behavior is _only_ acceptable in the context of
        the repl.\n    if (JS::ForceLexicalInitialization(cx, globalLexical) &&\n
        \       gErrFile->isOpen()) {\n      fputs(\n          \"Warning: According
        to the standard, after the above exception,\\n\"\n          \"Warning: the
        global bindings should be permanently uninitialized.\\n\"\n          \"Warning:
        We have non-standard-ly initialized them to `undefined`\"\n          \"for
        you.\\nWarning: This nicety only happens in the JS shell.\\n\",\n          stderr);\n
        \   }\n\n    RunShellJobs(cx);\n  } while (!hitEOF && !sc->quitting);\n\n
        \ if (gOutFile->isOpen()) {\n    fprintf(gOutFile->fp, \"\\n\");\n  }\n\n
        \ return true;\n}\n\nenum FileKind {\n  PreludeScript,    // UTF-8 script,
        fully-parsed, to avoid conflicting\n                    // configurations.\n
        \ FileScript,       // UTF-8, directly parsed as such\n  FileScriptUtf16,
        \ // FileScript, but inflate to UTF-16 before parsing\n  FileModule,\n};\n\n[[nodiscard]]
        static bool Process(JSContext* cx, const char* filename,\n                                  bool
        forceTTY, FileKind kind) {\n  FILE* file;\n  if (forceTTY || !filename ||
        strcmp(filename, \"-\") == 0) {\n    file = stdin;\n  } else {\n    file =
        OpenFile(cx, filename, \"rb\");\n    if (!file) {\n      return false;\n    }\n
        \ }\n  AutoCloseFile autoClose(file);\n\n  bool fullParse = false;\n  if (!forceTTY
        && !isatty(fileno(file))) {\n    // It's not interactive - just execute it.\n
        \   switch (kind) {\n      case PreludeScript:\n        fullParse = true;\n
        \       if (!RunFile(cx, filename, file, CompileUtf8::DontInflate, compileOnly,\n
        \                    fullParse)) {\n          return false;\n        }\n        break;\n
        \     case FileScript:\n        if (!RunFile(cx, filename, file, CompileUtf8::DontInflate,
        compileOnly,\n                     fullParse)) {\n          return false;\n
        \       }\n        break;\n      case FileScriptUtf16:\n        if (!RunFile(cx,
        filename, file, CompileUtf8::InflateToUtf16,\n                     compileOnly,
        fullParse)) {\n          return false;\n        }\n        break;\n      case
        FileModule:\n        if (!RunModule(cx, filename, compileOnly)) {\n          return
        false;\n        }\n        break;\n      default:\n        MOZ_CRASH(\"Impossible
        FileKind!\");\n    }\n  } else {\n    // It's an interactive filehandle; drop
        into read-eval-print loop.\n    MOZ_ASSERT(kind == FileScript);\n    if (!ReadEvalPrintLoop(cx,
        file, compileOnly)) {\n      return false;\n    }\n  }\n#ifdef FUZZING_JS_FUZZILLI\n
        \ fprintf(stderr, \"executionHash is 0x%x with %d inputs\\n\", cx->executionHash,\n
        \         cx->executionHashInputs);\n#endif\n  return true;\n}\n\n#ifdef XP_WIN\n#
        \ define GET_FD_FROM_FILE(a) int(_get_osfhandle(fileno(a)))\n#else\n#  define
        GET_FD_FROM_FILE(a) fileno(a)\n#endif\n\nstatic void freeExternalCallback(void*
        contents, void* userData) {\n  MOZ_ASSERT(!userData);\n  js_free(contents);\n}\n\nstatic
        bool CreateExternalArrayBuffer(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length() != 1) {\n
        \   JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage, nullptr,\n
        \       args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"createExternalArrayBuffer\");\n    return false;\n  }\n\n  int32_t
        bytes = 0;\n  if (!ToInt32(cx, args[0], &bytes)) {\n    return false;\n  }\n\n
        \ if (bytes < 0) {\n    JS_ReportErrorASCII(cx, \"Size must be non-negative\");\n
        \   return false;\n  }\n\n  void* buffer = js_malloc(bytes);\n  if (!buffer)
        {\n    JS_ReportOutOfMemory(cx);\n    return false;\n  }\n\n  RootedObject
        arrayBuffer(\n      cx, JS::NewExternalArrayBuffer(cx, bytes, buffer, &freeExternalCallback));\n
        \ if (!arrayBuffer) {\n    return false;\n  }\n\n  args.rval().setObject(*arrayBuffer);\n
        \ return true;\n}\n\nstatic bool CreateMappedArrayBuffer(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        < 1 || args.length() > 3) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage,
        nullptr,\n        args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"createMappedArrayBuffer\");\n    return false;\n  }\n\n  RootedString
        rawFilenameStr(cx, JS::ToString(cx, args[0]));\n  if (!rawFilenameStr) {\n
        \   return false;\n  }\n  // It's a little bizarre to resolve relative to
        the script, but for testing\n  // I need a file at a known location, and the
        only good way I know of to do\n  // that right now is to include it in the
        repo alongside the test script.\n  // Bug 944164 would introduce an alternative.\n
        \ Rooted<JSString*> filenameStr(\n      cx, ResolvePath(cx, rawFilenameStr,
        ScriptRelative));\n  if (!filenameStr) {\n    return false;\n  }\n  UniqueChars
        filename = JS_EncodeStringToUTF8(cx, filenameStr);\n  if (!filename) {\n    return
        false;\n  }\n\n  uint32_t offset = 0;\n  if (args.length() >= 2) {\n    if
        (!JS::ToUint32(cx, args[1], &offset)) {\n      return false;\n    }\n  }\n\n
        \ bool sizeGiven = false;\n  uint32_t size;\n  if (args.length() >= 3) {\n
        \   if (!JS::ToUint32(cx, args[2], &size)) {\n      return false;\n    }\n
        \   sizeGiven = true;\n    if (size == 0) {\n      JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr,\n                                JSMSG_BAD_ARRAY_LENGTH);\n
        \     return false;\n    }\n  }\n\n  FILE* file = OpenFile(cx, filename.get(),
        \"rb\");\n  if (!file) {\n    return false;\n  }\n  AutoCloseFile autoClose(file);\n\n
        \ struct stat st;\n  if (fstat(fileno(file), &st) < 0) {\n    JS_ReportErrorASCII(cx,
        \"Unable to stat file\");\n    return false;\n  }\n\n  if ((st.st_mode & S_IFMT)
        != S_IFREG) {\n    JS_ReportErrorASCII(cx, \"Path is not a regular file\");\n
        \   return false;\n  }\n\n  if (!sizeGiven) {\n    if (off_t(offset) >= st.st_size)
        {\n      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,\n                                JSMSG_OFFSET_LARGER_THAN_FILESIZE);\n
        \     return false;\n    }\n    size = st.st_size - offset;\n  }\n\n  void*
        contents =\n      JS::CreateMappedArrayBufferContents(GET_FD_FROM_FILE(file),
        offset, size);\n  if (!contents) {\n    JS_ReportErrorASCII(cx,\n                        \"failed
        to allocate mapped array buffer contents \"\n                        \"(possibly
        due to bad alignment)\");\n    return false;\n  }\n\n  RootedObject obj(cx,\n
        \                  JS::NewMappedArrayBufferWithContents(cx, size, contents));\n
        \ if (!obj) {\n    return false;\n  }\n\n  args.rval().setObject(*obj);\n
        \ return true;\n}\n\n#undef GET_FD_FROM_FILE\n\nstatic bool AddPromiseReactions(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 3) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage,
        nullptr,\n        args.length() < 3 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"addPromiseReactions\");\n    return false;\n  }\n\n  RootedObject
        promise(cx);\n  if (args[0].isObject()) {\n    promise = &args[0].toObject();\n
        \ }\n\n  if (!promise || !JS::IsPromiseObject(promise)) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"addPromiseReactions\");\n    return false;\n  }\n\n  RootedObject onResolve(cx);\n
        \ if (args[1].isObject()) {\n    onResolve = &args[1].toObject();\n  }\n\n
        \ RootedObject onReject(cx);\n  if (args[2].isObject()) {\n    onReject =
        &args[2].toObject();\n  }\n\n  if (!onResolve || !onResolve->is<JSFunction>()
        || !onReject ||\n      !onReject->is<JSFunction>()) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"addPromiseReactions\");\n    return false;\n  }\n\n  return JS::AddPromiseReactions(cx,
        promise, onResolve, onReject);\n}\n\nstatic bool IgnoreUnhandledRejections(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ ShellContext* sc = GetShellContext(cx);\n  sc->trackUnhandledRejections
        = false;\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic bool
        Options(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  JS::ContextOptions oldContextOptions = JS::ContextOptionsRef(cx);\n
        \ for (unsigned i = 0; i < args.length(); i++) {\n    RootedString str(cx,
        JS::ToString(cx, args[i]));\n    if (!str) {\n      return false;\n    }\n\n
        \   Rooted<JSLinearString*> opt(cx, str->ensureLinear(cx));\n    if (!opt)
        {\n      return false;\n    }\n\n    if (StringEqualsLiteral(opt, \"throw_on_asmjs_validation_failure\"))
        {\n      JS::ContextOptionsRef(cx).toggleThrowOnAsmJSValidationFailure();\n
        \   } else if (StringEqualsLiteral(opt, \"strict_mode\")) {\n      JS::ContextOptionsRef(cx).toggleStrictMode();\n
        \   } else {\n      UniqueChars optChars = QuoteString(cx, opt, '\"');\n      if
        (!optChars) {\n        return false;\n      }\n\n      JS_ReportErrorASCII(cx,\n
        \                         \"unknown option name %s.\"\n                          \"
        The valid names are \"\n                          \"throw_on_asmjs_validation_failure
        and strict_mode.\",\n                          optChars.get());\n      return
        false;\n    }\n  }\n\n  UniqueChars names = DuplicateString(\"\");\n  bool
        found = false;\n  if (names && oldContextOptions.throwOnAsmJSValidationFailure())
        {\n    names = JS_sprintf_append(std::move(names), \"%s%s\", found ? \",\"
        : \"\",\n                              \"throw_on_asmjs_validation_failure\");\n
        \   found = true;\n  }\n  if (names && oldContextOptions.strictMode()) {\n
        \   names = JS_sprintf_append(std::move(names), \"%s%s\", found ? \",\" :
        \"\",\n                              \"strict_mode\");\n    found = true;\n
        \ }\n  if (!names) {\n    JS_ReportOutOfMemory(cx);\n    return false;\n  }\n\n
        \ JSString* str = JS_NewStringCopyZ(cx, names.get());\n  if (!str) {\n    return
        false;\n  }\n  args.rval().setString(str);\n  return true;\n}\n\nstatic bool
        LoadScript(JSContext* cx, unsigned argc, Value* vp,\n                       bool
        scriptRelative) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  RootedString
        str(cx);\n  for (unsigned i = 0; i < args.length(); i++) {\n    str = JS::ToString(cx,
        args[i]);\n    if (!str) {\n      JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                                JSSMSG_INVALID_ARGS, \"load\");\n
        \     return false;\n    }\n\n    str = ResolvePath(cx, str, scriptRelative
        ? ScriptRelative : RootRelative);\n    if (!str) {\n      JS_ReportErrorASCII(cx,
        \"unable to resolve path\");\n      return false;\n    }\n\n    UniqueChars
        filename = JS_EncodeStringToUTF8(cx, str);\n    if (!filename) {\n      return
        false;\n    }\n\n    errno = 0;\n\n    CompileOptions opts(cx);\n    opts.setIntroductionType(\"js
        shell load\")\n        .setIsRunOnce(true)\n        .setNoScriptRval(true)\n
        \       .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n    RootedValue
        unused(cx);\n    if (!(compileOnly\n              ? JS::CompileUtf8Path(cx,
        opts, filename.get()) != nullptr\n              : JS::EvaluateUtf8Path(cx,
        opts, filename.get(), &unused))) {\n      return false;\n    }\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool Load(JSContext* cx, unsigned argc, Value*
        vp) {\n  return LoadScript(cx, argc, vp, false);\n}\n\nstatic bool LoadScriptRelativeToScript(JSContext*
        cx, unsigned argc,\n                                       Value* vp) {\n
        \ return LoadScript(cx, argc, vp, true);\n}\n\nstatic void my_LargeAllocFailCallback()
        {\n  JSContext* cx = TlsContext.get();\n  if (!cx || cx->isHelperThreadContext())
        {\n    return;\n  }\n\n  MOZ_ASSERT(!JS::RuntimeHeapIsBusy());\n\n  JS::PrepareForFullGC(cx);\n
        \ cx->runtime()->gc.gc(JS::GCOptions::Shrink,\n                       JS::GCReason::SHARED_MEMORY_LIMIT);\n}\n\nstatic
        const uint32_t CacheEntry_SOURCE = 0;\nstatic const uint32_t CacheEntry_BYTECODE
        = 1;\nstatic const uint32_t CacheEntry_OPTIONS = 2;\n\n// Some compile options
        can't be combined differently between save and load.\n//\n// CacheEntries
        store a CacheOption set, and on load an exception is thrown\n// if the entries
        are incompatible.\n\nenum CacheOptions : uint32_t {\n  IsRunOnce,\n  NoScriptRval,\n
        \ Global,\n  NonSyntactic,\n  SourceIsLazy,\n  ForceFullParse,\n};\n\nstruct
        CacheOptionSet : public mozilla::EnumSet<CacheOptions> {\n  using mozilla::EnumSet<CacheOptions>::EnumSet;\n\n
        \ explicit CacheOptionSet(const CompileOptions& options) : EnumSet() {\n    initFromOptions(options);\n
        \ }\n\n  void initFromOptions(const CompileOptions& options) {\n    if (options.noScriptRval)
        {\n      *this += CacheOptions::NoScriptRval;\n    }\n    if (options.isRunOnce)
        {\n      *this += CacheOptions::IsRunOnce;\n    }\n    if (options.sourceIsLazy)
        {\n      *this += CacheOptions::SourceIsLazy;\n    }\n    if (options.forceFullParse())
        {\n      *this += CacheOptions::ForceFullParse;\n    }\n    if (options.nonSyntacticScope)
        {\n      *this += CacheOptions::NonSyntactic;\n    }\n  }\n};\n\nstatic bool
        CacheOptionsCompatible(const CacheOptionSet& a,\n                                   const
        CacheOptionSet& b) {\n  // If the options are identical, they are trivially
        compatible.\n  return a == b;\n}\n\nstatic const JSClass CacheEntry_class
        = {\"CacheEntryObject\",\n                                         JSCLASS_HAS_RESERVED_SLOTS(3)};\n\nstatic
        bool CacheEntry(JSContext* cx, unsigned argc, JS::Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 1 || !args[0].isString())
        {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"CacheEntry\");\n    return false;\n  }\n\n  RootedObject obj(cx, JS_NewObject(cx,
        &CacheEntry_class));\n  if (!obj) {\n    return false;\n  }\n\n  JS::SetReservedSlot(obj,
        CacheEntry_SOURCE, args[0]);\n  JS::SetReservedSlot(obj, CacheEntry_BYTECODE,
        UndefinedValue());\n\n  // Fill in empty option set.\n  CacheOptionSet defaultOptions;\n
        \ JS::SetReservedSlot(obj, CacheEntry_OPTIONS,\n                      Int32Value(defaultOptions.serialize()));\n\n
        \ args.rval().setObject(*obj);\n  return true;\n}\n\nstatic bool CacheEntry_isCacheEntry(JSObject*
        cache) {\n  return cache->hasClass(&CacheEntry_class);\n}\n\nstatic JSString*
        CacheEntry_getSource(JSContext* cx, HandleObject cache) {\n  MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n
        \ Value v = JS::GetReservedSlot(cache, CacheEntry_SOURCE);\n  if (!v.isString())
        {\n    JS_ReportErrorASCII(\n        cx, \"CacheEntry_getSource: Unexpected
        type of source reserved slot.\");\n    return nullptr;\n  }\n\n  return v.toString();\n}\n\nstatic
        bool CacheEntry_compatible(JSContext* cx, HandleObject cache,\n                                  const
        CacheOptionSet& currentOptionSet) {\n  CacheOptionSet cacheEntryOptions;\n
        \ MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n  Value v = JS::GetReservedSlot(cache,
        CacheEntry_OPTIONS);\n  cacheEntryOptions.deserialize(v.toInt32());\n  if
        (!CacheOptionsCompatible(cacheEntryOptions, currentOptionSet)) {\n    JS_ReportErrorASCII(cx,\n
        \                       \"CacheEntry_compatible: Incompatible cache contents\");\n
        \   return false;\n  }\n  return true;\n}\n\nstatic uint8_t* CacheEntry_getBytecode(JSContext*
        cx, HandleObject cache,\n                                       size_t* length)
        {\n  MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n  Value v = JS::GetReservedSlot(cache,
        CacheEntry_BYTECODE);\n  if (!v.isObject() || !v.toObject().is<ArrayBufferObject>())
        {\n    JS_ReportErrorASCII(\n        cx,\n        \"CacheEntry_getBytecode:
        Unexpected type of bytecode reserved slot.\");\n    return nullptr;\n  }\n\n
        \ ArrayBufferObject* arrayBuffer = &v.toObject().as<ArrayBufferObject>();\n
        \ *length = arrayBuffer->byteLength();\n  return arrayBuffer->dataPointer();\n}\n\nstatic
        bool CacheEntry_setBytecode(JSContext* cx, HandleObject cache,\n                                   const
        CacheOptionSet& cacheOptions,\n                                   uint8_t*
        buffer, uint32_t length) {\n  MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n\n
        \ using BufferContents = ArrayBufferObject::BufferContents;\n\n  BufferContents
        contents = BufferContents::createMalloced(buffer);\n  Rooted<ArrayBufferObject*>
        arrayBuffer(\n      cx, ArrayBufferObject::createForContents(cx, length, contents));\n
        \ if (!arrayBuffer) {\n    return false;\n  }\n\n  JS::SetReservedSlot(cache,
        CacheEntry_BYTECODE, ObjectValue(*arrayBuffer));\n  JS::SetReservedSlot(cache,
        CacheEntry_OPTIONS,\n                      Int32Value(cacheOptions.serialize()));\n
        \ return true;\n}\n\nstatic bool ConvertTranscodeResultToJSException(JSContext*
        cx,\n                                                JS::TranscodeResult rv)
        {\n  switch (rv) {\n    case JS::TranscodeResult::Ok:\n      return true;\n\n
        \   default:\n      [[fallthrough]];\n    case JS::TranscodeResult::Failure:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"generic warning\");\n      return false;\n    case JS::TranscodeResult::Failure_BadBuildId:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"the build-id does not match\");\n      return false;\n    case JS::TranscodeResult::Failure_AsmJSNotSupported:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"Asm.js is not supported by XDR\");\n      return false;\n    case JS::TranscodeResult::Failure_BadDecode:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"XDR data corruption\");\n      return false;\n\n    case JS::TranscodeResult::Throw:\n
        \     MOZ_ASSERT(cx->isExceptionPending());\n      return false;\n  }\n}\n\nstatic
        bool Evaluate(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  if (args.length() < 1 || args.length() >
        2) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage, nullptr,\n
        \       args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"evaluate\");\n    return false;\n  }\n\n  RootedString code(cx,
        nullptr);\n  RootedObject cacheEntry(cx, nullptr);\n  if (args[0].isString())
        {\n    code = args[0].toString();\n  } else if (args[0].isObject() &&\n             CacheEntry_isCacheEntry(&args[0].toObject()))
        {\n    cacheEntry = &args[0].toObject();\n    code = CacheEntry_getSource(cx,
        cacheEntry);\n    if (!code) {\n      return false;\n    }\n  }\n\n  if (!code
        || (args.length() == 2 && args[1].isPrimitive())) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"evaluate\");\n    return false;\n  }\n\n  RootedObject opts(cx);\n  if (args.length()
        == 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(cx, \"evaluate:
        The 2nd argument must be an object\");\n      return false;\n    }\n\n    opts
        = &args[1].toObject();\n  }\n\n  RootedObject global(cx, JS::CurrentGlobalOrNull(cx));\n
        \ MOZ_ASSERT(global);\n\n  // Check \"global\" property before everything
        to use the given global's\n  // option as the default value.\n  Maybe<CompileOptions>
        maybeOptions;\n  if (opts) {\n    RootedValue v(cx);\n    if (!JS_GetProperty(cx,
        opts, \"global\", &v)) {\n      return false;\n    }\n    if (!v.isUndefined())
        {\n      if (v.isObject()) {\n        global = js::CheckedUnwrapDynamic(&v.toObject(),
        cx,\n                                          /* stopAtWindowProxy = */ false);\n
        \       if (!global) {\n          return false;\n        }\n      }\n      if
        (!global || !(JS::GetClass(global)->flags & JSCLASS_IS_GLOBAL)) {\n        JS_ReportErrorNumberASCII(\n
        \           cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,\n            \"\\\"global\\\"
        passed to evaluate()\", \"not a global object\");\n        return false;\n
        \     }\n\n      JSAutoRealm ar(cx, global);\n      maybeOptions.emplace(cx);\n
        \   }\n  }\n  if (!maybeOptions) {\n    // If \"global\" property is not given,
        use the current global's option as\n    // the default value.\n    maybeOptions.emplace(cx);\n
        \ }\n\n  CompileOptions& options = maybeOptions.ref();\n  UniqueChars fileNameBytes;\n
        \ RootedString displayURL(cx);\n  RootedString sourceMapURL(cx);\n  bool catchTermination
        = false;\n  bool loadBytecode = false;\n  bool saveIncrementalBytecode = false;\n
        \ bool execute = true;\n  bool assertEqBytecode = false;\n  JS::RootedObjectVector
        envChain(cx);\n  RootedObject callerGlobal(cx, cx->global());\n\n  options.setIntroductionType(\"js
        shell evaluate\")\n      .setFileAndLine(\"@evaluate\", 1)\n      .setDeferDebugMetadata();\n\n
        \ RootedValue privateValue(cx);\n  RootedString elementAttributeName(cx);\n\n
        \ if (opts) {\n    if (!js::ParseCompileOptions(cx, options, opts, &fileNameBytes))
        {\n      return false;\n    }\n    if (!ParseDebugMetadata(cx, opts, &privateValue,
        &elementAttributeName)) {\n      return false;\n    }\n    if (!ParseSourceOptions(cx,
        opts, &displayURL, &sourceMapURL)) {\n      return false;\n    }\n\n    RootedValue
        v(cx);\n    if (!JS_GetProperty(cx, opts, \"catchTermination\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      catchTermination = ToBoolean(v);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"loadBytecode\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      loadBytecode = ToBoolean(v);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"saveIncrementalBytecode\", &v))
        {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      saveIncrementalBytecode
        = ToBoolean(v);\n    }\n\n    if (!JS_GetProperty(cx, opts, \"execute\", &v))
        {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      execute
        = ToBoolean(v);\n    }\n\n    if (!JS_GetProperty(cx, opts, \"assertEqBytecode\",
        &v)) {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      assertEqBytecode
        = ToBoolean(v);\n    }\n\n    if (!JS_GetProperty(cx, opts, \"envChainObject\",
        &v)) {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      if
        (!v.isObject()) {\n        JS_ReportErrorNumberASCII(\n            cx, GetErrorMessage,
        nullptr, JSMSG_UNEXPECTED_TYPE,\n            \"\\\"envChainObject\\\" passed
        to evaluate()\", \"not an object\");\n        return false;\n      }\n\n      JSObject*
        obj = &v.toObject();\n      if (obj->isUnqualifiedVarObj()) {\n        JS_ReportErrorASCII(\n
        \           cx,\n            \"\\\"envChainObject\\\" passed to evaluate()
        should not be an \"\n            \"unqualified variables object\");\n        return
        false;\n      }\n\n      if (!envChain.append(obj)) {\n        return false;\n
        \     }\n    }\n\n    // We cannot load or save the bytecode if we have no
        object where the\n    // bytecode cache is stored.\n    if (loadBytecode ||
        saveIncrementalBytecode) {\n      if (!cacheEntry) {\n        JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                                  JSSMSG_INVALID_ARGS,
        \"evaluate\");\n        return false;\n      }\n    }\n  }\n\n  if (envChain.length()
        != 0) {\n    // Wrap the envChainObject list into target realm.\n    JSAutoRealm
        ar(cx, global);\n    for (size_t i = 0; i < envChain.length(); ++i) {\n      if
        (!JS_WrapObject(cx, envChain[i])) {\n        return false;\n      }\n    }\n\n
        \   options.setNonSyntacticScope(true);\n  }\n\n  // The `loadBuffer` we use
        below outlives the Stencil we generate so we can\n  // use its contents directly
        in the Stencil.\n  options.borrowBuffer = true;\n\n  // We need to track the
        options used to generate bytecode for a CacheEntry to\n  // avoid mismatches.
        This is primarily a concern when fuzzing the jsshell.\n  CacheOptionSet cacheOptions;\n
        \ cacheOptions.initFromOptions(options);\n\n  JS::TranscodeBuffer loadBuffer;\n
        \ JS::TranscodeBuffer saveBuffer;\n\n  if (loadBytecode) {\n    size_t loadLength
        = 0;\n    uint8_t* loadData = nullptr;\n\n    if (!CacheEntry_compatible(cx,
        cacheEntry, cacheOptions)) {\n      return false;\n    }\n\n    loadData =
        CacheEntry_getBytecode(cx, cacheEntry, &loadLength);\n    if (!loadData) {\n
        \     return false;\n    }\n    if (!loadBuffer.append(loadData, loadLength))
        {\n      JS_ReportOutOfMemory(cx);\n      return false;\n    }\n  }\n\n  {\n
        \   JSAutoRealm ar(cx, global);\n    RefPtr<JS::Stencil> stencil;\n\n    if
        (loadBytecode) {\n      JS::TranscodeRange range(loadBuffer.begin(), loadBuffer.length());\n
        \     JS::DecodeOptions decodeOptions(options);\n\n      JS::TranscodeResult
        rv =\n          JS::DecodeStencil(cx, decodeOptions, range, getter_AddRefs(stencil));\n
        \     if (!ConvertTranscodeResultToJSException(cx, rv)) {\n        return
        false;\n      }\n    } else {\n      AutoStableStringChars linearChars(cx);\n
        \     if (!linearChars.initTwoByte(cx, code)) {\n        return false;\n      }\n\n
        \     JS::SourceText<char16_t> srcBuf;\n      if (!srcBuf.initMaybeBorrowed(cx,
        linearChars)) {\n        return false;\n      }\n\n      stencil = JS::CompileGlobalScriptToStencil(cx,
        options, srcBuf);\n      if (!stencil) {\n        return false;\n      }\n
        \   }\n\n    JS::InstantiateOptions instantiateOptions(options);\n    RootedScript
        script(\n        cx, JS::InstantiateGlobalStencil(cx, instantiateOptions,
        stencil));\n    if (!script) {\n      return false;\n    }\n\n    AutoReportFrontendContext
        fc(cx);\n    if (!SetSourceOptions(cx, &fc, script->scriptSource(), displayURL,\n
        \                         sourceMapURL)) {\n      return false;\n    }\n\n
        \   if (!JS::UpdateDebugMetadata(cx, script, instantiateOptions, privateValue,\n
        \                                elementAttributeName, nullptr, nullptr))
        {\n      return false;\n    }\n\n    if (saveIncrementalBytecode) {\n      if
        (!JS::StartIncrementalEncoding(cx, std::move(stencil))) {\n        return
        false;\n      }\n    }\n\n    if (execute) {\n      if (!(envChain.empty()\n
        \               ? JS_ExecuteScript(cx, script, args.rval())\n                :
        JS_ExecuteScript(cx, envChain, script, args.rval()))) {\n        if (catchTermination
        && !JS_IsExceptionPending(cx)) {\n          JSAutoRealm ar1(cx, callerGlobal);\n
        \         JSString* str = JS_NewStringCopyZ(cx, \"terminated\");\n          if
        (!str) {\n            return false;\n          }\n          args.rval().setString(str);\n
        \         return true;\n        }\n        return false;\n      }\n    }\n\n
        \   // Serialize the encoded bytecode, recorded before the execution, into
        a\n    // buffer which can be deserialized linearly.\n    if (saveIncrementalBytecode)
        {\n      if (!FinishIncrementalEncoding(cx, script, saveBuffer)) {\n        return
        false;\n      }\n    }\n  }\n\n  if (saveIncrementalBytecode) {\n    // If
        we are both loading and saving, we assert that we are going to\n    // replace
        the current bytecode by the same stream of bytes.\n    if (loadBytecode &&
        assertEqBytecode) {\n      if (saveBuffer.length() != loadBuffer.length())
        {\n        char loadLengthStr[16];\n        SprintfLiteral(loadLengthStr,
        \"%zu\", loadBuffer.length());\n        char saveLengthStr[16];\n        SprintfLiteral(saveLengthStr,
        \"%zu\", saveBuffer.length());\n\n        JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                                  JSSMSG_CACHE_EQ_SIZE_FAILED, loadLengthStr,\n
        \                                 saveLengthStr);\n        return false;\n
        \     }\n\n      if (!ArrayEqual(loadBuffer.begin(), saveBuffer.begin(),\n
        \                     loadBuffer.length())) {\n        JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                                  JSSMSG_CACHE_EQ_CONTENT_FAILED);\n
        \       return false;\n      }\n    }\n\n    size_t saveLength = saveBuffer.length();\n
        \   if (saveLength >= INT32_MAX) {\n      JS_ReportErrorASCII(cx, \"Cannot
        save large cache entry content\");\n      return false;\n    }\n    uint8_t*
        saveData = saveBuffer.extractOrCopyRawBuffer();\n    if (!CacheEntry_setBytecode(cx,
        cacheEntry, cacheOptions, saveData,\n                                saveLength))
        {\n      js_free(saveData);\n      return false;\n    }\n  }\n\n  return JS_WrapValue(cx,
        args.rval());\n}\n\nJSString* js::shell::FileAsString(JSContext* cx, JS::HandleString
        pathnameStr) {\n  UniqueChars pathname = JS_EncodeStringToUTF8(cx, pathnameStr);\n
        \ if (!pathname) {\n    return nullptr;\n  }\n\n  FILE* file = OpenFile(cx,
        pathname.get(), \"rb\");\n  if (!file) {\n    return nullptr;\n  }\n\n  AutoCloseFile
        autoClose(file);\n\n  struct stat st;\n  if (fstat(fileno(file), &st) != 0)
        {\n    JS_ReportErrorUTF8(cx, \"can't stat %s\", pathname.get());\n    return
        nullptr;\n  }\n\n  if ((st.st_mode & S_IFMT) != S_IFREG) {\n    JS_ReportErrorUTF8(cx,
        \"can't read non-regular file %s\", pathname.get());\n    return nullptr;\n
        \ }\n\n  size_t len;\n  if (!FileSize(cx, pathname.get(), file, &len)) {\n
        \   return nullptr;\n  }\n\n  UniqueChars buf(js_pod_malloc<char>(len + 1));\n
        \ if (!buf) {\n    JS_ReportErrorUTF8(cx, \"out of memory reading %s\", pathname.get());\n
        \   return nullptr;\n  }\n\n  if (!ReadFile(cx, pathname.get(), file, buf.get(),
        len)) {\n    return nullptr;\n  }\n\n  UniqueTwoByteChars ucbuf(\n      JS::LossyUTF8CharsToNewTwoByteCharsZ(cx,
        JS::UTF8Chars(buf.get(), len),\n                                           &len,
        js::MallocArena)\n          .get());\n  if (!ucbuf) {\n    JS_ReportErrorUTF8(cx,
        \"Invalid UTF-8 in file '%s'\", pathname.get());\n    return nullptr;\n  }\n\n
        \ return JS_NewUCStringCopyN(cx, ucbuf.get(), len);\n}\n\n/*\n * Function
        to run scripts and return compilation + execution time. Semantics\n * are
        closely modelled after the equivalent function in WebKit, as this is used\n
        * to produce benchmark timings by SunSpider.\n */\nstatic bool Run(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (args.length() != 1) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS, \"run\");\n    return
        false;\n  }\n\n  RootedString str(cx, JS::ToString(cx, args[0]));\n  if (!str)
        {\n    return false;\n  }\n  args[0].setString(str);\n\n  str = FileAsString(cx,
        str);\n  if (!str) {\n    return false;\n  }\n\n  AutoStableStringChars linearChars(cx);\n
        \ if (!linearChars.initTwoByte(cx, str)) {\n    return false;\n  }\n\n  JS::SourceText<char16_t>
        srcBuf;\n  if (!srcBuf.initMaybeBorrowed(cx, linearChars)) {\n    return false;\n
        \ }\n\n  RootedScript script(cx);\n  int64_t startClock = PRMJ_Now();\n  {\n
        \   UniqueChars filename = JS_EncodeStringToUTF8(cx, str);\n    if (!filename)
        {\n      return false;\n    }\n\n    JS::CompileOptions options(cx);\n    options.setIntroductionType(\"js
        shell run\")\n        .setFileAndLine(filename.get(), 1)\n        .setIsRunOnce(true)\n
        \       .setNoScriptRval(true)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   script = JS::Compile(cx, options, srcBuf);\n    if (!script) {\n      return
        false;\n    }\n  }\n\n  if (!JS_ExecuteScript(cx, script)) {\n    return false;\n
        \ }\n\n  int64_t endClock = PRMJ_Now();\n\n  args.rval().setDouble((endClock
        - startClock) / double(PRMJ_USEC_PER_MSEC));\n  return true;\n}\n\nstatic
        int js_fgets(char* buf, int size, FILE* file) {\n  int n, i, c;\n  bool crflag;\n\n
        \ n = size - 1;\n  if (n < 0) {\n    return -1;\n  }\n\n  // Use the fastest
        available getc.\n  auto fast_getc =\n#if defined(HAVE_GETC_UNLOCKED)\n      getc_unlocked\n#elif
        defined(HAVE__GETC_NOLOCK)\n      _getc_nolock\n#else\n      getc\n#endif\n
        \     ;\n\n  crflag = false;\n  for (i = 0; i < n && (c = fast_getc(file))
        != EOF; i++) {\n    buf[i] = c;\n    if (c == '\\n') {  // any \\n ends a
        line\n      i++;            // keep the \\n; we know there is room for \\0\n
        \     break;\n    }\n    if (crflag) {  // \\r not followed by \\n ends line
        at the \\r\n      ungetc(c, file);\n      break;  // and overwrite c in buf
        with \\0\n    }\n    crflag = (c == '\\r');\n  }\n\n  buf[i] = '\\0';\n  return
        i;\n}\n\n/*\n * function readline()\n * Provides a hook for scripts to read
        a line from stdin.\n */\nstatic bool ReadLine(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  static constexpr
        size_t BUFSIZE = 256;\n  FILE* from = stdin;\n  size_t buflength = 0;\n  size_t
        bufsize = BUFSIZE;\n  char* buf = (char*)JS_malloc(cx, bufsize);\n  if (!buf)
        {\n    return false;\n  }\n\n  bool sawNewline = false;\n  size_t gotlength;\n
        \ while ((gotlength = js_fgets(buf + buflength, bufsize - buflength, from))
        >\n         0) {\n    buflength += gotlength;\n\n    /* Are we done? */\n
        \   if (buf[buflength - 1] == '\\n') {\n      buf[buflength - 1] = '\\0';\n
        \     sawNewline = true;\n      break;\n    } else if (buflength < bufsize
        - 1) {\n      break;\n    }\n\n    /* Else, grow our buffer for another pass.
        */\n    char* tmp;\n    bufsize *= 2;\n    if (bufsize > buflength) {\n      tmp
        = static_cast<char*>(JS_realloc(cx, buf, bufsize / 2, bufsize));\n    } else
        {\n      JS_ReportOutOfMemory(cx);\n      tmp = nullptr;\n    }\n\n    if
        (!tmp) {\n      JS_free(cx, buf);\n      return false;\n    }\n\n    buf =
        tmp;\n  }\n\n  /* Treat the empty string specially. */\n  if (buflength ==
        0) {\n    args.rval().set(feof(from) ? NullValue() : JS_GetEmptyStringValue(cx));\n
        \   JS_free(cx, buf);\n    return true;\n  }\n\n  /* Shrink the buffer to
        the real size. */\n  char* tmp = static_cast<char*>(JS_realloc(cx, buf, bufsize,
        buflength));\n  if (!tmp) {\n    JS_free(cx, buf);\n    return false;\n  }\n\n
        \ buf = tmp;\n\n  /*\n   * Turn buf into a JSString. Note that buflength includes
        the trailing null\n   * character.\n   */\n  JSString* str =\n      JS_NewStringCopyN(cx,
        buf, sawNewline ? buflength - 1 : buflength);\n  JS_free(cx, buf);\n  if (!str)
        {\n    return false;\n  }\n\n  args.rval().setString(str);\n  return true;\n}\n\n/*\n
        * function readlineBuf()\n * Provides a hook for scripts to emulate readline()
        using a string object.\n */\nstatic bool ReadLineBuf(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  ShellContext*
        sc = GetShellContext(cx);\n\n  if (!args.length()) {\n    if (!sc->readLineBuf)
        {\n      JS_ReportErrorASCII(cx,\n                          \"No source buffer
        set. You must initially \"\n                          \"call readlineBuf with
        an argument.\");\n      return false;\n    }\n\n    char* currentBuf = sc->readLineBuf.get()
        + sc->readLineBufPos;\n    size_t buflen = strlen(currentBuf);\n\n    if (!buflen)
        {\n      args.rval().setNull();\n      return true;\n    }\n\n    size_t len
        = 0;\n    while (len < buflen) {\n      if (currentBuf[len] == '\\n') {\n
        \       break;\n      }\n      len++;\n    }\n\n    JSString* str = JS_NewStringCopyUTF8N(cx,
        JS::UTF8Chars(currentBuf, len));\n    if (!str) {\n      return false;\n    }\n\n
        \   if (currentBuf[len] == '\\0') {\n      sc->readLineBufPos += len;\n    }
        else {\n      sc->readLineBufPos += len + 1;\n    }\n\n    args.rval().setString(str);\n
        \   return true;\n  }\n\n  if (args.length() == 1) {\n    sc->readLineBuf
        = nullptr;\n    sc->readLineBufPos = 0;\n\n    RootedString str(cx, JS::ToString(cx,
        args[0]));\n    if (!str) {\n      return false;\n    }\n    sc->readLineBuf
        = JS_EncodeStringToUTF8(cx, str);\n    if (!sc->readLineBuf) {\n      return
        false;\n    }\n\n    args.rval().setUndefined();\n    return true;\n  }\n\n
        \ JS_ReportErrorASCII(cx, \"Must specify at most one argument\");\n  return
        false;\n}\n\nstatic bool PutStr(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 0) {\n
        \   if (!gOutFile->isOpen()) {\n      JS_ReportErrorASCII(cx, \"output file
        is closed\");\n      return false;\n    }\n\n    RootedString str(cx, JS::ToString(cx,
        args[0]));\n    if (!str) {\n      return false;\n    }\n    UniqueChars bytes
        = JS_EncodeStringToUTF8(cx, str);\n    if (!bytes) {\n      return false;\n
        \   }\n    fputs(bytes.get(), gOutFile->fp);\n    fflush(gOutFile->fp);\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic bool Now(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ double now = PRMJ_Now() / double(PRMJ_USEC_PER_MSEC);\n  args.rval().setDouble(now);\n
        \ return true;\n}\n\nstatic bool CpuNow(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  double now = double(std::clock())
        / double(CLOCKS_PER_SEC);\n  args.rval().setDouble(now);\n  return true;\n}\n\nstatic
        bool PrintInternal(JSContext* cx, const CallArgs& args, RCFile* file) {\n
        \ if (!file->isOpen()) {\n    JS_ReportErrorASCII(cx, \"output file is closed\");\n
        \   return false;\n  }\n\n  for (unsigned i = 0; i < args.length(); i++) {\n
        \   RootedString str(cx, JS::ToString(cx, args[i]));\n    if (!str) {\n      return
        false;\n    }\n    UniqueChars bytes = JS_EncodeStringToUTF8(cx, str);\n    if
        (!bytes) {\n      return false;\n    }\n    fprintf(file->fp, \"%s%s\", i
        ? \" \" : \"\", bytes.get());\n  }\n\n  fputc('\\n', file->fp);\n  fflush(file->fp);\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool Print(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n#ifdef
        FUZZING_INTERFACES\n  if (fuzzHaveModule && !fuzzDoDebug) {\n    // When fuzzing
        and not debugging, suppress any print() output,\n    // as it slows down fuzzing
        and makes libFuzzer's output hard\n    // to read.\n    args.rval().setUndefined();\n
        \   return true;\n  }\n#endif  // FUZZING_INTERFACES\n  return PrintInternal(cx,
        args, gOutFile);\n}\n\nstatic bool PrintErr(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  return PrintInternal(cx,
        args, gErrFile);\n}\n\nstatic bool Help(JSContext* cx, unsigned argc, Value*
        vp);\n\nstatic bool Quit(JSContext* cx, unsigned argc, Value* vp) {\n  ShellContext*
        sc = GetShellContext(cx);\n\n  // Print a message to stderr in differential
        testing to help jsfunfuzz\n  // find uncatchable-exception bugs.\n  if (js::SupportDifferentialTesting())
        {\n    fprintf(stderr, \"quit called\\n\");\n  }\n\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  int32_t code;\n  if (!ToInt32(cx, args.get(0), &code)) {\n    return
        false;\n  }\n\n  // The fuzzers check the shell's exit code and assume a value
        >= 128 means\n  // the process crashed (for instance, SIGSEGV will result
        in code 139). On\n  // POSIX platforms, the exit code is 8-bit and negative
        values can also\n  // result in an exit code >= 128. We restrict the value
        to range [0, 127] to\n  // avoid false positives.\n  if (code < 0 || code
        >= 128) {\n    JS_ReportErrorASCII(cx, \"quit exit code should be in range
        0-127\");\n    return false;\n  }\n\n  js::StopDrainingJobQueue(cx);\n  sc->exitCode
        = code;\n  sc->quitting = true;\n  return false;\n}\n\nstatic bool StartTimingMutator(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (args.length() > 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_TOO_MANY_ARGS, \"startTimingMutator\");\n
        \   return false;\n  }\n\n  if (!cx->runtime()->gc.stats().startTimingMutator())
        {\n    JS_ReportErrorASCII(\n        cx, \"StartTimingMutator should only
        be called from outside of GC\");\n    return false;\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool StopTimingMutator(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        > 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              JSSMSG_TOO_MANY_ARGS,
        \"stopTimingMutator\");\n    return false;\n  }\n\n  double mutator_ms, gc_ms;\n
        \ if (!cx->runtime()->gc.stats().stopTimingMutator(mutator_ms, gc_ms)) {\n
        \   JS_ReportErrorASCII(cx,\n                        \"stopTimingMutator called
        when not timing the mutator\");\n    return false;\n  }\n  double total_ms
        = mutator_ms + gc_ms;\n  if (total_ms > 0 && gOutFile->isOpen()) {\n    fprintf(gOutFile->fp,
        \"Mutator: %.3fms (%.1f%%), GC: %.3fms (%.1f%%)\\n\",\n            mutator_ms,
        mutator_ms / total_ms * 100.0, gc_ms,\n            gc_ms / total_ms * 100.0);\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic const char*
        ToSource(JSContext* cx, HandleValue vp, UniqueChars* bytes) {\n  RootedString
        str(cx, JS_ValueToSource(cx, vp));\n  if (str) {\n    *bytes = JS_EncodeStringToUTF8(cx,
        str);\n    if (*bytes) {\n      return bytes->get();\n    }\n  }\n  JS_ClearPendingException(cx);\n
        \ return \"<<error converting value to string>>\";\n}\n\nstatic bool AssertEq(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (!(args.length() == 2 || (args.length() == 3 && args[2].isString())))
        {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              (args.length()
        < 2)    ? JSSMSG_NOT_ENOUGH_ARGS\n                              : (args.length()
        == 3) ? JSSMSG_INVALID_ARGS\n                                                     :
        JSSMSG_TOO_MANY_ARGS,\n                              \"assertEq\");\n    return
        false;\n  }\n\n  bool same;\n  if (!JS::SameValue(cx, args[0], args[1], &same))
        {\n    return false;\n  }\n  if (!same) {\n    UniqueChars bytes0, bytes1;\n
        \   const char* actual = ToSource(cx, args[0], &bytes0);\n    const char*
        expected = ToSource(cx, args[1], &bytes1);\n    if (args.length() == 2) {\n
        \     JS_ReportErrorNumberUTF8(cx, my_GetErrorMessage, nullptr,\n                               JSSMSG_ASSERT_EQ_FAILED,
        actual, expected);\n    } else {\n      RootedString message(cx, args[2].toString());\n
        \     UniqueChars bytes2 = QuoteString(cx, message);\n      if (!bytes2) {\n
        \       return false;\n      }\n      JS_ReportErrorNumberUTF8(cx, my_GetErrorMessage,
        nullptr,\n                               JSSMSG_ASSERT_EQ_FAILED_MSG, actual,
        expected,\n                               bytes2.get());\n    }\n    return
        false;\n  }\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic JSScript*
        GetTopScript(JSContext* cx) {\n  NonBuiltinScriptFrameIter iter(cx);\n  return
        iter.done() ? nullptr : iter.script();\n}\n\nstatic bool GetScriptAndPCArgs(JSContext*
        cx, CallArgs& args,\n                               MutableHandleScript scriptp,
        int32_t* ip) {\n  RootedScript script(cx, GetTopScript(cx));\n  *ip = 0;\n
        \ if (!args.get(0).isUndefined()) {\n    HandleValue v = args[0];\n    unsigned
        intarg = 0;\n    if (v.isObject() && JS::GetClass(&v.toObject())->isJSFunction())
        {\n      script = TestingFunctionArgumentToScript(cx, v);\n      if (!script)
        {\n        return false;\n      }\n      intarg++;\n    }\n    if (!args.get(intarg).isUndefined())
        {\n      if (!JS::ToInt32(cx, args[intarg], ip)) {\n        return false;\n
        \     }\n      if ((uint32_t)*ip >= script->length()) {\n        JS_ReportErrorASCII(cx,
        \"Invalid PC\");\n        return false;\n      }\n    }\n  }\n\n  scriptp.set(script);\n\n
        \ return true;\n}\n\nstatic bool LineToPC(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        == 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n
        \                             JSSMSG_LINE2PC_USAGE);\n    return false;\n
        \ }\n\n  RootedScript script(cx, GetTopScript(cx));\n  int32_t lineArg = 0;\n
        \ if (args[0].isObject() && args[0].toObject().is<JSFunction>()) {\n    script
        = TestingFunctionArgumentToScript(cx, args[0]);\n    if (!script) {\n      return
        false;\n    }\n    lineArg++;\n  }\n\n  uint32_t lineno;\n  if (!ToUint32(cx,
        args.get(lineArg), &lineno)) {\n    return false;\n  }\n\n  jsbytecode* pc
        = LineNumberToPC(script, lineno);\n  if (!pc) {\n    return false;\n  }\n
        \ args.rval().setInt32(script->pcToOffset(pc));\n  return true;\n}\n\nstatic
        bool PCToLine(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  RootedScript script(cx);\n  int32_t i;\n  unsigned
        lineno;\n\n  if (!GetScriptAndPCArgs(cx, args, &script, &i)) {\n    return
        false;\n  }\n  lineno = PCToLineNumber(script, script->offsetToPC(i));\n  if
        (!lineno) {\n    return false;\n  }\n  args.rval().setInt32(lineno);\n  return
        true;\n}\n\n#if defined(DEBUG) || defined(JS_JITSPEW)\n\nstatic bool Notes(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ Sprinter sprinter(cx);\n  if (!sprinter.init()) {\n    return false;\n  }\n\n
        \ for (unsigned i = 0; i < args.length(); i++) {\n    RootedScript script(cx,
        TestingFunctionArgumentToScript(cx, args[i]));\n    if (!script) {\n      return
        false;\n    }\n\n    if (!JSScript::dumpSrcNotes(cx, script, &sprinter)) {\n
        \     return false;\n    }\n  }\n\n  JSString* str = JS_NewStringCopyZ(cx,
        sprinter.string());\n  if (!str) {\n    return false;\n  }\n  args.rval().setString(str);\n
        \ return true;\n}\n\nnamespace {\n\nstruct DisassembleOptionParser {\n  unsigned
        argc;\n  Value* argv;\n  JSScript::DumpOptions options;\n\n  DisassembleOptionParser(unsigned
        argc, Value* argv)\n      : argc(argc), argv(argv) {}\n\n  bool parse(JSContext*
        cx) {\n    options.recursive = false;\n\n    /* Read options off early arguments
        */\n    while (argc > 0 && argv[0].isString()) {\n      JSString* str = argv[0].toString();\n
        \     JSLinearString* linearStr = JS_EnsureLinearString(cx, str);\n      if
        (!linearStr) {\n        return false;\n      }\n      if (JS_LinearStringEqualsLiteral(linearStr,
        \"-r\")) {\n        options.recursive = true;\n      } else {\n        break;\n
        \     }\n      argv++;\n      argc--;\n    }\n    return true;\n  }\n};\n\n}
        /* anonymous namespace */\n\nstatic bool DisassembleToSprinter(JSContext*
        cx, unsigned argc, Value* vp,\n                                  Sprinter*
        sprinter) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  DisassembleOptionParser
        p(args.length(), args.array());\n  if (!p.parse(cx)) {\n    return false;\n
        \ }\n\n  if (p.argc == 0) {\n    /* Without arguments, disassemble the current
        script. */\n    RootedScript script(cx, GetTopScript(cx));\n    if (script)
        {\n      JSAutoRealm ar(cx, script);\n      if (!JSScript::dump(cx, script,
        p.options, sprinter)) {\n        return false;\n      }\n    }\n  } else {\n
        \   for (unsigned i = 0; i < p.argc; i++) {\n      RootedFunction fun(cx);\n
        \     RootedScript script(cx);\n      RootedValue value(cx, p.argv[i]);\n
        \     if (value.isObject() && value.toObject().is<ShellModuleObjectWrapper>())
        {\n        script = value.toObject()\n                     .as<ShellModuleObjectWrapper>()\n
        \                    .get()\n                     ->maybeScript();\n      }
        else {\n        script = TestingFunctionArgumentToScript(cx, value, fun.address());\n
        \     }\n      if (!script) {\n        return false;\n      }\n\n      if
        (!JSScript::dump(cx, script, p.options, sprinter)) {\n        return false;\n
        \     }\n    }\n  }\n\n  return !sprinter->hadOutOfMemory();\n}\n\nstatic
        bool DisassembleToString(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  Sprinter sprinter(cx);\n  if (!sprinter.init())
        {\n    return false;\n  }\n  if (!DisassembleToSprinter(cx, args.length(),
        vp, &sprinter)) {\n    return false;\n  }\n\n  const char* chars = sprinter.string();\n
        \ size_t len;\n  JS::UniqueTwoByteChars buf(\n      JS::LossyUTF8CharsToNewTwoByteCharsZ(\n
        \         cx, JS::UTF8Chars(chars, strlen(chars)), &len, js::MallocArena)\n
        \         .get());\n  if (!buf) {\n    return false;\n  }\n  JSString* str
        = JS_NewUCStringCopyN(cx, buf.get(), len);\n  if (!str) {\n    return false;\n
        \ }\n  args.rval().setString(str);\n  return true;\n}\n\nstatic bool Disassemble(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx, \"output file is
        closed\");\n    return false;\n  }\n\n  Sprinter sprinter(cx);\n  if (!sprinter.init())
        {\n    return false;\n  }\n  if (!DisassembleToSprinter(cx, args.length(),
        vp, &sprinter)) {\n    return false;\n  }\n\n  fprintf(gOutFile->fp, \"%s\\n\",
        sprinter.string());\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool DisassFile(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx,
        \"output file is closed\");\n    return false;\n  }\n\n  /* Support extra
        options at the start, just like Disassemble. */\n  DisassembleOptionParser
        p(args.length(), args.array());\n  if (!p.parse(cx)) {\n    return false;\n
        \ }\n\n  if (!p.argc) {\n    args.rval().setUndefined();\n    return true;\n
        \ }\n\n  // We should change DisassembleOptionParser to store CallArgs.\n
        \ Rooted<JSString*> str(\n      cx, JS::ToString(cx, HandleValue::fromMarkedLocation(&p.argv[0])));\n
        \ if (!str) {\n    return false;\n  }\n  UniqueChars filename = JS_EncodeStringToUTF8(cx,
        str);\n  if (!filename) {\n    return false;\n  }\n  RootedScript script(cx);\n\n
        \ {\n    CompileOptions options(cx);\n    options.setIntroductionType(\"js
        shell disFile\")\n        .setFileAndLine(filename.get(), 1)\n        .setIsRunOnce(true)\n
        \       .setNoScriptRval(true)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   script = JS::CompileUtf8Path(cx, options, filename.get());\n    if (!script)
        {\n      return false;\n    }\n  }\n\n  Sprinter sprinter(cx);\n  if (!sprinter.init())
        {\n    return false;\n  }\n  if (JSScript::dump(cx, script, p.options, &sprinter))
        {\n    return false;\n  }\n\n  fprintf(gOutFile->fp, \"%s\\n\", sprinter.string());\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool DisassWithSrc(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx, \"output file is
        closed\");\n    return false;\n  }\n\n  const size_t lineBufLen = 512;\n  unsigned
        len, line1, line2, bupline;\n  char linebuf[lineBufLen];\n  static const char
        sep[] = \";-------------------------\";\n\n  RootedScript script(cx);\n  for
        (unsigned i = 0; i < args.length(); i++) {\n    script = TestingFunctionArgumentToScript(cx,
        args[i]);\n    if (!script) {\n      return false;\n    }\n\n    if (!script->filename())
        {\n      JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                                JSSMSG_FILE_SCRIPTS_ONLY);\n
        \     return false;\n    }\n\n    FILE* file = OpenFile(cx, script->filename(),
        \"rb\");\n    if (!file) {\n      return false;\n    }\n    auto closeFile
        = MakeScopeExit([file] { fclose(file); });\n\n    jsbytecode* pc = script->code();\n
        \   jsbytecode* end = script->codeEnd();\n\n    Sprinter sprinter(cx);\n    if
        (!sprinter.init()) {\n      return false;\n    }\n\n    /* burn the leading
        lines */\n    line2 = PCToLineNumber(script, pc);\n    for (line1 = 0; line1
        < line2 - 1; line1++) {\n      char* tmp = fgets(linebuf, lineBufLen, file);\n
        \     if (!tmp) {\n        JS_ReportErrorUTF8(cx, \"failed to read %s fully\",
        script->filename());\n        return false;\n      }\n    }\n\n    bupline
        = 0;\n    while (pc < end) {\n      line2 = PCToLineNumber(script, pc);\n\n
        \     if (line2 < line1) {\n        if (bupline != line2) {\n          bupline
        = line2;\n          if (!sprinter.jsprintf(\"%s %3u: BACKUP\\n\", sep, line2))
        {\n            return false;\n          }\n        }\n      } else {\n        if
        (bupline && line1 == line2) {\n          if (!sprinter.jsprintf(\"%s %3u:
        RESTORE\\n\", sep, line2)) {\n            return false;\n          }\n        }\n
        \       bupline = 0;\n        while (line1 < line2) {\n          if (!fgets(linebuf,
        lineBufLen, file)) {\n            JS_ReportErrorNumberUTF8(cx, my_GetErrorMessage,
        nullptr,\n                                     JSSMSG_UNEXPECTED_EOF, script->filename());\n
        \           return false;\n          }\n          line1++;\n          if (!sprinter.jsprintf(\"%s
        %3u: %s\", sep, line1, linebuf)) {\n            return false;\n          }\n
        \       }\n      }\n\n      len =\n          Disassemble1(cx, script, pc,
        script->pcToOffset(pc), true, &sprinter);\n      if (!len) {\n        return
        false;\n      }\n\n      pc += len;\n    }\n\n    fprintf(gOutFile->fp, \"%s\\n\",
        sprinter.string());\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\n#endif
        /* defined(DEBUG) || defined(JS_JITSPEW) */\n\n#ifdef JS_CACHEIR_SPEW\nstatic
        bool CacheIRHealthReport(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  js::jit::CacheIRHealth cih;\n  RootedScript
        script(cx);\n\n  // In the case that we are calling this function from the
        shell and\n  // the environment variable is not set, AutoSpewChannel automatically\n
        \ // sets and unsets the proper channel for the duration of spewing\n  //
        a health report.\n  AutoSpewChannel channel(cx, SpewChannel::CacheIRHealthReport,
        script);\n  if (!argc) {\n    // Calling CacheIRHealthReport without any arguments
        will create health\n    // reports for all scripts in the zone.\n    for (auto
        base = cx->zone()->cellIter<BaseScript>(); !base.done();\n         base.next())
        {\n      if (!base->hasJitScript() || base->selfHosted()) {\n        continue;\n
        \     }\n\n      script = base->asJSScript();\n      cih.healthReportForScript(cx,
        script, js::jit::SpewContext::Shell);\n    }\n  } else {\n    RootedValue
        value(cx, args.get(0));\n\n    if (value.isObject() && value.toObject().is<ShellModuleObjectWrapper>())
        {\n      script =\n          value.toObject().as<ShellModuleObjectWrapper>().get()->maybeScript();\n
        \   } else {\n      script = TestingFunctionArgumentToScript(cx, args.get(0));\n
        \   }\n\n    if (!script) {\n      return false;\n    }\n\n    cih.healthReportForScript(cx,
        script, js::jit::SpewContext::Shell);\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n#endif /* JS_CACHEIR_SPEW */\n\n/* Pretend we can always
        preserve wrappers for dummy DOM objects. */\nstatic bool DummyPreserveWrapperCallback(JSContext*
        cx, HandleObject obj) {\n  return true;\n}\n\nstatic bool DummyHasReleasedWrapperCallback(HandleObject
        obj) { return true; }\n\n#ifdef FUZZING_JS_FUZZILLI\nstatic bool fuzzilli_hash(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ args.rval().setUndefined();\n\n  if (argc != 1) {\n    return true;\n  }\n
        \ uint32_t hash;\n  JS::Handle<JS::Value> v = args.get(0);\n  if (v.isInt32())
        {\n    int32_t i = v.toInt32();\n    hash = FuzzilliHashDouble((double)i);\n
        \ } else if (v.isDouble()) {\n    double d = v.toDouble();\n    d = JS::CanonicalizeNaN(d);\n
        \   hash = FuzzilliHashDouble(d);\n  } else if (v.isNull()) {\n    hash =
        FuzzilliHashDouble(1.0);\n  } else if (v.isUndefined()) {\n    hash = FuzzilliHashDouble(2.0);\n
        \ } else if (v.isBoolean()) {\n    hash = FuzzilliHashDouble(3.0 + v.toBoolean());\n
        \ } else if (v.isBigInt()) {\n    JS::BigInt* bigInt = v.toBigInt();\n    hash
        = FuzzilliHashBigInt(bigInt);\n  } else if (v.isObject()) {\n    JSObject&
        obj = v.toObject();\n    FuzzilliHashObject(cx, &obj);\n    return true;\n
        \ } else {\n    hash = 0;\n  }\n\n  cx->executionHashInputs += 1;\n  cx->executionHash
        = mozilla::RotateLeft(cx->executionHash + hash, 1);\n  return true;\n}\n\n//
        We have to assume that the fuzzer will be able to call this function e.g.
        by\n// enumerating the properties of the global object and eval'ing them.
        As such\n// this function is implemented in a way that requires passing some
        magic value\n// as first argument (with the idea being that the fuzzer won't
        be able to\n// generate this value) which then also acts as a selector for
        the operation\n// to perform.\nstatic bool Fuzzilli(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  RootedString
        arg(cx, JS::ToString(cx, args.get(0)));\n  if (!arg) {\n    return false;\n
        \ }\n  Rooted<JSLinearString*> operation(cx, StringToLinearString(cx, arg));\n
        \ if (!operation) {\n    return false;\n  }\n\n  if (StringEqualsAscii(operation,
        \"FUZZILLI_CRASH\")) {\n    int type;\n    if (!ToInt32(cx, args.get(1), &type))
        {\n      return false;\n    }\n\n    // With this, we can test the various
        ways the JS shell can crash and make\n    // sure that Fuzzilli is able to
        detect all of these failures properly.\n    switch (type) {\n      case 0:\n
        \       *((int*)0x41414141) = 0x1337;\n        break;\n      case 1:\n        MOZ_RELEASE_ASSERT(false);\n
        \       break;\n      case 2:\n        MOZ_ASSERT(false);\n        break;\n
        \     case 3:\n        __asm__(\"int3\");\n        break;\n      default:\n
        \       exit(1);\n    }\n  } else if (StringEqualsAscii(operation, \"FUZZILLI_PRINT\"))
        {\n    static FILE* fzliout = fdopen(REPRL_DWFD, \"w\");\n    if (!fzliout)
        {\n      fprintf(\n          stderr,\n          \"Fuzzer output channel not
        available, printing to stdout instead\\n\");\n      fzliout = stdout;\n    }\n\n
        \   RootedString str(cx, JS::ToString(cx, args.get(1)));\n    if (!str) {\n
        \     return false;\n    }\n    UniqueChars bytes = JS_EncodeStringToUTF8(cx,
        str);\n    if (!bytes) {\n      return false;\n    }\n    fprintf(fzliout,
        \"%s\\n\", bytes.get());\n    fflush(fzliout);\n  } else if (StringEqualsAscii(operation,
        \"FUZZILLI_RANDOM\")) {\n    // This is an entropy source which can be called
        during fuzzing.\n    // Its currently used to tests whether Fuzzilli detects
        non-deterministic\n    // behavior.\n    args.rval().setInt32(static_cast<uint32_t>(mozilla::RandomUint64OrDie()));\n
        \   return true;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool FuzzilliReprlGetAndRun(JSContext* cx) {\n  size_t scriptSize = 0;\n\n
        \ unsigned action;\n  MOZ_RELEASE_ASSERT(read(REPRL_CRFD, &action, 4) == 4);\n
        \ if (action == 'cexe') {\n    MOZ_RELEASE_ASSERT(read(REPRL_CRFD, &scriptSize,
        8) == 8);\n  } else {\n    fprintf(stderr, \"Unknown action: %u\\n\", action);\n
        \   _exit(-1);\n  }\n\n  CompileOptions options(cx);\n  options.setIntroductionType(\"reprl\")\n
        \     .setFileAndLine(\"reprl\", 1)\n      .setIsRunOnce(true)\n      .setNoScriptRval(true)\n
        \     .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n  char*
        scriptSrc = static_cast<char*>(js_malloc(scriptSize));\n\n  char* ptr = scriptSrc;\n
        \ size_t remaining = scriptSize;\n  while (remaining > 0) {\n    ssize_t rv
        = read(REPRL_DRFD, ptr, remaining);\n    if (rv <= 0) {\n      fprintf(stderr,
        \"Failed to load script\\n\");\n      _exit(-1);\n    }\n    remaining -=
        rv;\n    ptr += rv;\n  }\n\n  JS::SourceText<Utf8Unit> srcBuf;\n  if (!srcBuf.init(cx,
        scriptSrc, scriptSize,\n                   JS::SourceOwnership::TakeOwnership))
        {\n    return false;\n  }\n\n  RootedScript script(cx, JS::Compile(cx, options,
        srcBuf));\n  if (!script) {\n    return false;\n  }\n\n  if (!JS_ExecuteScript(cx,
        script)) {\n    return false;\n  }\n\n  return true;\n}\n\n#endif /* FUZZING_JS_FUZZILLI
        */\n\nstatic bool FuzzilliUseReprlMode(OptionParser* op) {\n#ifdef FUZZING_JS_FUZZILLI\n
        \ // Check if we should use REPRL mode\n  bool reprl_mode = op->getBoolOption(\"reprl\");\n
        \ if (reprl_mode) {\n    // Check in with parent\n    char helo[] = \"HELO\";\n
        \   if (write(REPRL_CWFD, helo, 4) != 4 || read(REPRL_CRFD, helo, 4) != 4)
        {\n      reprl_mode = false;\n    }\n\n    if (memcmp(helo, \"HELO\", 4) !=
        0) {\n      fprintf(stderr, \"Invalid response from parent\\n\");\n      _exit(-1);\n
        \   }\n  }\n  return reprl_mode;\n#else\n  return false;\n#endif /* FUZZING_JS_FUZZILLI
        */\n}\n\nstatic bool Crash(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (args.length() == 0) {\n    MOZ_CRASH(\"forced
        crash\");\n  }\n  RootedString message(cx, JS::ToString(cx, args[0]));\n  if
        (!message) {\n    return false;\n  }\n  UniqueChars utf8chars = JS_EncodeStringToUTF8(cx,
        message);\n  if (!utf8chars) {\n    return false;\n  }\n  if (args.get(1).isObject())
        {\n    RootedValue v(cx);\n    RootedObject opts(cx, &args[1].toObject());\n
        \   if (!JS_GetProperty(cx, opts, \"suppress_minidump\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean() && v.toBoolean()) {\n      js::NoteIntentionalCrash();\n
        \   }\n  }\n#ifndef DEBUG\n  MOZ_ReportCrash(utf8chars.get(), __FILE__, __LINE__);\n#endif\n
        \ MOZ_CRASH_UNSAFE(utf8chars.get());\n}\n\nstatic bool GetSLX(JSContext* cx,
        unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ RootedScript script(cx);\n\n  script = TestingFunctionArgumentToScript(cx,
        args.get(0));\n  if (!script) {\n    return false;\n  }\n  args.rval().setInt32(GetScriptLineExtent(script));\n
        \ return true;\n}\n\nstatic bool ThrowError(JSContext* cx, unsigned argc,
        Value* vp) {\n  JS_ReportErrorASCII(cx, \"This is an error\");\n  return false;\n}\n\nstatic
        bool CopyErrorReportToObject(JSContext* cx, JSErrorReport* report,\n                                    HandleObject
        obj) {\n  RootedString nameStr(cx);\n  if (report->exnType == JSEXN_WARN)
        {\n    nameStr = JS_NewStringCopyZ(cx, \"Warning\");\n    if (!nameStr) {\n
        \     return false;\n    }\n  } else {\n    nameStr = GetErrorTypeName(cx,
        report->exnType);\n    // GetErrorTypeName doesn't set an exception, but\n
        \   // can fail for InternalError or non-error objects.\n    if (!nameStr)
        {\n      nameStr = cx->runtime()->emptyString;\n    }\n  }\n  RootedValue
        nameVal(cx, StringValue(nameStr));\n  if (!DefineDataProperty(cx, obj, cx->names().name,
        nameVal)) {\n    return false;\n  }\n\n  RootedString messageStr(cx, report->newMessageString(cx));\n
        \ if (!messageStr) {\n    return false;\n  }\n  RootedValue messageVal(cx,
        StringValue(messageStr));\n  if (!DefineDataProperty(cx, obj, cx->names().message,
        messageVal)) {\n    return false;\n  }\n\n  RootedValue linenoVal(cx, Int32Value(report->lineno));\n
        \ if (!DefineDataProperty(cx, obj, cx->names().lineNumber, linenoVal)) {\n
        \   return false;\n  }\n\n  RootedValue columnVal(cx, Int32Value(report->column));\n
        \ if (!DefineDataProperty(cx, obj, cx->names().columnNumber, columnVal)) {\n
        \   return false;\n  }\n\n  RootedObject notesArray(cx, CreateErrorNotesArray(cx,
        report));\n  if (!notesArray) {\n    return false;\n  }\n\n  RootedValue notesArrayVal(cx,
        ObjectValue(*notesArray));\n  return DefineDataProperty(cx, obj, cx->names().notes,
        notesArrayVal);\n}\n\nstatic bool CreateErrorReport(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  // We
        don't have a stack here, so just initialize with null.\n  JS::ExceptionStack
        exnStack(cx, args.get(0), nullptr);\n  JS::ErrorReportBuilder report(cx);\n
        \ if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects))
        {\n    return false;\n  }\n\n  MOZ_ASSERT(!report.report()->isWarning());\n\n
        \ RootedObject obj(cx, JS_NewPlainObject(cx));\n  if (!obj) {\n    return
        false;\n  }\n\n  RootedString toString(cx, NewStringCopyUTF8Z(cx, report.toStringResult()));\n
        \ if (!toString) {\n    return false;\n  }\n\n  if (!JS_DefineProperty(cx,
        obj, \"toStringResult\", toString,\n                         JSPROP_ENUMERATE))
        {\n    return false;\n  }\n\n  if (!CopyErrorReportToObject(cx, report.report(),
        obj)) {\n    return false;\n  }\n\n  args.rval().setObject(*obj);\n  return
        true;\n}\n\n#define LAZY_STANDARD_CLASSES\n\n/* A class for easily testing
        the inner/outer object callbacks. */\ntypedef struct ComplexObject {\n  bool
        isInner;\n  bool frozen;\n  JSObject* inner;\n  JSObject* outer;\n} ComplexObject;\n\nstatic
        bool sandbox_enumerate(JSContext* cx, JS::HandleObject obj,\n                              JS::MutableHandleIdVector
        properties,\n                              bool enumerableOnly) {\n  RootedValue
        v(cx);\n\n  if (!JS_GetProperty(cx, obj, \"lazy\", &v)) {\n    return false;\n
        \ }\n\n  if (!ToBoolean(v)) {\n    return true;\n  }\n\n  return JS_NewEnumerateStandardClasses(cx,
        obj, properties, enumerableOnly);\n}\n\nstatic bool sandbox_resolve(JSContext*
        cx, HandleObject obj, HandleId id,\n                            bool* resolvedp)
        {\n  RootedValue v(cx);\n  if (!JS_GetProperty(cx, obj, \"lazy\", &v)) {\n
        \   return false;\n  }\n\n  if (ToBoolean(v)) {\n    return JS_ResolveStandardClass(cx,
        obj, id, resolvedp);\n  }\n  return true;\n}\n\nstatic const JSClassOps sandbox_classOps
        = {\n    nullptr,                   // addProperty\n    nullptr,                   //
        delProperty\n    nullptr,                   // enumerate\n    sandbox_enumerate,
        \        // newEnumerate\n    sandbox_resolve,           // resolve\n    nullptr,
        \                  // mayResolve\n    nullptr,                   // finalize\n
        \   nullptr,                   // call\n    nullptr,                   //
        construct\n    JS_GlobalObjectTraceHook,  // trace\n};\n\nstatic const JSClass
        sandbox_class = {\"sandbox\", JSCLASS_GLOBAL_FLAGS,\n                                      &sandbox_classOps};\n\nstatic
        void SetStandardRealmOptions(JS::RealmOptions& options) {\n  options.creationOptions()\n
        \     .setSharedMemoryAndAtomicsEnabled(enableSharedMemory)\n      .setCoopAndCoepEnabled(false)\n
        \     .setWeakRefsEnabled(enableWeakRefs\n                              ?
        JS::WeakRefSpecifier::EnabledWithCleanupSome\n                              :
        JS::WeakRefSpecifier::Disabled)\n      .setToSourceEnabled(enableToSource)\n
        \     .setPropertyErrorMessageFixEnabled(enablePropertyErrorMessageFix)\n
        \     .setIteratorHelpersEnabled(enableIteratorHelpers)\n      .setShadowRealmsEnabled(enableShadowRealms)\n
        \     .setArrayFromAsyncEnabled(enableArrayFromAsync)\n#ifdef NIGHTLY_BUILD\n
        \     .setArrayGroupingEnabled(enableArrayGrouping)\n      .setWellFormedUnicodeStringsEnabled(enableWellFormedUnicodeStrings)\n#endif\n
        \     .setChangeArrayByCopyEnabled(enableChangeArrayByCopy)\n#ifdef ENABLE_NEW_SET_METHODS\n
        \     .setNewSetMethodsEnabled(enableNewSetMethods)\n#endif\n      ;\n}\n\n[[nodiscard]]
        static bool CheckRealmOptions(JSContext* cx,\n                                            JS::RealmOptions&
        options,\n                                            JSPrincipals* principals)
        {\n  JS::RealmCreationOptions& creationOptions = options.creationOptions();\n
        \ if (creationOptions.compartmentSpecifier() !=\n      JS::CompartmentSpecifier::ExistingCompartment)
        {\n    return true;\n  }\n\n  JS::Compartment* comp = creationOptions.compartment();\n\n
        \ // All realms in a compartment must be either system or non-system.\n  bool
        isSystem =\n      principals && principals == cx->runtime()->trustedPrincipals();\n
        \ if (isSystem != IsSystemCompartment(comp)) {\n    JS_ReportErrorASCII(cx,\n
        \                       \"Cannot create system and non-system realms in the
        \"\n                        \"same compartment\");\n    return false;\n  }\n\n
        \ // Debugger visibility is per-compartment, not per-realm, so make sure the\n
        \ // requested visibility matches the existing compartment's.\n  if (creationOptions.invisibleToDebugger()
        != comp->invisibleToDebugger()) {\n    JS_ReportErrorASCII(cx,\n                        \"All
        the realms in a compartment must have \"\n                        \"the same
        debugger visibility\");\n    return false;\n  }\n\n  return true;\n}\n\nstatic
        JSObject* NewSandbox(JSContext* cx, bool lazy) {\n  JS::RealmOptions options;\n
        \ SetStandardRealmOptions(options);\n\n  if (defaultToSameCompartment) {\n
        \   options.creationOptions().setExistingCompartment(cx->global());\n  } else
        {\n    options.creationOptions().setNewCompartmentAndZone();\n  }\n\n  JSPrincipals*
        principals = nullptr;\n  if (!CheckRealmOptions(cx, options, principals))
        {\n    return nullptr;\n  }\n\n  RootedObject obj(cx,\n                   JS_NewGlobalObject(cx,
        &sandbox_class, principals,\n                                      JS::DontFireOnNewGlobalHook,
        options));\n  if (!obj) {\n    return nullptr;\n  }\n\n  {\n    JSAutoRealm
        ar(cx, obj);\n    if (!lazy && !JS::InitRealmStandardClasses(cx)) {\n      return
        nullptr;\n    }\n\n    RootedValue value(cx, BooleanValue(lazy));\n    if
        (!JS_DefineProperty(cx, obj, \"lazy\", value,\n                           JSPROP_PERMANENT
        | JSPROP_READONLY)) {\n      return nullptr;\n    }\n\n    JS_FireOnNewGlobalObject(cx,
        obj);\n  }\n\n  if (!cx->compartment()->wrap(cx, &obj)) {\n    return nullptr;\n
        \ }\n  return obj;\n}\n\nstatic bool EvalInContext(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"evalcx\", 1)) {\n    return false;\n  }\n\n  RootedString str(cx, ToString(cx,
        args[0]));\n  if (!str) {\n    return false;\n  }\n\n  RootedObject sobj(cx);\n
        \ if (args.hasDefined(1)) {\n    sobj = ToObject(cx, args[1]);\n    if (!sobj)
        {\n      return false;\n    }\n  }\n\n  AutoStableStringChars strChars(cx);\n
        \ if (!strChars.initTwoByte(cx, str)) {\n    return false;\n  }\n\n  mozilla::Range<const
        char16_t> chars = strChars.twoByteRange();\n  size_t srclen = chars.length();\n
        \ const char16_t* src = chars.begin().get();\n\n  bool lazy = false;\n  if
        (srclen == 4) {\n    if (src[0] == 'l' && src[1] == 'a' && src[2] == 'z' &&
        src[3] == 'y') {\n      lazy = true;\n      srclen = 0;\n    }\n  }\n\n  if
        (!sobj) {\n    sobj = NewSandbox(cx, lazy);\n    if (!sobj) {\n      return
        false;\n    }\n  }\n\n  if (srclen == 0) {\n    args.rval().setObject(*sobj);\n
        \   return true;\n  }\n\n  JS::AutoFilename filename;\n  unsigned lineno;\n\n
        \ DescribeScriptedCaller(cx, &filename, &lineno);\n  {\n    sobj = UncheckedUnwrap(sobj,
        true);\n\n    JSAutoRealm ar(cx, sobj);\n\n    sobj = ToWindowIfWindowProxy(sobj);\n\n
        \   if (!JS_IsGlobalObject(sobj)) {\n      JS_ReportErrorASCII(cx, \"Invalid
        scope argument to evalcx\");\n      return false;\n    }\n\n    JS::CompileOptions
        opts(cx);\n    opts.setFileAndLine(filename.get(), lineno)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   JS::SourceText<char16_t> srcBuf;\n    if (!srcBuf.init(cx, src, srclen,
        JS::SourceOwnership::Borrowed) ||\n        !JS::Evaluate(cx, opts, srcBuf,
        args.rval())) {\n      return false;\n    }\n  }\n\n  if (!cx->compartment()->wrap(cx,
        args.rval())) {\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool
        EnsureGeckoProfilingStackInstalled(JSContext* cx,\n                                               ShellContext*
        sc) {\n  if (cx->geckoProfiler().infraInstalled()) {\n    MOZ_ASSERT(sc->geckoProfilingStack);\n
        \   return true;\n  }\n\n  MOZ_ASSERT(!sc->geckoProfilingStack);\n  sc->geckoProfilingStack
        = MakeUnique<ProfilingStack>();\n  if (!sc->geckoProfilingStack) {\n    JS_ReportOutOfMemory(cx);\n
        \   return false;\n  }\n\n  SetContextProfilingStack(cx, sc->geckoProfilingStack.get());\n
        \ return true;\n}\n\nstruct WorkerInput {\n  JSRuntime* parentRuntime;\n  UniqueTwoByteChars
        chars;\n  size_t length;\n\n  WorkerInput(JSRuntime* parentRuntime, UniqueTwoByteChars
        chars, size_t length)\n      : parentRuntime(parentRuntime), chars(std::move(chars)),
        length(length) {}\n};\n\nstatic void DestroyShellCompartmentPrivate(JS::GCContext*
        gcx,\n                                           JS::Compartment* compartment)
        {\n  auto priv = static_cast<ShellCompartmentPrivate*>(\n      JS_GetCompartmentPrivate(compartment));\n
        \ js_delete(priv);\n}\n\nstatic void SetWorkerContextOptions(JSContext* cx);\nstatic
        bool ShellBuildId(JS::BuildIdCharVector* buildId);\n\nstatic constexpr size_t
        gWorkerStackSize = 2 * 128 * sizeof(size_t) * 1024;\n\nstatic void WorkerMain(UniquePtr<WorkerInput>
        input) {\n  MOZ_ASSERT(input->parentRuntime);\n\n  JSContext* cx = JS_NewContext(8L
        * 1024L * 1024L, input->parentRuntime);\n  if (!cx) {\n    return;\n  }\n\n
        \ ShellContext* sc = js_new<ShellContext>(cx);\n  if (!sc) {\n    return;\n
        \ }\n\n  auto guard = mozilla::MakeScopeExit([&] {\n    CancelOffThreadJobsForContext(cx);\n
        \   sc->markObservers.reset();\n    JS_SetContextPrivate(cx, nullptr);\n    js_delete(sc);\n
        \   JS_DestroyContext(cx);\n  });\n\n  sc->isWorker = true;\n\n  JS_SetContextPrivate(cx,
        sc);\n  JS_AddExtraGCRootsTracer(cx, TraceBlackRoots, nullptr);\n  JS_SetGrayGCRootsTracer(cx,
        TraceGrayRoots, nullptr);\n  SetWorkerContextOptions(cx);\n\n  JS_SetFutexCanWait(cx);\n
        \ JS::SetWarningReporter(cx, WarningReporter);\n  js::SetPreserveWrapperCallbacks(cx,
        DummyPreserveWrapperCallback,\n                                  DummyHasReleasedWrapperCallback);\n
        \ JS_InitDestroyPrincipalsCallback(cx, ShellPrincipals::destroy);\n  JS_SetDestroyCompartmentCallback(cx,
        DestroyShellCompartmentPrivate);\n\n  js::SetWindowProxyClass(cx, &ShellWindowProxyClass);\n\n
        \ js::UseInternalJobQueues(cx);\n\n  JS::SetHostCleanupFinalizationRegistryCallback(\n
        \     cx, ShellCleanupFinalizationRegistryCallback, sc);\n\n  if (!JS::InitSelfHostedCode(cx))
        {\n    return;\n  }\n\n  EnvironmentPreparer environmentPreparer(cx);\n\n
        \ do {\n    JS::RealmOptions realmOptions;\n    SetStandardRealmOptions(realmOptions);\n\n
        \   RootedObject global(cx, NewGlobalObject(cx, realmOptions, nullptr,\n                                            ShellGlobalKind::WindowProxy,\n
        \                                           /* immutablePrototype = */ true));\n
        \   if (!global) {\n      break;\n    }\n\n    JSAutoRealm ar(cx, global);\n\n
        \   JS::ConstUTF8CharsZ path(processWideModuleLoadPath.get(),\n                             strlen(processWideModuleLoadPath.get()));\n
        \   RootedString moduleLoadPath(cx, JS_NewStringCopyUTF8Z(cx, path));\n    if
        (!moduleLoadPath) {\n      return;\n    }\n    sc->moduleLoader = js::MakeUnique<ModuleLoader>();\n
        \   if (!sc->moduleLoader || !sc->moduleLoader->init(cx, moduleLoadPath))
        {\n      return;\n    }\n\n    JS::CompileOptions options(cx);\n    options.setFileAndLine(\"<string>\",
        1)\n        .setIsRunOnce(true)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   AutoReportException are(cx);\n    JS::SourceText<char16_t> srcBuf;\n    if
        (!srcBuf.init(cx, input->chars.get(), input->length,\n                     JS::SourceOwnership::Borrowed))
        {\n      break;\n    }\n\n    RootedScript script(cx, JS::Compile(cx, options,
        srcBuf));\n    if (!script) {\n      break;\n    }\n    RootedValue result(cx);\n
        \   JS_ExecuteScript(cx, script, &result);\n  } while (0);\n\n  KillWatchdog(cx);\n
        \ JS_SetGrayGCRootsTracer(cx, nullptr, nullptr);\n}\n\n// Workers can spawn
        other workers, so we need a lock to access workerThreads.\nstatic Mutex* workerThreadsLock
        = nullptr;\nstatic Vector<UniquePtr<js::Thread>, 0, SystemAllocPolicy> workerThreads;\n\nclass
        MOZ_RAII AutoLockWorkerThreads : public LockGuard<Mutex> {\n  using Base =
        LockGuard<Mutex>;\n\n public:\n  AutoLockWorkerThreads() : Base(*workerThreadsLock)
        {\n    MOZ_ASSERT(workerThreadsLock);\n  }\n};\n\nstatic bool EvalInWorker(JSContext*
        cx, unsigned argc, Value* vp) {\n  if (!CanUseExtraThreads()) {\n    JS_ReportErrorASCII(cx,
        \"Can't create threads with --no-threads\");\n    return false;\n  }\n\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (!args.get(0).isString()) {\n    JS_ReportErrorASCII(cx,
        \"Invalid arguments\");\n    return false;\n  }\n\n#if defined(DEBUG) || defined(JS_OOM_BREAKPOINT)\n
        \ if (cx->runningOOMTest) {\n    JS_ReportErrorASCII(\n        cx, \"Can't
        create threads while running simulated OOM test\");\n    return false;\n  }\n#endif\n\n
        \ if (!args[0].toString()->ensureLinear(cx)) {\n    return false;\n  }\n\n
        \ if (!workerThreadsLock) {\n    workerThreadsLock = js_new<Mutex>(mutexid::ShellWorkerThreads);\n
        \   if (!workerThreadsLock) {\n      ReportOutOfMemory(cx);\n      return
        false;\n    }\n  }\n\n  JSLinearString* str = &args[0].toString()->asLinear();\n\n
        \ UniqueTwoByteChars chars(js_pod_malloc<char16_t>(str->length()));\n  if
        (!chars) {\n    ReportOutOfMemory(cx);\n    return false;\n  }\n\n  CopyChars(chars.get(),
        *str);\n\n  auto input = js::MakeUnique<WorkerInput>(JS_GetParentRuntime(cx),\n
        \                                          std::move(chars), str->length());\n
        \ if (!input) {\n    ReportOutOfMemory(cx);\n    return false;\n  }\n\n  UniquePtr<Thread>
        thread;\n  {\n    AutoEnterOOMUnsafeRegion oomUnsafe;\n    thread = js::MakeUnique<Thread>(\n
        \       Thread::Options().setStackSize(gWorkerStackSize + 512 * 1024));\n
        \   if (!thread || !thread->init(WorkerMain, std::move(input))) {\n      oomUnsafe.crash(\"EvalInWorker\");\n
        \   }\n  }\n\n  AutoLockWorkerThreads alwt;\n  if (!workerThreads.append(std::move(thread)))
        {\n    ReportOutOfMemory(cx);\n    thread->join();\n    return false;\n  }\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool ShapeOf(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  if (!args.get(0).isObject()) {\n    JS_ReportErrorASCII(cx, \"shapeOf:
        object expected\");\n    return false;\n  }\n  JSObject* obj = &args[0].toObject();\n
        \ args.rval().set(JS_NumberValue(double(uintptr_t(obj->shape()) >> 3)));\n
        \ return true;\n}\n\nstatic bool Sleep_fn(JSContext* cx, unsigned argc, Value*
        vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  TimeDuration duration = TimeDuration::FromSeconds(0.0);\n  if (args.length()
        > 0) {\n    double t_secs;\n    if (!ToNumber(cx, args[0], &t_secs)) {\n      return
        false;\n    }\n    if (std::isnan(t_secs)) {\n      JS_ReportErrorASCII(cx,
        \"sleep interval is not a number\");\n      return false;\n    }\n\n    duration
        = TimeDuration::FromSeconds(std::max(0.0, t_secs));\n    const TimeDuration
        MAX_TIMEOUT_INTERVAL =\n        TimeDuration::FromSeconds(MAX_TIMEOUT_SECONDS);\n
        \   if (duration > MAX_TIMEOUT_INTERVAL) {\n      JS_ReportErrorASCII(cx,
        \"Excessive sleep interval\");\n      return false;\n    }\n  }\n  {\n    LockGuard<Mutex>
        guard(sc->watchdogLock);\n    TimeStamp toWakeup = TimeStamp::Now() + duration;\n
        \   for (;;) {\n      sc->sleepWakeup.wait_for(guard, duration);\n      if
        (sc->serviceInterrupt) {\n        break;\n      }\n      auto now = TimeStamp::Now();\n
        \     if (now >= toWakeup) {\n        break;\n      }\n      duration = toWakeup
        - now;\n    }\n  }\n  args.rval().setUndefined();\n  return !sc->serviceInterrupt;\n}\n\nstatic
        void KillWatchdog(JSContext* cx) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ Maybe<Thread> thread;\n\n  {\n    LockGuard<Mutex> guard(sc->watchdogLock);\n
        \   std::swap(sc->watchdogThread, thread);\n    if (thread) {\n      // The
        watchdog thread becoming Nothing is its signal to exit.\n      sc->watchdogWakeup.notify_one();\n
        \   }\n  }\n  if (thread) {\n    thread->join();\n  }\n\n  MOZ_ASSERT(!sc->watchdogThread);\n}\n\nstatic
        void WatchdogMain(JSContext* cx) {\n  ThisThread::SetName(\"JS Watchdog\");\n\n
        \ ShellContext* sc = GetShellContext(cx);\n\n  {\n    LockGuard<Mutex> guard(sc->watchdogLock);\n
        \   while (sc->watchdogThread) {\n      auto now = TimeStamp::Now();\n      if
        (sc->watchdogTimeout && now >= sc->watchdogTimeout.value()) {\n        /*\n
        \        * The timeout has just expired. Request an interrupt callback\n         *
        outside the lock.\n         */\n        sc->watchdogTimeout = Nothing();\n
        \       {\n          UnlockGuard<Mutex> unlock(guard);\n          CancelExecution(cx);\n
        \       }\n\n        /* Wake up any threads doing sleep. */\n        sc->sleepWakeup.notify_all();\n
        \     } else {\n        if (sc->watchdogTimeout) {\n          /*\n           *
        Time hasn't expired yet. Simulate an interrupt callback\n           * which
        doesn't abort execution.\n           */\n          JS_RequestInterruptCallback(cx);\n
        \       }\n\n        TimeDuration sleepDuration = sc->watchdogTimeout\n                                         ?
        TimeDuration::FromSeconds(0.1)\n                                         :
        TimeDuration::Forever();\n        sc->watchdogWakeup.wait_for(guard, sleepDuration);\n
        \     }\n    }\n  }\n}\n\nstatic bool ScheduleWatchdog(JSContext* cx, double
        t) {\n  ShellContext* sc = GetShellContext(cx);\n\n  if (t <= 0) {\n    LockGuard<Mutex>
        guard(sc->watchdogLock);\n    sc->watchdogTimeout = Nothing();\n    return
        true;\n  }\n\n#ifdef __wasi__\n  return false;\n#endif\n\n  auto interval
        = TimeDuration::FromSeconds(t);\n  auto timeout = TimeStamp::Now() + interval;\n
        \ LockGuard<Mutex> guard(sc->watchdogLock);\n  if (!sc->watchdogThread) {\n
        \   MOZ_ASSERT(!sc->watchdogTimeout);\n    sc->watchdogThread.emplace();\n
        \   AutoEnterOOMUnsafeRegion oomUnsafe;\n    if (!sc->watchdogThread->init(WatchdogMain,
        cx)) {\n      oomUnsafe.crash(\"watchdogThread.init\");\n    }\n  } else if
        (!sc->watchdogTimeout || timeout < sc->watchdogTimeout.value()) {\n    sc->watchdogWakeup.notify_one();\n
        \ }\n  sc->watchdogTimeout = Some(timeout);\n  return true;\n}\n\nstatic void
        KillWorkerThreads(JSContext* cx) {\n  MOZ_ASSERT_IF(!CanUseExtraThreads(),
        workerThreads.empty());\n\n  if (!workerThreadsLock) {\n    MOZ_ASSERT(workerThreads.empty());\n
        \   return;\n  }\n\n  while (true) {\n    // We need to leave the AutoLockWorkerThreads
        scope before we call\n    // js::Thread::join, to avoid deadlocks when AutoLockWorkerThreads
        is\n    // used by the worker thread.\n    UniquePtr<Thread> thread;\n    {\n
        \     AutoLockWorkerThreads alwt;\n      if (workerThreads.empty()) {\n        break;\n
        \     }\n      thread = std::move(workerThreads.back());\n      workerThreads.popBack();\n
        \   }\n    thread->join();\n  }\n\n  workerThreads.clearAndFree();\n\n  js_delete(workerThreadsLock);\n
        \ workerThreadsLock = nullptr;\n}\n\nstatic void CancelExecution(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  sc->serviceInterrupt =
        true;\n  JS_RequestInterruptCallback(cx);\n}\n\nstatic bool SetTimeoutValue(JSContext*
        cx, double t) {\n  if (std::isnan(t)) {\n    JS_ReportErrorASCII(cx, \"timeout
        is not a number\");\n    return false;\n  }\n  const TimeDuration MAX_TIMEOUT_INTERVAL
        =\n      TimeDuration::FromSeconds(MAX_TIMEOUT_SECONDS);\n  if (TimeDuration::FromSeconds(t)
        > MAX_TIMEOUT_INTERVAL) {\n    JS_ReportErrorASCII(cx, \"Excessive timeout
        value\");\n    return false;\n  }\n  GetShellContext(cx)->timeoutInterval
        = t;\n  if (!ScheduleWatchdog(cx, t)) {\n    JS_ReportErrorASCII(cx, \"Failed
        to create the watchdog\");\n    return false;\n  }\n  return true;\n}\n\nstatic
        bool Timeout(JSContext* cx, unsigned argc, Value* vp) {\n  ShellContext* sc
        = GetShellContext(cx);\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if
        (args.length() == 0) {\n    args.rval().setNumber(sc->timeoutInterval);\n
        \   return true;\n  }\n\n  if (args.length() > 2) {\n    JS_ReportErrorASCII(cx,
        \"Wrong number of arguments\");\n    return false;\n  }\n\n  double t;\n  if
        (!ToNumber(cx, args[0], &t)) {\n    return false;\n  }\n\n  if (args.length()
        > 1) {\n    RootedValue value(cx, args[1]);\n    if (!value.isObject() ||
        !value.toObject().is<JSFunction>()) {\n      JS_ReportErrorASCII(cx, \"Second
        argument must be a timeout function\");\n      return false;\n    }\n    sc->interruptFunc
        = value;\n    sc->haveInterruptFunc = true;\n  }\n\n  args.rval().setUndefined();\n
        \ return SetTimeoutValue(cx, t);\n}\n\nstatic bool InterruptIf(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 1) {\n    JS_ReportErrorASCII(cx, \"Wrong number of
        arguments\");\n    return false;\n  }\n\n  if (ToBoolean(args[0])) {\n    GetShellContext(cx)->serviceInterrupt
        = true;\n    JS_RequestInterruptCallback(cx);\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool InvokeInterruptCallbackWrapper(JSContext*
        cx, unsigned argc,\n                                           Value* vp)
        {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length() != 1)
        {\n    JS_ReportErrorASCII(cx, \"Wrong number of arguments\");\n    return
        false;\n  }\n\n  GetShellContext(cx)->serviceInterrupt = true;\n  JS_RequestInterruptCallback(cx);\n
        \ bool interruptRv = CheckForInterrupt(cx);\n\n  // The interrupt handler
        could have set a pending exception. Since we call\n  // back into JS, don't
        have it see the pending exception. If we have an\n  // uncatchable exception
        that's not propagating a debug mode forced\n  // return, return.\n  if (!interruptRv
        && !cx->isExceptionPending() &&\n      !cx->isPropagatingForcedReturn()) {\n
        \   return false;\n  }\n\n  JS::AutoSaveExceptionState savedExc(cx);\n\n  FixedInvokeArgs<1>
        iargs(cx);\n\n  iargs[0].setBoolean(interruptRv);\n\n  RootedValue rv(cx);\n
        \ if (!js::Call(cx, args[0], UndefinedHandleValue, iargs, &rv)) {\n    return
        false;\n  }\n\n  args.rval().setUndefined();\n  return interruptRv;\n}\n\nstatic
        bool SetInterruptCallback(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 1) {\n    JS_ReportErrorASCII(cx,
        \"Wrong number of arguments\");\n    return false;\n  }\n\n  RootedValue value(cx,
        args[0]);\n  if (!value.isObject() || !value.toObject().is<JSFunction>())
        {\n    JS_ReportErrorASCII(cx, \"Argument must be a function\");\n    return
        false;\n  }\n  GetShellContext(cx)->interruptFunc = value;\n  GetShellContext(cx)->haveInterruptFunc
        = true;\n\n  args.rval().setUndefined();\n  return true;\n}\n\n#ifdef DEBUG\n//
        var s0 = \"A\".repeat(10*1024);\n// interruptRegexp(/a(bc|bd)/, s0);\n// first
        arg is regexp\n// second arg is string\nstatic bool InterruptRegexp(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ ShellContext* sc = GetShellContext(cx);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() != 2) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments.\");\n    return false;\n  }\n  if (!(args[0].isObject()
        && args[0].toObject().is<RegExpObject>())) {\n    ReportUsageErrorASCII(cx,
        callee,\n                          \"First argument must be a regular expression.\");\n
        \   return false;\n  }\n  if (!args[1].isString()) {\n    ReportUsageErrorASCII(cx,
        callee, \"Second argument must be a String.\");\n    return false;\n  }\n
        \ // Set interrupt flags\n  sc->serviceInterrupt = true;\n  js::irregexp::IsolateSetShouldSimulateInterrupt(cx->isolate);\n\n
        \ RootedObject regexp(cx, &args[0].toObject());\n  RootedString string(cx,
        args[1].toString());\n  int32_t lastIndex = 0;\n\n  return js::RegExpMatcherRaw(cx,
        regexp, string, lastIndex, nullptr,\n                              args.rval());\n}\n#endif\n\nstatic
        bool SetJitCompilerOption(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() != 2) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments.\");\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be a String.\");\n
        \   return false;\n  }\n\n  if (!args[1].isInt32()) {\n    ReportUsageErrorASCII(cx,
        callee, \"Second argument must be an Int32.\");\n    return false;\n  }\n\n
        \ // Disallow setting JIT options when there are worker threads, to avoid\n
        \ // races.\n  if (workerThreadsLock) {\n    ReportUsageErrorASCII(\n        cx,
        callee, \"Can't set JIT options when there are worker threads.\");\n    return
        false;\n  }\n\n  JSLinearString* strArg = JS_EnsureLinearString(cx, args[0].toString());\n
        \ if (!strArg) {\n    return false;\n  }\n\n#define JIT_COMPILER_MATCH(key,
        string)                        \\\n  else if (JS_LinearStringEqualsLiteral(strArg,
        string)) opt = \\\n      JSJITCOMPILER_##key;\n\n  JSJitCompilerOption opt
        = JSJITCOMPILER_NOT_AN_OPTION;\n  if (false) {\n  }\n  JIT_COMPILER_OPTIONS(JIT_COMPILER_MATCH);\n#undef
        JIT_COMPILER_MATCH\n\n  if (opt == JSJITCOMPILER_NOT_AN_OPTION) {\n    ReportUsageErrorASCII(\n
        \       cx, callee,\n        \"First argument does not name a valid option
        (see jsapi.h).\");\n    return false;\n  }\n\n  int32_t number = args[1].toInt32();\n
        \ if (number < 0) {\n    number = -1;\n  }\n\n  // Disallow enabling or disabling
        the Baseline Interpreter at runtime.\n  // Enabling is a problem because the
        Baseline Interpreter code is only\n  // present if the interpreter was enabled
        when the JitRuntime was created.\n  // To support disabling we would have
        to discard all JitScripts. Furthermore,\n  // we really want JitOptions to
        be immutable after startup so it's better to\n  // use shell flags.\n  if
        (opt == JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE &&\n      bool(number) !=
        jit::IsBaselineInterpreterEnabled()) {\n    JS_ReportErrorASCII(cx,\n                        \"Enabling
        or disabling the Baseline Interpreter at \"\n                        \"runtime
        is not supported.\");\n    return false;\n  }\n\n  // Throw if disabling the
        JITs and there's JIT code on the stack, to avoid\n  // assertion failures.\n
        \ if ((opt == JSJITCOMPILER_BASELINE_ENABLE ||\n       opt == JSJITCOMPILER_ION_ENABLE)
        &&\n      number == 0) {\n    js::jit::JitActivationIterator iter(cx);\n    if
        (!iter.done()) {\n      JS_ReportErrorASCII(cx,\n                          \"Can't
        turn off JITs with JIT code on the stack.\");\n      return false;\n    }\n
        \ }\n\n  // Throw if trying to disable all the Wasm compilers.  The logic
        here is that\n  // if we're trying to disable a compiler that is currently
        enabled and that is\n  // the last compiler enabled then we must throw.\n
        \ //\n  // Note that this check does not prevent an error from being thrown
        later.\n  // Actual compiler availability is dynamic and depends on other
        conditions,\n  // such as other options set and whether a debugger is present.\n
        \ if ((opt == JSJITCOMPILER_WASM_JIT_BASELINE ||\n       opt == JSJITCOMPILER_WASM_JIT_OPTIMIZING)
        &&\n      number == 0) {\n    uint32_t baseline, optimizing;\n    MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(\n
        \       cx, JSJITCOMPILER_WASM_JIT_BASELINE, &baseline));\n    MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(\n
        \       cx, JSJITCOMPILER_WASM_JIT_OPTIMIZING, &optimizing));\n    if (baseline
        + optimizing == 1) {\n      if ((opt == JSJITCOMPILER_WASM_JIT_BASELINE &&
        baseline) ||\n          (opt == JSJITCOMPILER_WASM_JIT_OPTIMIZING && optimizing))
        {\n        JS_ReportErrorASCII(\n            cx,\n            \"Disabling
        all the Wasm compilers at runtime is not supported.\");\n        return false;\n
        \     }\n    }\n  }\n\n  // JIT compiler options are process-wide, so we have
        to stop off-thread\n  // compilations for all runtimes to avoid races.\n  WaitForAllHelperThreads();\n\n
        \ // Only release JIT code for the current runtime because there's no good\n
        \ // way to discard code for other runtimes.\n  ReleaseAllJITCode(cx->gcContext());\n\n
        \ JS_SetGlobalJitCompilerOption(cx, opt, uint32_t(number));\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool EnableLastWarning(JSContext* cx, unsigned
        argc, Value* vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  sc->lastWarningEnabled = true;\n  sc->lastWarning.setNull();\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool DisableLastWarning(JSContext*
        cx, unsigned argc, Value* vp) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  sc->lastWarningEnabled =
        false;\n  sc->lastWarning.setNull();\n\n  args.rval().setUndefined();\n  return
        true;\n}\n\nstatic bool GetLastWarning(JSContext* cx, unsigned argc, Value*
        vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (!sc->lastWarningEnabled) {\n    JS_ReportErrorASCII(cx, \"Call
        enableLastWarning first.\");\n    return false;\n  }\n\n  if (!JS_WrapValue(cx,
        &sc->lastWarning)) {\n    return false;\n  }\n\n  args.rval().set(sc->lastWarning);\n
        \ return true;\n}\n\nstatic bool ClearLastWarning(JSContext* cx, unsigned
        argc, Value* vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (!sc->lastWarningEnabled) {\n    JS_ReportErrorASCII(cx,
        \"Call enableLastWarning first.\");\n    return false;\n  }\n\n  sc->lastWarning.setNull();\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\n#if defined(DEBUG) ||
        defined(JS_JITSPEW)\nstatic bool StackDump(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!gOutFile->isOpen())
        {\n    JS_ReportErrorASCII(cx, \"output file is closed\");\n    return false;\n
        \ }\n\n  bool showArgs = ToBoolean(args.get(0));\n  bool showLocals = ToBoolean(args.get(1));\n
        \ bool showThisProps = ToBoolean(args.get(2));\n\n  JS::UniqueChars buf =\n
        \     JS::FormatStackDump(cx, showArgs, showLocals, showThisProps);\n  if
        (!buf) {\n    fputs(\"Failed to format JavaScript stack for dump\\n\", gOutFile->fp);\n
        \   JS_ClearPendingException(cx);\n  } else {\n    fputs(buf.get(), gOutFile->fp);\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n#endif\n\nstatic
        bool StackPointerInfo(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  // Copy the truncated stack pointer
        to the result.  This value is not used\n  // as a pointer but as a way to
        measure frame-size from JS.\n  args.rval().setInt32(int32_t(reinterpret_cast<size_t>(&args)
        & 0xfffffff));\n  return true;\n}\n\nstatic bool Elapsed(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        == 0) {\n    double d = PRMJ_Now() - GetShellContext(cx)->startTime;\n    args.rval().setDouble(d);\n
        \   return true;\n  }\n  JS_ReportErrorASCII(cx, \"Wrong number of arguments\");\n
        \ return false;\n}\n\nstatic ShellCompartmentPrivate* EnsureShellCompartmentPrivate(JSContext*
        cx) {\n  Compartment* comp = cx->compartment();\n  auto priv =\n      static_cast<ShellCompartmentPrivate*>(JS_GetCompartmentPrivate(comp));\n
        \ if (!priv) {\n    priv = cx->new_<ShellCompartmentPrivate>();\n    JS_SetCompartmentPrivate(cx->compartment(),
        priv);\n  }\n  return priv;\n}\n\nstatic bool ParseModule(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"parseModule\", 1)) {\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"expected string to compile, got %s\", typeName);\n    return false;\n  }\n\n
        \ JSString* scriptContents = args[0].toString();\n\n  UniqueChars filename;\n
        \ CompileOptions options(cx);\n  if (args.length() > 1) {\n    if (!args[1].isString())
        {\n      const char* typeName = InformalValueTypeName(args[1]);\n      JS_ReportErrorASCII(cx,
        \"expected filename string, got %s\", typeName);\n      return false;\n    }\n\n
        \   RootedString str(cx, args[1].toString());\n    filename = JS_EncodeStringToUTF8(cx,
        str);\n    if (!filename) {\n      return false;\n    }\n\n    options.setFileAndLine(filename.get(),
        1);\n  } else {\n    options.setFileAndLine(\"<string>\", 1);\n  }\n  options.setModule();\n\n
        \ AutoStableStringChars linearChars(cx);\n  if (!linearChars.initTwoByte(cx,
        scriptContents)) {\n    return false;\n  }\n\n  JS::SourceText<char16_t> srcBuf;\n
        \ if (!srcBuf.initMaybeBorrowed(cx, linearChars)) {\n    return false;\n  }\n\n
        \ AutoReportFrontendContext fc(cx);\n  RootedObject module(cx, frontend::CompileModule(cx,
        &fc, options, srcBuf));\n  if (!module) {\n    return false;\n  }\n\n  Rooted<ShellModuleObjectWrapper*>
        wrapper(\n      cx, ShellModuleObjectWrapper::create(cx, module.as<ModuleObject>()));\n
        \ if (!wrapper) {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n
        \ return true;\n}\n\n// A JSObject that holds XDRBuffer.\nclass XDRBufferObject
        : public NativeObject {\n  static const size_t VECTOR_SLOT = 0;\n  static
        const unsigned RESERVED_SLOTS = 1;\n\n public:\n  static const JSClassOps
        classOps_;\n  static const JSClass class_;\n\n  [[nodiscard]] inline static
        XDRBufferObject* create(\n      JSContext* cx, JS::TranscodeBuffer&& buf);\n\n
        \ JS::TranscodeBuffer* data() const {\n    Value value = getReservedSlot(VECTOR_SLOT);\n
        \   auto buf = static_cast<JS::TranscodeBuffer*>(value.toPrivate());\n    MOZ_ASSERT(buf);\n
        \   return buf;\n  }\n\n  bool hasData() const {\n    // Data may not be present
        if we hit OOM in initialization.\n    return !getReservedSlot(VECTOR_SLOT).isUndefined();\n
        \ }\n\n  static void finalize(JS::GCContext* gcx, JSObject* obj);\n};\n\n/*static
        */ const JSClassOps XDRBufferObject::classOps_ = {\n    nullptr,                    //
        addProperty\n    nullptr,                    // delProperty\n    nullptr,
        \                   // enumerate\n    nullptr,                    // newEnumerate\n
        \   nullptr,                    // resolve\n    nullptr,                    //
        mayResolve\n    XDRBufferObject::finalize,  // finalize\n    nullptr,                    //
        call\n    nullptr,                    // construct\n    nullptr,                    //
        trace\n};\n\n/*static */ const JSClass XDRBufferObject::class_ = {\n    \"XDRBufferObject\",\n
        \   JSCLASS_HAS_RESERVED_SLOTS(XDRBufferObject::RESERVED_SLOTS) |\n        JSCLASS_BACKGROUND_FINALIZE,\n
        \   &XDRBufferObject::classOps_};\n\nXDRBufferObject* XDRBufferObject::create(JSContext*
        cx,\n                                         JS::TranscodeBuffer&& buf) {\n
        \ XDRBufferObject* bufObj =\n      NewObjectWithGivenProto<XDRBufferObject>(cx,
        nullptr);\n  if (!bufObj) {\n    return nullptr;\n  }\n\n  auto heapBuf =
        cx->make_unique<JS::TranscodeBuffer>(std::move(buf));\n  if (!heapBuf) {\n
        \   return nullptr;\n  }\n\n  size_t len = heapBuf->length();\n  InitReservedSlot(bufObj,
        VECTOR_SLOT, heapBuf.release(), len,\n                   MemoryUse::XDRBufferElements);\n\n
        \ return bufObj;\n}\n\nvoid XDRBufferObject::finalize(JS::GCContext* gcx,
        JSObject* obj) {\n  XDRBufferObject* buf = &obj->as<XDRBufferObject>();\n
        \ if (buf->hasData()) {\n    gcx->delete_(buf, buf->data(), buf->data()->length(),\n
        \                MemoryUse::XDRBufferElements);\n  }\n}\n\nstatic bool InstantiateModuleStencil(JSContext*
        cx, uint32_t argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (!args.requireAtLeast(cx, \"instantiateModuleStencil\", 1)) {\n    return
        false;\n  }\n\n  /* Prepare the input byte array. */\n  if (!args[0].isObject()
        || !args[0].toObject().is<js::StencilObject>()) {\n    JS_ReportErrorASCII(cx,\n
        \                       \"instantiateModuleStencil: Stencil object expected\");\n
        \   return false;\n  }\n  Rooted<js::StencilObject*> stencilObj(\n      cx,
        &args[0].toObject().as<js::StencilObject>());\n\n  if (!stencilObj->stencil()->isModule())
        {\n    JS_ReportErrorASCII(cx,\n                        \"instantiateModuleStencil:
        Module stencil expected\");\n    return false;\n  }\n\n  CompileOptions options(cx);\n
        \ UniqueChars fileNameBytes;\n  if (args.length() == 2) {\n    if (!args[1].isObject())
        {\n      JS_ReportErrorASCII(\n          cx, \"instantiateModuleStencil: The
        2nd argument must be an object\");\n      return false;\n    }\n\n    RootedObject
        opts(cx, &args[1].toObject());\n    if (!js::ParseCompileOptions(cx, options,
        opts, &fileNameBytes)) {\n      return false;\n    }\n  }\n\n  /* Prepare
        the CompilationStencil for decoding. */\n  AutoReportFrontendContext fc(cx);\n
        \ Rooted<frontend::CompilationInput> input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (!input.get().initForModule(&fc)) {\n    return false;\n  }\n\n  /* Instantiate
        the stencil. */\n  Rooted<frontend::CompilationGCOutput> output(cx);\n  if
        (!frontend::CompilationStencil::instantiateStencils(\n          cx, input.get(),
        *stencilObj->stencil(), output.get())) {\n    return false;\n  }\n\n  Rooted<ModuleObject*>
        modObject(cx, output.get().module);\n  Rooted<ShellModuleObjectWrapper*> wrapper(\n
        \     cx, ShellModuleObjectWrapper::create(cx, modObject));\n  if (!wrapper)
        {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n  return true;\n}\n\nstatic
        bool InstantiateModuleStencilXDR(JSContext* cx, uint32_t argc,\n                                        Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx,
        \"instantiateModuleStencilXDR\", 1)) {\n    return false;\n  }\n\n  /* Prepare
        the input byte array. */\n  if (!args[0].isObject() || !args[0].toObject().is<StencilXDRBufferObject>())
        {\n    JS_ReportErrorASCII(\n        cx, \"instantiateModuleStencilXDR: stencil
        XDR object expected\");\n    return false;\n  }\n  Rooted<StencilXDRBufferObject*>
        xdrObj(\n      cx, &args[0].toObject().as<StencilXDRBufferObject>());\n  MOZ_ASSERT(xdrObj->hasBuffer());\n\n
        \ CompileOptions options(cx);\n  UniqueChars fileNameBytes;\n  if (args.length()
        == 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(\n          cx,\n
        \         \"instantiateModuleStencilXDR: The 2nd argument must be an object\");\n
        \     return false;\n    }\n\n    RootedObject opts(cx, &args[1].toObject());\n
        \   if (!js::ParseCompileOptions(cx, options, opts, &fileNameBytes)) {\n      return
        false;\n    }\n  }\n\n  /* Prepare the CompilationStencil for decoding. */\n
        \ AutoReportFrontendContext fc(cx);\n  Rooted<frontend::CompilationInput>
        input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (!input.get().initForModule(&fc)) {\n    return false;\n  }\n  frontend::CompilationStencil
        stencil(nullptr);\n\n  /* Deserialize the stencil from XDR. */\n  JS::TranscodeRange
        xdrRange(xdrObj->buffer(), xdrObj->bufferLength());\n  bool succeeded = false;\n
        \ if (!stencil.deserializeStencils(&fc, options, xdrRange, &succeeded)) {\n
        \   return false;\n  }\n  if (!succeeded) {\n    fc.clearAutoReport();\n    JS_ReportErrorASCII(cx,
        \"Decoding failure\");\n    return false;\n  }\n\n  if (!stencil.isModule())
        {\n    fc.clearAutoReport();\n    JS_ReportErrorASCII(cx,\n                        \"instantiateModuleStencilXDR:
        Module stencil expected\");\n    return false;\n  }\n\n  /* Instantiate the
        stencil. */\n  Rooted<frontend::CompilationGCOutput> output(cx);\n  if (!frontend::CompilationStencil::instantiateStencils(\n
        \         cx, input.get(), stencil, output.get())) {\n    return false;\n
        \ }\n\n  Rooted<ModuleObject*> modObject(cx, output.get().module);\n  Rooted<ShellModuleObjectWrapper*>
        wrapper(\n      cx, ShellModuleObjectWrapper::create(cx, modObject));\n  if
        (!wrapper) {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n
        \ return true;\n}\n\nstatic bool RegisterModule(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"registerModule\", 2)) {\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"expected string, got %s\", typeName);\n    return false;\n  }\n\n  if (!args[1].isObject()
        ||\n      !args[1].toObject().is<ShellModuleObjectWrapper>()) {\n    const
        char* typeName = InformalValueTypeName(args[1]);\n    JS_ReportErrorASCII(cx,
        \"expected module, got %s\", typeName);\n    return false;\n  }\n\n  ShellContext*
        sc = GetShellContext(cx);\n  Rooted<ModuleObject*> module(\n      cx, args[1].toObject().as<ShellModuleObjectWrapper>().get());\n\n
        \ Rooted<JSAtom*> specifier(cx, AtomizeString(cx, args[0].toString()));\n
        \ if (!specifier) {\n    return false;\n  }\n\n  RootedObject moduleRequest(\n
        \     cx, ModuleRequestObject::create(cx, specifier, nullptr));\n  if (!moduleRequest)
        {\n    return false;\n  }\n\n  if (!sc->moduleLoader->registerTestModule(cx,
        moduleRequest, module)) {\n    return false;\n  }\n\n  Rooted<ShellModuleObjectWrapper*>
        wrapper(\n      cx, ShellModuleObjectWrapper::create(cx, module));\n  if (!wrapper)
        {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n  return true;\n}\n\nstatic
        bool ClearModules(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  ShellContext* sc = GetShellContext(cx);\n  sc->moduleLoader->clearModules(cx);\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool ModuleLink(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 1 || !args[0].isObject()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleLink\");\n
        \   return false;\n  }\n\n  RootedObject object(cx, UncheckedUnwrap(&args[0].toObject()));\n
        \ if (!object->is<ShellModuleObjectWrapper>()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleLink\");\n
        \   return false;\n  }\n\n  AutoRealm ar(cx, object);\n\n  Rooted<ModuleObject*>
        module(cx,\n                               object->as<ShellModuleObjectWrapper>().get());\n
        \ if (!js::ModuleLink(cx, module)) {\n    return false;\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool ModuleEvaluate(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 1 || !args[0].isObject()) {\n    JS_ReportErrorNumberASCII(cx, GetErrorMessage,
        nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleEvaluate\");\n
        \   return false;\n  }\n\n  RootedObject object(cx, UncheckedUnwrap(&args[0].toObject()));\n
        \ if (!object->is<ShellModuleObjectWrapper>()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleEvaluate\");\n
        \   return false;\n  }\n\n  {\n    AutoRealm ar(cx, object);\n\n    Rooted<ModuleObject*>
        module(cx,\n                                 object->as<ShellModuleObjectWrapper>().get());\n
        \   if (!js::ModuleEvaluate(cx, module, args.rval())) {\n      return false;\n
        \   }\n  }\n\n  return JS_WrapValue(cx, args.rval());\n}\n\nstatic ModuleEnvironmentObject*
        GetModuleInitialEnvironment(\n    JSContext* cx, Handle<ModuleObject*> module)
        {\n  // Use the initial environment so that tests can check bindings exists\n
        \ // before they have been instantiated.\n  Rooted<ModuleEnvironmentObject*>
        env(cx, &module->initialEnvironment());\n  MOZ_ASSERT(env);\n  return env;\n}\n\nstatic
        bool GetModuleEnvironmentNames(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length() != 1) {\n
        \   JS_ReportErrorASCII(cx, \"Wrong number of arguments\");\n    return false;\n
        \ }\n\n  if (!args[0].isObject() ||\n      !args[0].toObject().is<ShellModuleObjectWrapper>())
        {\n    JS_ReportErrorASCII(cx,\n                        \"First argument should
        be a ShellModuleObjectWrapper\");\n    return false;\n  }\n\n  Rooted<ModuleObject*>
        module(\n      cx, args[0].toObject().as<ShellModuleObjectWrapper>().get());\n
        \ if (module->hadEvaluationError()) {\n    JS_ReportErrorASCII(cx, \"Module
        environment unavailable\");\n    return false;\n  }\n\n  Rooted<ModuleEnvironmentObject*>
        env(cx,\n                                       GetModuleInitialEnvironment(cx,
        module));\n  Rooted<IdVector> ids(cx, IdVector(cx));\n  if (!JS_Enumerate(cx,
        env, &ids)) {\n    return false;\n  }\n\n  // The \"*namespace*\" binding
        is a detail of current implementation so hide\n  // it to give stable results
        in tests.\n  ids.eraseIfEqual(NameToId(cx->names().starNamespaceStar));\n\n
        \ uint32_t length = ids.length();\n  Rooted<ArrayObject*> array(cx, NewDenseFullyAllocatedArray(cx,
        length));\n  if (!array) {\n    return false;\n  }\n\n  array->setDenseInitializedLength(length);\n
        \ for (uint32_t i = 0; i < length; i++) {\n    array->initDenseElement(i,
        StringValue(ids[i].toString()));\n  }\n\n  args.rval().setObject(*array);\n
        \ return true;\n}\n\nstatic bool GetModuleEnvironmentValue(JSContext* cx,
        unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (args.length() != 2) {\n    JS_ReportErrorASCII(cx, \"Wrong number of
        arguments\");\n    return false;\n  }\n\n  if (!args[0].isObject() ||\n      !args[0].toObject().is<ShellModuleObjectWrapper>())
        {\n    JS_ReportErrorASCII(cx,\n                        \"First argument should
        be a ShellModuleObjectWrapper\");\n    return false;\n  }\n\n  if (!args[1].isString())
        {\n    JS_ReportErrorASCII(cx, \"Second argument should be a string\");\n
        \   return false;\n  }\n\n  Rooted<ModuleObject*> module(\n      cx, args[0].toObject().as<ShellModuleObjectWrapper>().get());\n
        \ if (module->hadEvaluationError()) {\n    JS_ReportErrorASCII(cx, \"Module
        environment unavailable\");\n    return false;\n  }\n\n  Rooted<ModuleEnvironmentObject*>
        env(cx,\n                                       GetModuleInitialEnvironment(cx,
        module));\n  RootedString name(cx, args[1].toString());\n  RootedId id(cx);\n
        \ if (!JS_StringToId(cx, name, &id)) {\n    return false;\n  }\n\n  if (!GetProperty(cx,
        env, env, id, args.rval())) {\n    return false;\n  }\n\n  if (args.rval().isMagic(JS_UNINITIALIZED_LEXICAL))
        {\n    ReportRuntimeLexicalError(cx, JSMSG_UNINITIALIZED_LEXICAL, id);\n    return
        false;\n  }\n\n  return true;\n}\n\nenum class DumpType {\n  ParseNode,\n
        \ Stencil,\n};\n\ntemplate <typename Unit>\nstatic bool DumpAST(JSContext*
        cx, const JS::ReadOnlyCompileOptions& options,\n                    const
        Unit* units, size_t length,\n                    js::frontend::CompilationState&
        compilationState,\n                    js::frontend::ParseGoal goal) {\n  using
        namespace js::frontend;\n\n  AutoReportFrontendContext fc(cx);\n  Parser<FullParseHandler,
        Unit> parser(&fc, options, units, length,\n                                        /*
        foldConstants = */ false,\n                                        compilationState,\n
        \                                       /* syntaxParser = */ nullptr);\n  if
        (!parser.checkOptions()) {\n    return false;\n  }\n\n  // Emplace the top-level
        stencil.\n  MOZ_ASSERT(compilationState.scriptData.length() ==\n             CompilationStencil::TopLevelIndex);\n
        \ if (!compilationState.appendScriptStencilAndData(&fc)) {\n    return false;\n
        \ }\n\n  js::frontend::ParseNode* pn;\n  if (goal == frontend::ParseGoal::Script)
        {\n    pn = parser.parse();\n  } else {\n    ModuleBuilder builder(&fc, &parser);\n\n
        \   SourceExtent extent = SourceExtent::makeGlobalExtent(length);\n    ModuleSharedContext
        modulesc(&fc, options, builder, extent);\n    pn = parser.moduleBody(&modulesc);\n
        \ }\n\n  if (!pn) {\n    return false;\n  }\n\n#if defined(DEBUG)\n  js::Fprinter
        out(stderr);\n  DumpParseTree(&parser, pn, out);\n#endif\n\n  return true;\n}\n\ntemplate
        <typename Unit>\n[[nodiscard]] static bool DumpStencil(JSContext* cx,\n                                      const
        JS::ReadOnlyCompileOptions& options,\n                                      const
        Unit* units, size_t length,\n                                      js::frontend::ParseGoal
        goal) {\n  Rooted<frontend::CompilationInput> input(cx,\n                                           frontend::CompilationInput(options));\n\n
        \ JS::SourceText<Unit> srcBuf;\n  if (!srcBuf.init(cx, units, length, JS::SourceOwnership::Borrowed))
        {\n    return false;\n  }\n\n  AutoReportFrontendContext fc(cx);\n  js::frontend::NoScopeBindingCache
        scopeCache;\n  UniquePtr<frontend::ExtensibleCompilationStencil> stencil;\n
        \ if (goal == frontend::ParseGoal::Script) {\n    stencil = frontend::CompileGlobalScriptToExtensibleStencil(\n
        \       cx, &fc, input.get(), &scopeCache, srcBuf, ScopeKind::Global);\n  }
        else {\n    stencil = frontend::ParseModuleToExtensibleStencil(\n        cx,
        &fc, cx->tempLifoAlloc(), input.get(), &scopeCache, srcBuf);\n  }\n\n  if
        (!stencil) {\n    return false;\n  }\n\n#if defined(DEBUG) || defined(JS_JITSPEW)\n
        \ stencil->dump();\n#endif\n\n  return true;\n}\n\nstatic bool FrontendTest(JSContext*
        cx, unsigned argc, Value* vp,\n                         const char* funcName,
        DumpType dumpType) {\n  using namespace js::frontend;\n\n  CallArgs args =
        CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx, funcName, 1))
        {\n    return false;\n  }\n  if (!args[0].isString()) {\n    const char* typeName
        = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx, \"expected
        string to parse, got %s\", typeName);\n    return false;\n  }\n\n  frontend::ParseGoal
        goal = frontend::ParseGoal::Script;\n#ifdef JS_ENABLE_SMOOSH\n  bool smoosh
        = false;\n#endif\n\n  CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell parse\")\n      .setFileAndLine(\"<string>\", 1)\n      .setIsRunOnce(true)\n
        \     .setNoScriptRval(true);\n\n  if (args.length() >= 2) {\n    if (!args[1].isObject())
        {\n      JS_ReportErrorASCII(cx, \"The 2nd argument must be an object\");\n
        \     return false;\n    }\n\n    RootedObject objOptions(cx, &args[1].toObject());\n\n
        \   RootedValue optionModule(cx);\n    if (!JS_GetProperty(cx, objOptions,
        \"module\", &optionModule)) {\n      return false;\n    }\n\n    if (optionModule.isBoolean())
        {\n      if (optionModule.toBoolean()) {\n        goal = frontend::ParseGoal::Module;\n
        \     }\n    } else if (!optionModule.isUndefined()) {\n      const char*
        typeName = InformalValueTypeName(optionModule);\n      JS_ReportErrorASCII(cx,
        \"option `module` should be a boolean, got %s\",\n                          typeName);\n
        \     return false;\n    }\n    if (!js::ParseCompileOptions(cx, options,
        objOptions, nullptr)) {\n      return false;\n    }\n\n#ifdef JS_ENABLE_SMOOSH\n
        \   bool found = false;\n    if (!JS_HasProperty(cx, objOptions, \"rustFrontend\",
        &found)) {\n      return false;\n    }\n    if (found) {\n      JS_ReportErrorASCII(cx,
        \"'rustFrontend' option is renamed to 'smoosh'\");\n      return false;\n
        \   }\n\n    RootedValue optionSmoosh(cx);\n    if (!JS_GetProperty(cx, objOptions,
        \"smoosh\", &optionSmoosh)) {\n      return false;\n    }\n\n    if (optionSmoosh.isBoolean())
        {\n      smoosh = optionSmoosh.toBoolean();\n    } else if (!optionSmoosh.isUndefined())
        {\n      const char* typeName = InformalValueTypeName(optionSmoosh);\n      JS_ReportErrorASCII(cx,
        \"option `smoosh` should be a boolean, got %s\",\n                          typeName);\n
        \     return false;\n    }\n#endif  // JS_ENABLE_SMOOSH\n  }\n\n  JSString*
        scriptContents = args[0].toString();\n  Rooted<JSLinearString*> linearString(cx,
        scriptContents->ensureLinear(cx));\n  if (!linearString) {\n    return false;\n
        \ }\n\n  bool isAscii = false;\n  if (linearString->hasLatin1Chars()) {\n
        \   JS::AutoCheckCannotGC nogc;\n    isAscii = JS::StringIsASCII(mozilla::Span(\n
        \       reinterpret_cast<const char*>(linearString->latin1Chars(nogc)),\n
        \       linearString->length()));\n  }\n\n  AutoStableStringChars stableChars(cx);\n
        \ if (isAscii) {\n    if (!stableChars.init(cx, scriptContents)) {\n      return
        false;\n    }\n    MOZ_ASSERT(stableChars.isLatin1());\n  } else {\n    if
        (!stableChars.initTwoByte(cx, scriptContents)) {\n      return false;\n    }\n
        \ }\n\n  size_t length = scriptContents->length();\n#ifdef JS_ENABLE_SMOOSH\n
        \ if (dumpType == DumpType::ParseNode) {\n    if (smoosh) {\n      if (isAscii)
        {\n        const Latin1Char* chars = stableChars.latin1Range().begin().get();\n\n
        \       if (goal == frontend::ParseGoal::Script) {\n          if (!SmooshParseScript(cx,
        chars, length)) {\n            return false;\n          }\n        } else
        {\n          if (!SmooshParseModule(cx, chars, length)) {\n            return
        false;\n          }\n        }\n        args.rval().setUndefined();\n        return
        true;\n      }\n      JS_ReportErrorASCII(cx,\n                          \"SmooshMonkey
        does not support non-ASCII chars yet\");\n      return false;\n    }\n  }\n#endif
        \ // JS_ENABLE_SMOOSH\n\n  if (goal == frontend::ParseGoal::Module) {\n    //
        See frontend::CompileModule.\n    options.setForceStrictMode();\n    options.allowHTMLComments
        = false;\n  }\n\n  if (dumpType == DumpType::Stencil) {\n#ifdef JS_ENABLE_SMOOSH\n
        \   if (smoosh) {\n      if (isAscii) {\n        if (goal == frontend::ParseGoal::Script)
        {\n          const Latin1Char* latin1 = stableChars.latin1Range().begin().get();\n
        \         auto utf8 = reinterpret_cast<const mozilla::Utf8Unit*>(latin1);\n
        \         JS::SourceText<Utf8Unit> srcBuf;\n          if (!srcBuf.init(cx,
        utf8, length, JS::SourceOwnership::Borrowed)) {\n            return false;\n
        \         }\n\n          AutoReportFrontendContext fc(cx);\n          Rooted<frontend::CompilationInput>
        input(\n              cx, frontend::CompilationInput(options));\n          UniquePtr<frontend::ExtensibleCompilationStencil>
        stencil;\n          if (!Smoosh::tryCompileGlobalScriptToExtensibleStencil(\n
        \                 cx, &fc, input.get(), srcBuf, stencil)) {\n            return
        false;\n          }\n          if (!stencil) {\n            fc.clearAutoReport();\n
        \           JS_ReportErrorASCII(cx, \"SmooshMonkey failed to parse\");\n            return
        false;\n          }\n\n#  ifdef DEBUG\n          {\n            frontend::BorrowingCompilationStencil
        borrowingStencil(*stencil);\n            borrowingStencil.dump();\n          }\n#
        \ endif\n        } else {\n          JS_ReportErrorASCII(cx,\n                              \"SmooshMonkey
        does not support module stencil\");\n          return false;\n        }\n
        \       args.rval().setUndefined();\n        return true;\n      }\n      JS_ReportErrorASCII(cx,\n
        \                         \"SmooshMonkey does not support non-ASCII chars
        yet\");\n      return false;\n    }\n#endif  // JS_ENABLE_SMOOSH\n\n    if
        (isAscii) {\n      const Latin1Char* latin1 = stableChars.latin1Range().begin().get();\n
        \     auto utf8 = reinterpret_cast<const mozilla::Utf8Unit*>(latin1);\n      if
        (!DumpStencil<mozilla::Utf8Unit>(cx, options, utf8, length, goal)) {\n        return
        false;\n      }\n    } else {\n      MOZ_ASSERT(stableChars.isTwoByte());\n
        \     const char16_t* chars = stableChars.twoByteRange().begin().get();\n
        \     if (!DumpStencil<char16_t>(cx, options, chars, length, goal)) {\n        return
        false;\n      }\n    }\n\n    args.rval().setUndefined();\n    return true;\n
        \ }\n\n  AutoReportFrontendContext fc(cx);\n  Rooted<frontend::CompilationInput>
        input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (goal == frontend::ParseGoal::Script) {\n    if (!input.get().initForGlobal(&fc))
        {\n      return false;\n    }\n  } else {\n    if (!input.get().initForModule(&fc))
        {\n      return false;\n    }\n  }\n\n  LifoAllocScope allocScope(&cx->tempLifoAlloc());\n
        \ frontend::NoScopeBindingCache scopeCache;\n  frontend::CompilationState
        compilationState(&fc, allocScope, input.get());\n  if (!compilationState.init(&fc,
        &scopeCache)) {\n    return false;\n  }\n\n  if (isAscii) {\n    const Latin1Char*
        latin1 = stableChars.latin1Range().begin().get();\n    auto utf8 = reinterpret_cast<const
        mozilla::Utf8Unit*>(latin1);\n    if (!DumpAST<mozilla::Utf8Unit>(cx, options,
        utf8, length, compilationState,\n                                    goal))
        {\n      return false;\n    }\n  } else {\n    MOZ_ASSERT(stableChars.isTwoByte());\n
        \   const char16_t* chars = stableChars.twoByteRange().begin().get();\n    if
        (!DumpAST<char16_t>(cx, options, chars, length, compilationState,\n                           goal))
        {\n      return false;\n    }\n  }\n  args.rval().setUndefined();\n  return
        true;\n}\n\nstatic bool DumpStencil(JSContext* cx, unsigned argc, Value* vp)
        {\n  return FrontendTest(cx, argc, vp, \"dumpStencil\", DumpType::Stencil);\n}\n\nstatic
        bool Parse(JSContext* cx, unsigned argc, Value* vp) {\n  // Parse returns
        local scope information with variables ordered\n  // differently, depending
        on the underlying JIT implementation.\n  if (js::SupportDifferentialTesting())
        {\n    JS_ReportErrorASCII(cx,\n                        \"Function not available
        in differential testing mode.\");\n    return false;\n  }\n\n  return FrontendTest(cx,
        argc, vp, \"parse\", DumpType::ParseNode);\n}\n\nstatic bool SyntaxParse(JSContext*
        cx, unsigned argc, Value* vp) {\n  using namespace js::frontend;\n\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx, \"syntaxParse\",
        1)) {\n    return false;\n  }\n  if (!args[0].isString()) {\n    const char*
        typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx, \"expected
        string to parse, got %s\", typeName);\n    return false;\n  }\n\n  JSString*
        scriptContents = args[0].toString();\n\n  CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell syntaxParse\")\n      .setFileAndLine(\"<string>\", 1);\n\n  AutoStableStringChars
        stableChars(cx);\n  if (!stableChars.initTwoByte(cx, scriptContents)) {\n
        \   return false;\n  }\n\n  const char16_t* chars = stableChars.twoByteRange().begin().get();\n
        \ size_t length = scriptContents->length();\n\n  AutoReportFrontendContext
        fc(cx);\n  Rooted<frontend::CompilationInput> input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (!input.get().initForGlobal(&fc)) {\n    return false;\n  }\n\n  LifoAllocScope
        allocScope(&cx->tempLifoAlloc());\n  frontend::NoScopeBindingCache scopeCache;\n
        \ frontend::CompilationState compilationState(&fc, allocScope, input.get());\n
        \ if (!compilationState.init(&fc, &scopeCache)) {\n    return false;\n  }\n\n
        \ Parser<frontend::SyntaxParseHandler, char16_t> parser(\n      &fc, options,
        chars, length,\n      /* foldConstants = */ false, compilationState,\n      /*
        syntaxParser = */ nullptr);\n  if (!parser.checkOptions()) {\n    return false;\n
        \ }\n\n  bool succeeded = parser.parse();\n  if (fc.hadErrors()) {\n    return
        false;\n  }\n\n  if (!succeeded && !parser.hadAbortedSyntaxParse()) {\n    //
        If no exception is posted, either there was an OOM or a language\n    // feature
        unhandled by the syntax parser was encountered.\n    MOZ_ASSERT(fc.hadOutOfMemory());\n
        \   return false;\n  }\n\n  args.rval().setBoolean(succeeded);\n  return true;\n}\n\nstatic
        void OffThreadCompileScriptCallback(JS::OffThreadToken* token,\n                                           void*
        callbackData) {\n  auto job = static_cast<OffThreadJob*>(callbackData);\n
        \ job->markDone(token);\n}\n\nstatic bool OffThreadCompileToStencil(JSContext*
        cx, unsigned argc, Value* vp) {\n  if (!CanUseExtraThreads()) {\n    JS_ReportErrorASCII(\n
        \       cx, \"Can't use offThreadCompileToStencil with --no-threads\");\n
        \   return false;\n  }\n\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (!args.requireAtLeast(cx, \"offThreadCompileToStencil\", 1)) {\n    return
        false;\n  }\n  if (!args[0].isString()) {\n    const char* typeName = InformalValueTypeName(args[0]);\n
        \   JS_ReportErrorASCII(cx, \"expected string to parse, got %s\", typeName);\n
        \   return false;\n  }\n\n  UniqueChars fileNameBytes;\n  CompileOptions options(cx);\n
        \ options.setIntroductionType(\"js shell offThreadCompileToStencil\")\n      .setFileAndLine(\"<string>\",
        1);\n\n  if (args.length() >= 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(\n
        \         cx, \"offThreadCompileToStencil: The 2nd argument must be an object\");\n
        \     return false;\n    }\n\n    // Offthread compilation requires that the
        debug metadata be set when the\n    // script is collected from offthread,
        rather than when compiled.\n    RootedObject opts(cx, &args[1].toObject());\n
        \   if (!js::ParseCompileOptions(cx, options, opts, &fileNameBytes)) {\n      return
        false;\n    }\n  }\n\n  // This option setting must override whatever the
        caller requested.\n  options.setIsRunOnce(true);\n\n  // We assume the caller
        wants caching if at all possible, ignoring\n  // heuristics that make sense
        for a real browser.\n  options.forceAsync = true;\n\n  JSString* scriptContents
        = args[0].toString();\n  AutoStableStringChars stableChars(cx);\n  if (!stableChars.initTwoByte(cx,
        scriptContents)) {\n    return false;\n  }\n\n  size_t length = scriptContents->length();\n
        \ const char16_t* chars = stableChars.twoByteChars();\n\n  // Make sure we
        own the string's chars, so that they are not freed before\n  // the compilation
        is finished.\n  UniqueTwoByteChars ownedChars;\n  if (stableChars.maybeGiveOwnershipToCaller())
        {\n    ownedChars.reset(const_cast<char16_t*>(chars));\n  } else {\n    ownedChars.reset(cx->pod_malloc<char16_t>(length));\n
        \   if (!ownedChars) {\n      return false;\n    }\n\n    mozilla::PodCopy(ownedChars.get(),
        chars, length);\n  }\n\n  if (!JS::CanCompileOffThread(cx, options, length))
        {\n    JS_ReportErrorASCII(cx, \"cannot compile code on worker thread\");\n
        \   return false;\n  }\n\n  OffThreadJob* job =\n      NewOffThreadJob(cx,
        options, OffThreadJob::Source(std::move(ownedChars)));\n  if (!job) {\n    return
        false;\n  }\n\n  JS::SourceText<char16_t> srcBuf;\n  if (!srcBuf.init(cx,
        job->sourceChars(), length,\n                   JS::SourceOwnership::Borrowed)
        ||\n      !JS::CompileToStencilOffThread(cx, options, srcBuf,\n                                     OffThreadCompileScriptCallback,
        job)) {\n    job->cancel();\n    DeleteOffThreadJob(cx, job);\n    return
        false;\n  }\n\n  args.rval().setInt32(job->id);\n  return true;\n}\n\nstatic
        bool FinishOffThreadStencil(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  OffThreadJob* job = LookupOffThreadJobForArgs(cx,
        args, 0);\n  if (!job) {\n    return false;\n  }\n\n  JS::OffThreadToken*
        token = job->waitUntilDone(cx);\n  MOZ_ASSERT(token);\n\n  RefPtr<JS::Stencil>
        stencil = JS::FinishOffThreadStencil(cx, token);\n  DeleteOffThreadJob(cx,
        job);\n  if (!stencil) {\n    return false;\n  }\n  RootedObject stencilObj(cx,\n
        \                         js::StencilObject::create(cx, std::move(stencil)));\n
        \ if (!stencilObj) {\n    return false;\n  }\n\n  args.rval().setObject(*stencilObj);\n
        \ return true;\n}\n\nstatic bool OffThreadCompileModuleToStencil(JSContext*
        cx, unsigned argc,\n                                            Value* vp)
        {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 1
        || !args[0].isString()) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS,\n                              \"offThreadCompileModuleToStencil\");\n
        \   return false;\n  }\n\n  UniqueChars fileNameBytes;\n  CompileOptions options(cx);\n
        \ options.setIntroductionType(\"js shell offThreadCompileModuleToStencil\")\n
        \     .setFileAndLine(\"<string>\", 1);\n  options.setIsRunOnce(true).setSourceIsLazy(false);\n
        \ options.forceAsync = true;\n\n  JSString* scriptContents = args[0].toString();\n
        \ AutoStableStringChars stableChars(cx);\n  if (!stableChars.initTwoByte(cx,
        scriptContents)) {\n    return false;\n  }\n\n  size_t length = scriptContents->length();\n
        \ const char16_t* chars = stableChars.twoByteChars();\n\n  // Make sure we
        own the string's chars, so that they are not freed before\n  // the compilation
        is finished.\n  UniqueTwoByteChars ownedChars;\n  if (stableChars.maybeGiveOwnershipToCaller())
        {\n    ownedChars.reset(const_cast<char16_t*>(chars));\n  } else {\n    ownedChars.reset(cx->pod_malloc<char16_t>(length));\n
        \   if (!ownedChars) {\n      return false;\n    }\n\n    mozilla::PodCopy(ownedChars.get(),
        chars, length);\n  }\n\n  if (!JS::CanCompileOffThread(cx, options, length))
        {\n    JS_ReportErrorASCII(cx, \"cannot compile code on worker thread\");\n
        \   return false;\n  }\n\n  OffThreadJob* job =\n      NewOffThreadJob(cx,
        options, OffThreadJob::Source(std::move(ownedChars)));\n  if (!job) {\n    return
        false;\n  }\n\n  JS::SourceText<char16_t> srcBuf;\n  if (!srcBuf.init(cx,
        job->sourceChars(), length,\n                   JS::SourceOwnership::Borrowed)
        ||\n      !JS::CompileModuleToStencilOffThread(\n          cx, options, srcBuf,
        OffThreadCompileScriptCallback, job)) {\n    job->cancel();\n    DeleteOffThreadJob(cx,
        job);\n    return false;\n  }\n\n  args.rval().setInt32(job->id);\n  return
        true;\n}\n\nstatic bool OffThreadDecodeStencil(JSContext* cx, unsigned argc,
        Value* vp) {\n  if (!CanUseExtraThreads()) {\n    JS_ReportErrorASCII(cx,\n
        \                       \"Can't use offThreadDecodeStencil with --no-threads\");\n
        \   return false;\n  }\n\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (!args.requireAtLeast(cx, \"offThreadDecodeStencil\", 1)) {\n    return
        false;\n  }\n  if (!args[0].isObject() || !CacheEntry_isCacheEntry(&args[0].toObject()))
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"expected cache entry, got %s\", typeName);\n    return false;\n  }\n  RootedObject
        cacheEntry(cx, &args[0].toObject());\n\n  UniqueChars fileNameBytes;\n  CompileOptions
        options(cx);\n  options.setIntroductionType(\"js shell offThreadDecodeStencil\")\n
        \     .setFileAndLine(\"<string>\", 1);\n\n  if (args.length() >= 2) {\n    if
        (!args[1].isObject()) {\n      JS_ReportErrorASCII(\n          cx, \"offThreadDecodeStencil:
        The 2nd argument must be an object\");\n      return false;\n    }\n\n    RootedObject
        opts(cx, &args[1].toObject());\n    if (!js::ParseCompileOptions(cx, options,
        opts, &fileNameBytes)) {\n      return false;\n    }\n  }\n\n  // This option
        setting must override whatever the caller requested, and\n  // this should
        match `Evaluate` that encodes the script.\n  options.setIsRunOnce(false);\n\n
        \ // We assume the caller wants caching if at all possible, ignoring\n  //
        heuristics that make sense for a real browser.\n  options.forceAsync = true;\n\n
        \ JS::TranscodeBuffer loadBuffer;\n  size_t loadLength = 0;\n  uint8_t* loadData
        = nullptr;\n  loadData = CacheEntry_getBytecode(cx, cacheEntry, &loadLength);\n
        \ if (!loadData) {\n    return false;\n  }\n  if (!loadBuffer.append(loadData,
        loadLength)) {\n    JS_ReportOutOfMemory(cx);\n    return false;\n  }\n\n
        \ JS::DecodeOptions decodeOptions(options);\n  if (!JS::CanDecodeOffThread(cx,
        decodeOptions, loadLength)) {\n    JS_ReportErrorASCII(cx, \"cannot compile
        code on worker thread\");\n    return false;\n  }\n\n  OffThreadJob* job =\n
        \     NewOffThreadJob(cx, options, OffThreadJob::Source(std::move(loadBuffer)));\n
        \ if (!job) {\n    return false;\n  }\n\n  if (!JS::DecodeStencilOffThread(cx,
        decodeOptions, job->xdrBuffer(), 0,\n                                  OffThreadCompileScriptCallback,
        job)) {\n    job->cancel();\n    DeleteOffThreadJob(cx, job);\n    return
        false;\n  }\n\n  args.rval().setInt32(job->id);\n  return true;\n}\n\nclass
        AutoCStringVector {\n  Vector<char*> argv_;\n\n public:\n  explicit AutoCStringVector(JSContext*
        cx) : argv_(cx) {}\n  ~AutoCStringVector() {\n    for (size_t i = 0; i < argv_.length();
        i++) {\n      js_free(argv_[i]);\n    }\n  }\n  bool append(UniqueChars&&
        arg) {\n    if (!argv_.append(arg.get())) {\n      return false;\n    }\n\n
        \   // Now owned by this vector.\n    (void)arg.release();\n    return true;\n
        \ }\n  char* const* get() const { return argv_.begin(); }\n  size_t length()
        const { return argv_.length(); }\n  char* operator[](size_t i) const { return
        argv_[i]; }\n  void replace(size_t i, UniqueChars arg) {\n    js_free(argv_[i]);\n
        \   argv_[i] = arg.release();\n  }\n};\n\n#if defined(XP_WIN)\nstatic bool
        EscapeForShell(JSContext* cx, AutoCStringVector& argv) {\n  // Windows will
        break arguments in argv by various spaces, so we wrap each\n  // argument
        in quotes and escape quotes within. Even with quotes, \\ will be\n  // treated
        like an escape character, so inflate each \\ to \\\\.\n\n  for (size_t i =
        0; i < argv.length(); i++) {\n    if (!argv[i]) {\n      continue;\n    }\n\n
        \   size_t newLen = 3;  // quotes before and after and null-terminator\n    for
        (char* p = argv[i]; *p; p++) {\n      newLen++;\n      if (*p == '\\\"' ||
        *p == '\\\\') {\n        newLen++;\n      }\n    }\n\n    auto escaped = cx->make_pod_array<char>(newLen);\n
        \   if (!escaped) {\n      return false;\n    }\n\n    char* src = argv[i];\n
        \   char* dst = escaped.get();\n    *dst++ = '\\\"';\n    while (*src) {\n
        \     if (*src == '\\\"' || *src == '\\\\') {\n        *dst++ = '\\\\';\n
        \     }\n      *dst++ = *src++;\n    }\n    *dst++ = '\\\"';\n    *dst++ =
        '\\0';\n    MOZ_ASSERT(escaped.get() + newLen == dst);\n\n    argv.replace(i,
        std::move(escaped));\n  }\n  return true;\n}\n#endif\n\n#ifndef __wasi__\nstatic
        bool ReadAll(int fd, wasm::Bytes* bytes) {\n  size_t lastLength = bytes->length();\n
        \ while (true) {\n    static const int ChunkSize = 64 * 1024;\n    if (!bytes->growBy(ChunkSize))
        {\n      return false;\n    }\n\n    intptr_t readCount;\n    while (true)
        {\n      readCount = read(fd, bytes->begin() + lastLength, ChunkSize);\n      if
        (readCount >= 0) {\n        break;\n      }\n      if (errno != EINTR) {\n
        \       return false;\n      }\n    }\n\n    if (readCount < ChunkSize) {\n
        \     bytes->shrinkTo(lastLength + readCount);\n      if (readCount == 0)
        {\n        return true;\n      }\n    }\n\n    lastLength = bytes->length();\n
        \ }\n}\n\nstatic bool WriteAll(int fd, const uint8_t* bytes, size_t length)
        {\n  while (length > 0) {\n    int written = write(fd, bytes, length);\n    if
        (written < 0) {\n      if (errno == EINTR) {\n        continue;\n      }\n
        \     return false;\n    }\n    MOZ_ASSERT(unsigned(written) <= length);\n
        \   length -= written;\n    bytes += written;\n  }\n\n  return true;\n}\n\nclass
        AutoPipe {\n  int fds_[2];\n\n public:\n  AutoPipe() {\n    fds_[0] = -1;\n
        \   fds_[1] = -1;\n  }\n\n  ~AutoPipe() {\n    if (fds_[0] != -1) {\n      close(fds_[0]);\n
        \   }\n    if (fds_[1] != -1) {\n      close(fds_[1]);\n    }\n  }\n\n  bool
        init() {\n#  ifdef XP_WIN\n    return !_pipe(fds_, 4096, O_BINARY);\n#  else\n
        \   return !pipe(fds_);\n#  endif\n  }\n\n  int reader() const {\n    MOZ_ASSERT(fds_[0]
        != -1);\n    return fds_[0];\n  }\n\n  int writer() const {\n    MOZ_ASSERT(fds_[1]
        != -1);\n    return fds_[1];\n  }\n\n  void closeReader() {\n    MOZ_ASSERT(fds_[0]
        != -1);\n    close(fds_[0]);\n    fds_[0] = -1;\n  }\n\n  void closeWriter()
        {\n    MOZ_ASSERT(fds_[1] != -1);\n    close(fds_[1]);\n    fds_[1] = -1;\n
        \ }\n};\n#endif  // __wasi__\n\nint shell::sArgc;\nchar** shell::sArgv;\n\n#ifndef
        __wasi__\nstatic const char sWasmCompileAndSerializeFlag[] =\n    \"--wasm-compile-and-serialize\";\nstatic
        Vector<const char*, 5, js::SystemAllocPolicy> sCompilerProcessFlags;\n\nstatic
        bool CompileAndSerializeInSeparateProcess(JSContext* cx,\n                                                 const
        uint8_t* bytecode,\n                                                 size_t
        bytecodeLength,\n                                                 wasm::Bytes*
        serialized) {\n  AutoPipe stdIn, stdOut;\n  if (!stdIn.init() || !stdOut.init())
        {\n    return false;\n  }\n\n  AutoCStringVector argv(cx);\n\n  UniqueChars
        argv0 = DuplicateString(cx, sArgv[0]);\n  if (!argv0 || !argv.append(std::move(argv0)))
        {\n    return false;\n  }\n\n  // Put compiler flags first since they must
        precede the non-option\n  // file-descriptor args (passed on Windows, below).\n
        \ for (unsigned i = 0; i < sCompilerProcessFlags.length(); i++) {\n    UniqueChars
        flags = DuplicateString(cx, sCompilerProcessFlags[i]);\n    if (!flags ||
        !argv.append(std::move(flags))) {\n      return false;\n    }\n  }\n\n  UniqueChars
        arg;\n\n  arg = DuplicateString(sWasmCompileAndSerializeFlag);\n  if (!arg
        || !argv.append(std::move(arg))) {\n    return false;\n  }\n\n#  ifdef XP_WIN\n
        \ // The spawned process will have all the stdIn/stdOut file handles open,
        but\n  // without the power of fork, we need some other way to communicate
        the\n  // integer fd values so we encode them in argv and WasmCompileAndSerialize()\n
        \ // has a matching #ifdef XP_WIN to parse them out. Communicate both ends
        of\n  // both pipes so the child process can closed the unused ends.\n\n  arg
        = JS_smprintf(\"%d\", stdIn.reader());\n  if (!arg || !argv.append(std::move(arg)))
        {\n    return false;\n  }\n\n  arg = JS_smprintf(\"%d\", stdIn.writer());\n
        \ if (!arg || !argv.append(std::move(arg))) {\n    return false;\n  }\n\n
        \ arg = JS_smprintf(\"%d\", stdOut.reader());\n  if (!arg || !argv.append(std::move(arg)))
        {\n    return false;\n  }\n\n  arg = JS_smprintf(\"%d\", stdOut.writer());\n
        \ if (!arg || !argv.append(std::move(arg))) {\n    return false;\n  }\n#  endif\n\n
        \ // Required by both _spawnv and exec.\n  if (!argv.append(nullptr)) {\n
        \   return false;\n  }\n\n#  ifdef XP_WIN\n  if (!EscapeForShell(cx, argv))
        {\n    return false;\n  }\n\n  int childPid = _spawnv(P_NOWAIT, sArgv[0],
        argv.get());\n  if (childPid == -1) {\n    return false;\n  }\n#  else\n  pid_t
        childPid = fork();\n  switch (childPid) {\n    case -1:\n      return false;\n
        \   case 0:\n      // In the child process. Redirect stdin/stdout to the respective
        ends of\n      // the pipes. Closing stdIn.writer() is necessary for stdin
        to hit EOF.\n      // This case statement must not return before exec() takes
        over. Rather,\n      // exit(-1) is used to return failure to the parent process.\n
        \     if (dup2(stdIn.reader(), STDIN_FILENO) == -1) {\n        exit(-1);\n
        \     }\n      if (dup2(stdOut.writer(), STDOUT_FILENO) == -1) {\n        exit(-1);\n
        \     }\n      close(stdIn.reader());\n      close(stdIn.writer());\n      close(stdOut.reader());\n
        \     close(stdOut.writer());\n      execv(sArgv[0], argv.get());\n      exit(-1);\n
        \ }\n#  endif\n\n  // In the parent process. Closing stdOut.writer() is necessary
        for\n  // stdOut.reader() below to hit EOF.\n  stdIn.closeReader();\n  stdOut.closeWriter();\n\n
        \ if (!WriteAll(stdIn.writer(), bytecode, bytecodeLength)) {\n    return false;\n
        \ }\n\n  stdIn.closeWriter();\n\n  if (!ReadAll(stdOut.reader(), serialized))
        {\n    return false;\n  }\n\n  stdOut.closeReader();\n\n  int status;\n#  ifdef
        XP_WIN\n  if (_cwait(&status, childPid, WAIT_CHILD) == -1) {\n    return false;\n
        \ }\n#  else\n  while (true) {\n    if (waitpid(childPid, &status, 0) >= 0)
        {\n      break;\n    }\n    if (errno != EINTR) {\n      return false;\n    }\n
        \ }\n#  endif\n\n  return status == 0;\n}\n\nstatic bool WasmCompileAndSerialize(JSContext*
        cx) {\n  MOZ_ASSERT(wasm::CodeCachingAvailable(cx));\n\n#  ifdef XP_WIN\n
        \ // See CompileAndSerializeInSeparateProcess for why we've had to smuggle\n
        \ // these fd values through argv. Closing the writing ends is necessary for\n
        \ // the reading ends to hit EOF.\n  int flagIndex = 0;\n  for (; flagIndex
        < sArgc; flagIndex++) {\n    if (!strcmp(sArgv[flagIndex], sWasmCompileAndSerializeFlag))
        {\n      break;\n    }\n  }\n  MOZ_RELEASE_ASSERT(flagIndex < sArgc);\n\n
        \ int fdsIndex = flagIndex + 1;\n  MOZ_RELEASE_ASSERT(fdsIndex + 4 == sArgc);\n\n
        \ int stdInReader = atoi(sArgv[fdsIndex + 0]);\n  int stdInWriter = atoi(sArgv[fdsIndex
        + 1]);\n  int stdOutReader = atoi(sArgv[fdsIndex + 2]);\n  int stdOutWriter
        = atoi(sArgv[fdsIndex + 3]);\n\n  int stdIn = stdInReader;\n  close(stdInWriter);\n
        \ close(stdOutReader);\n  int stdOut = stdOutWriter;\n#  else\n  int stdIn
        = STDIN_FILENO;\n  int stdOut = STDOUT_FILENO;\n#  endif\n\n  wasm::MutableBytes
        bytecode = js_new<wasm::ShareableBytes>();\n  if (!ReadAll(stdIn, &bytecode->bytes))
        {\n    return false;\n  }\n\n  wasm::Bytes serialized;\n  if (!wasm::CompileAndSerialize(cx,
        *bytecode, &serialized)) {\n    return false;\n  }\n\n  if (!WriteAll(stdOut,
        serialized.begin(), serialized.length())) {\n    return false;\n  }\n\n  return
        true;\n}\n\nstatic bool WasmCompileInSeparateProcess(JSContext* cx, unsigned
        argc,\n                                         Value* vp) {\n  if (!wasm::CodeCachingAvailable(cx))
        {\n    JS_ReportErrorASCII(cx, \"WebAssembly caching not supported\");\n    return
        false;\n  }\n\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"wasmCompileInSeparateProcess\", 1)) {\n    return false;\n  }\n\n  SharedMem<uint8_t*>
        bytecode;\n  size_t numBytes;\n  if (!args[0].isObject() ||\n      !IsBufferSource(&args[0].toObject(),
        &bytecode, &numBytes)) {\n    RootedObject callee(cx, &args.callee());\n    ReportUsageErrorASCII(cx,
        callee, \"Argument must be a buffer source\");\n    return false;\n  }\n\n
        \ wasm::Bytes serialized;\n  if (!CompileAndSerializeInSeparateProcess(cx,
        bytecode.unwrap(), numBytes,\n                                            &serialized))
        {\n    if (!cx->isExceptionPending()) {\n      JS_ReportErrorASCII(cx, \"creating
        and executing child process\");\n    }\n    return false;\n  }\n\n  RootedObject
        module(cx);\n  if (!wasm::DeserializeModule(cx, serialized, &module)) {\n
        \   return false;\n  }\n\n  args.rval().setObject(*module);\n  return true;\n}\n#endif
        \ // __wasi__\n\nstatic bool DecompileFunction(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        < 1 || !args[0].isObject() ||\n      !args[0].toObject().is<JSFunction>())
        {\n    args.rval().setUndefined();\n    return true;\n  }\n  RootedFunction
        fun(cx, &args[0].toObject().as<JSFunction>());\n  JSString* result = JS_DecompileFunction(cx,
        fun);\n  if (!result) {\n    return false;\n  }\n  args.rval().setString(result);\n
        \ return true;\n}\n\nstatic bool DecompileThisScript(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  NonBuiltinScriptFrameIter
        iter(cx);\n  if (iter.done()) {\n    args.rval().setString(cx->runtime()->emptyString);\n
        \   return true;\n  }\n\n  {\n    JSAutoRealm ar(cx, iter.script());\n\n    RootedScript
        script(cx, iter.script());\n    JSString* result = JS_DecompileScript(cx,
        script);\n    if (!result) {\n      return false;\n    }\n\n    args.rval().setString(result);\n
        \ }\n\n  return JS_WrapValue(cx, args.rval());\n}\n\nstatic bool ValueToSource(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ JSString* str = ValueToSource(cx, args.get(0));\n  if (!str) {\n    return
        false;\n  }\n\n  args.rval().setString(str);\n  return true;\n}\n\nstatic
        bool ThisFilename(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  JS::AutoFilename filename;\n  if (!DescribeScriptedCaller(cx,
        &filename) || !filename.get()) {\n    args.rval().setString(cx->runtime()->emptyString);\n
        \   return true;\n  }\n\n  JSString* str = NewStringCopyUTF8(cx, filename.get());\n
        \ if (!str) {\n    return false;\n  }\n\n  args.rval().setString(str);\n  return
        true;\n}\n\nstatic bool WrapWithProto(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  Value obj = args.get(0);\n
        \ Value proto = args.get(1);\n  if (!obj.isObject() || !proto.isObjectOrNull())
        {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"wrapWithProto\");\n    return false;\n  }\n\n  // Disallow constructing
        (deeply) nested wrapper chains, to avoid running\n  // out of stack space
        in isCallable/isConstructor. See bug 1126105.\n  if (IsWrapper(&obj.toObject()))
        {\n    JS_ReportErrorASCII(cx, \"wrapWithProto cannot wrap a wrapper\");\n
        \   return false;\n  }\n\n  WrapperOptions options(cx);\n  options.setProto(proto.toObjectOrNull());\n
        \ JSObject* wrapped = Wrapper::New(cx, &obj.toObject(),\n                                   &Wrapper::singletonWithPrototype,
        options);\n  if (!wrapped) {\n    return false;\n  }\n\n  args.rval().setObject(*wrapped);\n
        \ return true;\n}\n\nstatic bool NewGlobal(JSContext* cx, unsigned argc, Value*
        vp) {\n  JS::RealmOptions options;\n  JS::RealmCreationOptions& creationOptions
        = options.creationOptions();\n  JS::RealmBehaviors& behaviors = options.behaviors();\n
        \ ShellGlobalKind kind = ShellGlobalKind::WindowProxy;\n  bool immutablePrototype
        = true;\n\n  SetStandardRealmOptions(options);\n\n  // Default to creating
        the global in the current compartment unless\n  // --more-compartments is
        used.\n  if (defaultToSameCompartment) {\n    creationOptions.setExistingCompartment(cx->global());\n
        \ } else {\n    creationOptions.setNewCompartmentAndZone();\n  }\n\n  JS::AutoHoldPrincipals
        principals(cx);\n\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        == 1 && args[0].isObject()) {\n    RootedObject opts(cx, &args[0].toObject());\n
        \   RootedValue v(cx);\n\n    if (!JS_GetProperty(cx, opts, \"invisibleToDebugger\",
        &v)) {\n      return false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setInvisibleToDebugger(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"sameZoneAs\", &v)) {\n      return
        false;\n    }\n    if (v.isObject()) {\n      creationOptions.setNewCompartmentInExistingZone(\n
        \         UncheckedUnwrap(&v.toObject()));\n    }\n\n    if (!JS_GetProperty(cx,
        opts, \"sameCompartmentAs\", &v)) {\n      return false;\n    }\n    if (v.isObject())
        {\n      creationOptions.setExistingCompartment(UncheckedUnwrap(&v.toObject()));\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"newCompartment\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean() && v.toBoolean()) {\n      creationOptions.setNewCompartmentAndZone();\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"discardSource\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      behaviors.setDiscardSource(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"useWindowProxy\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      kind = v.toBoolean() ? ShellGlobalKind::WindowProxy\n
        \                          : ShellGlobalKind::GlobalObject;\n    }\n\n    if
        (!JS_GetProperty(cx, opts, \"immutablePrototype\", &v)) {\n      return false;\n
        \   }\n    if (v.isBoolean()) {\n      immutablePrototype = v.toBoolean();\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"systemPrincipal\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      principals.reset(&ShellPrincipals::fullyTrusted);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"principal\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      uint32_t bits;\n      if
        (!ToUint32(cx, v, &bits)) {\n        return false;\n      }\n      JSPrincipals*
        newPrincipals = cx->new_<ShellPrincipals>(bits);\n      if (!newPrincipals)
        {\n        return false;\n      }\n      principals.reset(newPrincipals);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"enableCoopAndCoep\", &v)) {\n
        \     return false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setCoopAndCoepEnabled(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"freezeBuiltins\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setFreezeBuiltins(v.toBoolean());\n
        \   }\n\n    // On the web, the SharedArrayBuffer constructor is not installed
        as a\n    // global property in pages that aren't isolated in a separate process
        (and\n    // thus can't allow the structured cloning of shared memory).  Specify
        false\n    // for this option to reproduce this behavior.\n    if (!JS_GetProperty(cx,
        opts, \"defineSharedArrayBufferConstructor\", &v)) {\n      return false;\n
        \   }\n    if (v.isBoolean()) {\n      creationOptions.setDefineSharedArrayBufferConstructor(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"shouldResistFingerprinting\",
        &v)) {\n      return false;\n    }\n    if (v.isBoolean()) {\n      behaviors.setShouldResistFingerprinting(v.toBoolean());\n
        \   }\n  }\n\n  if (!CheckRealmOptions(cx, options, principals.get())) {\n
        \   return false;\n  }\n\n  RootedObject global(cx, NewGlobalObject(cx, options,
        principals.get(), kind,\n                                          immutablePrototype));\n
        \ if (!global) {\n    return false;\n  }\n\n  RootedObject wrapped(cx, ToWindowProxyIfWindow(global));\n
        \ if (!JS_WrapObject(cx, &wrapped)) {\n    return false;\n  }\n\n  args.rval().setObject(*wrapped);\n
        \ return true;\n}\n\nstatic bool NukeAllCCWs(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n
        \                             JSSMSG_INVALID_ARGS, \"nukeAllCCWs\");\n    return
        false;\n  }\n\n  NukeCrossCompartmentWrappers(cx, AllCompartments(), cx->realm(),\n
        \                              NukeWindowReferences, NukeAllReferences);\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool RecomputeWrappers(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() > 2) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS, \"recomputeWrappers\");\n
        \   return false;\n  }\n\n  JS::Compartment* sourceComp = nullptr;\n  if (args.get(0).isObject())
        {\n    sourceComp = JS::GetCompartment(UncheckedUnwrap(&args[0].toObject()));\n
        \ }\n\n  JS::Compartment* targetComp = nullptr;\n  if (args.get(1).isObject())
        {\n    targetComp = JS::GetCompartment(UncheckedUnwrap(&args[1].toObject()));\n
        \ }\n\n  struct SingleOrAllCompartments final : public CompartmentFilter {\n
        \   JS::Compartment* comp;\n    explicit SingleOrAllCompartments(JS::Compartment*
        c) : comp(c) {}\n    virtual bool match(JS::Compartment* c) const override
        {\n      return !comp || comp == c;\n    }\n  };\n\n  if (!js::RecomputeWrappers(cx,
        SingleOrAllCompartments(sourceComp),\n                             SingleOrAllCompartments(targetComp)))
        {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool DumpObjectWrappers(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  bool printedHeader = false;\n  for (ZonesIter
        zone(cx->runtime(), WithAtoms); !zone.done(); zone.next()) {\n    bool printedZoneInfo
        = false;\n    for (CompartmentsInZoneIter comp(zone); !comp.done(); comp.next())
        {\n      bool printedCompartmentInfo = false;\n      for (Compartment::ObjectWrapperEnum
        e(comp); !e.empty(); e.popFront()) {\n        JSObject* wrapper = e.front().value().unbarrieredGet();\n
        \       JSObject* wrapped = e.front().key();\n        if (!printedHeader)
        {\n          fprintf(stderr, \"Cross-compartment object wrappers:\\n\");\n
        \         printedHeader = true;\n        }\n        if (!printedZoneInfo)
        {\n          fprintf(stderr, \"  Zone %p:\\n\", zone.get());\n          printedZoneInfo
        = true;\n        }\n        if (!printedCompartmentInfo) {\n          fprintf(stderr,
        \"    Compartment %p:\\n\", comp.get());\n          printedCompartmentInfo
        = true;\n        }\n        fprintf(stderr,\n                \"      Object
        wrapper %p -> %p in zone %p compartment %p\\n\",\n                wrapper,
        wrapped, wrapped->zone(), wrapped->compartment());\n      }\n    }\n  }\n\n
        \ if (!printedHeader) {\n    fprintf(stderr, \"No cross-compartment object
        wrappers.\\n\");\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool GetMaxArgs(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  args.rval().setInt32(ARGS_LENGTH_MAX);\n  return
        true;\n}\n\nstatic bool IsHTMLDDA_Call(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  // These are the required
        conditions under which this object may be called\n  // by test262 tests, and
        the required behavior under those conditions.\n  if (args.length() == 0 ||\n
        \     (args[0].isString() && args[0].toString()->length() == 0)) {\n    args.rval().setNull();\n
        \   return true;\n  }\n\n  JS_ReportErrorASCII(\n      cx, \"IsHTMLDDA object
        is being called in an impermissible manner\");\n  return false;\n}\n\nstatic
        bool CreateIsHTMLDDA(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  static const JSClassOps classOps = {\n
        \     nullptr,         // addProperty\n      nullptr,         // delProperty\n
        \     nullptr,         // enumerate\n      nullptr,         // newEnumerate\n
        \     nullptr,         // resolve\n      nullptr,         // mayResolve\n
        \     nullptr,         // finalize\n      IsHTMLDDA_Call,  // call\n      nullptr,
        \        // construct\n      nullptr,         // trace\n  };\n\n  static const
        JSClass cls = {\n      \"IsHTMLDDA\",\n      JSCLASS_EMULATES_UNDEFINED,\n
        \     &classOps,\n  };\n\n  JSObject* obj = JS_NewObject(cx, &cls);\n  if
        (!obj) {\n    return false;\n  }\n  args.rval().setObject(*obj);\n  return
        true;\n}\n\nstatic bool GetSelfHostedValue(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 1 || !args[0].isString()) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS, \"getSelfHostedValue\");\n
        \   return false;\n  }\n  Rooted<JSAtom*> srcAtom(cx, ToAtom<CanGC>(cx, args[0]));\n
        \ if (!srcAtom) {\n    return false;\n  }\n  Rooted<PropertyName*> srcName(cx,
        srcAtom->asPropertyName());\n  return GlobalObject::getIntrinsicValue(cx,
        cx->global(), srcName,\n                                         args.rval());\n}\n\nclass
        ShellSourceHook : public SourceHook {\n  // The function we should call to
        lazily retrieve source code.\n  PersistentRootedFunction fun;\n\n public:\n
        \ ShellSourceHook(JSContext* cx, JSFunction& fun) : fun(cx, &fun) {}\n\n  bool
        load(JSContext* cx, const char* filename, char16_t** twoByteSource,\n            char**
        utf8Source, size_t* length) override {\n    MOZ_ASSERT((twoByteSource != nullptr)
        != (utf8Source != nullptr),\n               \"must be called requesting only
        one of UTF-8 or UTF-16 source\");\n\n    RootedString str(cx);\n    if (filename)
        {\n      str = NewStringCopyUTF8(cx, filename);\n      if (!str) {\n        return
        false;\n      }\n    } else {\n      str = JS_GetEmptyString(cx);\n    }\n
        \   RootedValue filenameValue(cx, StringValue(str));\n\n    RootedValue result(cx);\n
        \   if (!Call(cx, UndefinedHandleValue, fun, HandleValueArray(filenameValue),\n
        \             &result)) {\n      return false;\n    }\n\n    str = JS::ToString(cx,
        result);\n    if (!str) {\n      return false;\n    }\n\n    Rooted<JSLinearString*>
        linear(cx, str->ensureLinear(cx));\n    if (!linear) {\n      return false;\n
        \   }\n\n    if (twoByteSource) {\n      *length = JS_GetStringLength(linear);\n\n
        \     *twoByteSource = cx->pod_malloc<char16_t>(*length);\n      if (!*twoByteSource)
        {\n        return false;\n      }\n\n      CopyChars(*twoByteSource, *linear);\n
        \   } else {\n      MOZ_ASSERT(utf8Source != nullptr);\n\n      *length =
        JS::GetDeflatedUTF8StringLength(linear);\n\n      *utf8Source = cx->pod_malloc<char>(*length);\n
        \     if (!*utf8Source) {\n        return false;\n      }\n\n      mozilla::DebugOnly<size_t>
        dstLen = JS::DeflateStringToUTF8Buffer(\n          linear, mozilla::Span(*utf8Source,
        *length));\n      MOZ_ASSERT(dstLen == *length);\n    }\n\n    return true;\n
        \ }\n};\n\nstatic bool WithSourceHook(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx,
        &args.callee());\n\n  if (args.length() != 2) {\n    ReportUsageErrorASCII(cx,
        callee, \"Wrong number of arguments.\");\n    return false;\n  }\n\n  if (!args[0].isObject()
        || !args[0].toObject().is<JSFunction>() ||\n      !args[1].isObject() || !args[1].toObject().is<JSFunction>())
        {\n    ReportUsageErrorASCII(cx, callee,\n                          \"First
        and second arguments must be functions.\");\n    return false;\n  }\n\n  mozilla::UniquePtr<ShellSourceHook>
        hook =\n      mozilla::MakeUnique<ShellSourceHook>(cx,\n                                           args[0].toObject().as<JSFunction>());\n
        \ if (!hook) {\n    return false;\n  }\n\n  mozilla::UniquePtr<SourceHook>
        savedHook = js::ForgetSourceHook(cx);\n  js::SetSourceHook(cx, std::move(hook));\n\n
        \ RootedObject fun(cx, &args[1].toObject());\n  bool result = Call(cx, UndefinedHandleValue,
        fun,\n                     JS::HandleValueArray::empty(), args.rval());\n
        \ js::SetSourceHook(cx, std::move(savedHook));\n  return result;\n}\n\nstatic
        void PrintProfilerEvents_Callback(const char* msg, const char* details) {\n
        \ fprintf(stderr, \"PROFILER EVENT: %s %s\\n\", msg, details);\n}\n\nstatic
        bool PrintProfilerEvents(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (cx->runtime()->geckoProfiler().enabled())
        {\n    js::RegisterContextProfilingEventMarker(cx, &PrintProfilerEvents_Callback);\n
        \ }\n  args.rval().setUndefined();\n  return true;\n}\n\n#ifdef SINGLESTEP_PROFILING\nstatic
        void SingleStepCallback(void* arg, jit::Simulator* sim, void* pc) {\n  JSContext*
        cx = reinterpret_cast<JSContext*>(arg);\n\n  // If profiling is not enabled,
        don't do anything.\n  if (!cx->runtime()->geckoProfiler().enabled()) {\n    return;\n
        \ }\n\n  JS::ProfilingFrameIterator::RegisterState state;\n  state.pc = pc;\n#
        \ if defined(JS_SIMULATOR_ARM)\n  state.sp = (void*)sim->get_register(jit::Simulator::sp);\n
        \ state.lr = (void*)sim->get_register(jit::Simulator::lr);\n  state.fp = (void*)sim->get_register(jit::Simulator::fp);\n#
        \ elif defined(JS_SIMULATOR_MIPS64) || defined(JS_SIMULATOR_MIPS32)\n  state.sp
        = (void*)sim->getRegister(jit::Simulator::sp);\n  state.lr = (void*)sim->getRegister(jit::Simulator::ra);\n
        \ state.fp = (void*)sim->getRegister(jit::Simulator::fp);\n#  elif defined(JS_SIMULATOR_LOONG64)\n
        \ state.sp = (void*)sim->getRegister(jit::Simulator::sp);\n  state.lr = (void*)sim->getRegister(jit::Simulator::ra);\n
        \ state.fp = (void*)sim->getRegister(jit::Simulator::fp);\n#  else\n#    error
        \"NYI: Single-step profiling support\"\n#  endif\n\n  mozilla::DebugOnly<void*>
        lastStackAddress = nullptr;\n  StackChars stack;\n  uint32_t frameNo = 0;\n
        \ AutoEnterOOMUnsafeRegion oomUnsafe;\n  for (JS::ProfilingFrameIterator i(cx,
        state); !i.done(); ++i) {\n    MOZ_ASSERT(i.stackAddress() != nullptr);\n
        \   MOZ_ASSERT(lastStackAddress <= i.stackAddress());\n    lastStackAddress
        = i.stackAddress();\n    JS::ProfilingFrameIterator::Frame frames[16];\n    uint32_t
        nframes = i.extractStack(frames, 0, 16);\n    for (uint32_t i = 0; i < nframes;
        i++) {\n      // Assert endStackAddress never exceeds sp (bug 1782188).\n
        \     MOZ_ASSERT(frames[i].endStackAddress >= state.sp);\n      if (frameNo
        > 0) {\n        if (!stack.append(\",\", 1)) {\n          oomUnsafe.crash(\"stack.append\");\n
        \       }\n      }\n      if (!stack.append(frames[i].label, strlen(frames[i].label)))
        {\n        oomUnsafe.crash(\"stack.append\");\n      }\n      frameNo++;\n
        \   }\n  }\n\n  ShellContext* sc = GetShellContext(cx);\n\n  // Only append
        the stack if it differs from the last stack.\n  if (sc->stacks.empty() ||
        sc->stacks.back().length() != stack.length() ||\n      !ArrayEqual(sc->stacks.back().begin(),
        stack.begin(), stack.length())) {\n    if (!sc->stacks.append(std::move(stack)))
        {\n      oomUnsafe.crash(\"stacks.append\");\n    }\n  }\n}\n#endif\n\nstatic
        bool EnableSingleStepProfiling(JSContext* cx, unsigned argc, Value* vp) {\n#ifdef
        SINGLESTEP_PROFILING\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  jit::Simulator*
        sim = cx->simulator();\n  sim->enable_single_stepping(SingleStepCallback,
        cx);\n\n  args.rval().setUndefined();\n  return true;\n#else\n  JS_ReportErrorASCII(cx,
        \"single-step profiling not enabled on this platform\");\n  return false;\n#endif\n}\n\nstatic
        bool DisableSingleStepProfiling(JSContext* cx, unsigned argc,\n                                       Value*
        vp) {\n#ifdef SINGLESTEP_PROFILING\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  jit::Simulator* sim = cx->simulator();\n  sim->disable_single_stepping();\n\n
        \ ShellContext* sc = GetShellContext(cx);\n\n  RootedValueVector elems(cx);\n
        \ for (size_t i = 0; i < sc->stacks.length(); i++) {\n    JSString* stack
        =\n        JS_NewUCStringCopyN(cx, sc->stacks[i].begin(), sc->stacks[i].length());\n
        \   if (!stack) {\n      return false;\n    }\n    if (!elems.append(StringValue(stack)))
        {\n      return false;\n    }\n  }\n\n  JSObject* array = JS::NewArrayObject(cx,
        elems);\n  if (!array) {\n    return false;\n  }\n\n  sc->stacks.clear();\n
        \ args.rval().setObject(*array);\n  return true;\n#else\n  JS_ReportErrorASCII(cx,
        \"single-step profiling not enabled on this platform\");\n  return false;\n#endif\n}\n\nstatic
        bool IsLatin1(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  bool isLatin1 =\n      args.get(0).isString()
        && args[0].toString()->hasLatin1Chars();\n  args.rval().setBoolean(isLatin1);\n
        \ return true;\n}\n\nstatic bool EnableGeckoProfiling(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!EnsureGeckoProfilingStackInstalled(cx,
        GetShellContext(cx))) {\n    return false;\n  }\n\n  cx->runtime()->geckoProfiler().enableSlowAssertions(false);\n
        \ cx->runtime()->geckoProfiler().enable(true);\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool EnableGeckoProfilingWithSlowAssertions(JSContext*
        cx, unsigned argc,\n                                                   Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  args.rval().setUndefined();\n\n
        \ if (cx->runtime()->geckoProfiler().enabled()) {\n    // If profiling already
        enabled with slow assertions disabled,\n    // this is a no-op.\n    if (cx->runtime()->geckoProfiler().slowAssertionsEnabled())
        {\n      return true;\n    }\n\n    // Slow assertions are off.  Disable profiling
        before re-enabling\n    // with slow assertions on.\n    cx->runtime()->geckoProfiler().enable(false);\n
        \ }\n\n  if (!EnsureGeckoProfilingStackInstalled(cx, GetShellContext(cx)))
        {\n    return false;\n  }\n\n  cx->runtime()->geckoProfiler().enableSlowAssertions(true);\n
        \ cx->runtime()->geckoProfiler().enable(true);\n\n  return true;\n}\n\nstatic
        bool DisableGeckoProfiling(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  args.rval().setUndefined();\n\n  if (!cx->runtime()->geckoProfiler().enabled())
        {\n    return true;\n  }\n\n  cx->runtime()->geckoProfiler().enable(false);\n
        \ return true;\n}\n\n// Global mailbox that is used to communicate a shareable
        object value from one\n// worker to another.\n//\n// These object types are
        shareable:\n//\n//   - SharedArrayBuffer\n//   - WasmMemoryObject (when constructed
        with shared:true)\n//   - WasmModuleObject\n//\n// For the SharedArrayBuffer
        and WasmMemoryObject we transmit the underlying\n// SharedArrayRawBuffer (\"SARB\").
        For the WasmModuleObject we transmit the\n// underlying JS::WasmModule.  The
        transmitted types are refcounted.  When they\n// are in the mailbox their
        reference counts are at least 1, accounting for the\n// reference from the
        mailbox.\n//\n// The lock guards the mailbox variable and prevents a race
        where two workers\n// try to set the mailbox at the same time to replace an
        object that is only\n// referenced from the mailbox: the workers will both
        decrement the reference\n// count on the old object, and one of those decrements
        will be on a garbage\n// object.  We could implement this with atomics and
        a CAS loop but it's not\n// worth the bother.\n//\n// Note that if a thread
        reads the mailbox repeatedly it will get distinct\n// objects on each read.
        \ The alternatives are to cache created objects locally,\n// but this retains
        storage we don't need to retain, or to somehow clear the\n// mailbox locally,
        but this creates a coordination headache.  Buyer beware.\n\nenum class MailboxTag
        {\n  Empty,\n  SharedArrayBuffer,\n  WasmMemory,\n  WasmModule,\n  Number,\n};\n\nstruct
        SharedObjectMailbox {\n  union Value {\n    struct {\n      SharedArrayRawBuffer*
        buffer;\n      size_t length;\n      bool isHugeMemory;  // For a WasmMemory
        tag, otherwise false\n    } sarb;\n    JS::WasmModule* module;\n    double
        number;\n\n    Value() : number(0.0) {}\n  };\n\n  MailboxTag tag = MailboxTag::Empty;\n
        \ Value val;\n};\n\ntypedef ExclusiveData<SharedObjectMailbox> SOMailbox;\n\n//
        Never null after successful initialization.\nstatic SOMailbox* sharedObjectMailbox;\n\nstatic
        bool InitSharedObjectMailbox() {\n  sharedObjectMailbox = js_new<SOMailbox>(mutexid::ShellObjectMailbox);\n
        \ return sharedObjectMailbox != nullptr;\n}\n\nstatic void DestructSharedObjectMailbox()
        {\n  // All workers need to have terminated at this point.\n\n  {\n    auto
        mbx = sharedObjectMailbox->lock();\n    switch (mbx->tag) {\n      case MailboxTag::Empty:\n
        \     case MailboxTag::Number:\n        break;\n      case MailboxTag::SharedArrayBuffer:\n
        \     case MailboxTag::WasmMemory:\n        mbx->val.sarb.buffer->dropReference();\n
        \       break;\n      case MailboxTag::WasmModule:\n        mbx->val.module->Release();\n
        \       break;\n      default:\n        MOZ_CRASH();\n    }\n  }\n\n  js_delete(sharedObjectMailbox);\n
        \ sharedObjectMailbox = nullptr;\n}\n\nstatic bool GetSharedObject(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ RootedObject newObj(cx);\n\n  {\n    auto mbx = sharedObjectMailbox->lock();\n
        \   switch (mbx->tag) {\n      case MailboxTag::Empty: {\n        break;\n
        \     }\n      case MailboxTag::Number: {\n        args.rval().setNumber(mbx->val.number);\n
        \       return true;\n      }\n      case MailboxTag::SharedArrayBuffer:\n
        \     case MailboxTag::WasmMemory: {\n        // Flag was set in the sender;
        ensure it is set in the receiver.\n        MOZ_ASSERT(\n            cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled());\n\n
        \       // The protocol for creating a SAB requires the refcount to be\n        //
        incremented prior to the SAB creation.\n\n        SharedArrayRawBuffer* buf
        = mbx->val.sarb.buffer;\n        size_t length = mbx->val.sarb.length;\n        if
        (!buf->addReference()) {\n          JS_ReportErrorNumberASCII(cx, GetErrorMessage,
        nullptr,\n                                    JSMSG_SC_SAB_REFCNT_OFLO);\n
        \         return false;\n        }\n\n        // If the allocation fails we
        must decrement the refcount before\n        // returning.\n\n        Rooted<ArrayBufferObjectMaybeShared*>
        maybesab(\n            cx, SharedArrayBufferObject::New(cx, buf, length));\n
        \       if (!maybesab) {\n          buf->dropReference();\n          return
        false;\n        }\n\n        // At this point the SAB was created successfully
        and it owns the\n        // refcount-increase on the buffer that we performed
        above.  So even\n        // if we fail to allocate along any path below we
        must not decrement\n        // the refcount; the garbage collector must be
        allowed to handle\n        // that via finalization of the orphaned SAB object.\n\n
        \       if (mbx->tag == MailboxTag::SharedArrayBuffer) {\n          newObj
        = maybesab;\n        } else {\n          if (!GlobalObject::ensureConstructor(cx,
        cx->global(),\n                                               JSProto_WebAssembly))
        {\n            return false;\n          }\n          RootedObject proto(cx,\n
        \                            &cx->global()->getPrototype(JSProto_WasmMemory));\n
        \         newObj = WasmMemoryObject::create(cx, maybesab,\n                                            mbx->val.sarb.isHugeMemory,
        proto);\n          MOZ_ASSERT_IF(newObj, newObj->as<WasmMemoryObject>().isShared());\n
        \         if (!newObj) {\n            return false;\n          }\n        }\n\n
        \       break;\n      }\n      case MailboxTag::WasmModule: {\n        //
        Flag was set in the sender; ensure it is set in the receiver.\n        MOZ_ASSERT(\n
        \           cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled());\n\n
        \       if (!GlobalObject::ensureConstructor(cx, cx->global(),\n                                             JSProto_WebAssembly))
        {\n          return false;\n        }\n\n        // WasmModuleObject::create()
        increments the refcount on the module\n        // and signals an error and
        returns null if that fails.\n        newObj = mbx->val.module->createObject(cx);\n
        \       if (!newObj) {\n          return false;\n        }\n        break;\n
        \     }\n      default: {\n        MOZ_CRASH();\n      }\n    }\n  }\n\n  args.rval().setObjectOrNull(newObj);\n
        \ return true;\n}\n\nstatic bool SetSharedObject(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  MailboxTag
        tag = MailboxTag::Empty;\n  SharedObjectMailbox::Value value;\n\n  // Increase
        refcounts when we obtain the value to avoid operating on dead\n  // storage
        during self-assignment.\n\n  if (args.get(0).isObject()) {\n    RootedObject
        obj(cx, &args[0].toObject());\n    if (obj->is<SharedArrayBufferObject>())
        {\n      Rooted<SharedArrayBufferObject*> sab(cx,\n                                           &obj->as<SharedArrayBufferObject>());\n
        \     tag = MailboxTag::SharedArrayBuffer;\n      value.sarb.buffer = sab->rawBufferObject();\n
        \     value.sarb.length = sab->byteLength();\n      value.sarb.isHugeMemory
        = false;\n      if (!value.sarb.buffer->addReference()) {\n        JS_ReportErrorASCII(cx,\n
        \                           \"Reference count overflow on SharedArrayBuffer\");\n
        \       return false;\n      }\n    } else if (obj->is<WasmMemoryObject>())
        {\n      // Here we must transmit sab.byteLength() as the length; the SARB
        has its\n      // own notion of the length which may be greater, and that's
        fine.\n      if (obj->as<WasmMemoryObject>().isShared()) {\n        Rooted<SharedArrayBufferObject*>
        sab(\n            cx, &obj->as<WasmMemoryObject>()\n                     .buffer()\n
        \                    .as<SharedArrayBufferObject>());\n        tag = MailboxTag::WasmMemory;\n
        \       value.sarb.buffer = sab->rawBufferObject();\n        value.sarb.length
        = sab->byteLength();\n        value.sarb.isHugeMemory = obj->as<WasmMemoryObject>().isHuge();\n
        \       if (!value.sarb.buffer->addReference()) {\n          JS_ReportErrorASCII(cx,\n
        \                             \"Reference count overflow on SharedArrayBuffer\");\n
        \         return false;\n        }\n      } else {\n        JS_ReportErrorASCII(cx,
        \"Invalid argument to SetSharedObject\");\n        return false;\n      }\n
        \   } else if (JS::IsWasmModuleObject(obj)) {\n      tag = MailboxTag::WasmModule;\n
        \     value.module = JS::GetWasmModule(obj).forget().take();\n    } else {\n
        \     JS_ReportErrorASCII(cx, \"Invalid argument to SetSharedObject\");\n
        \     return false;\n    }\n  } else if (args.get(0).isNumber()) {\n    tag
        = MailboxTag::Number;\n    value.number = args.get(0).toNumber();\n    //
        Nothing\n  } else if (args.get(0).isNullOrUndefined()) {\n    // Nothing\n
        \ } else {\n    JS_ReportErrorASCII(cx, \"Invalid argument to SetSharedObject\");\n
        \   return false;\n  }\n\n  {\n    auto mbx = sharedObjectMailbox->lock();\n\n
        \   switch (mbx->tag) {\n      case MailboxTag::Empty:\n      case MailboxTag::Number:\n
        \       break;\n      case MailboxTag::SharedArrayBuffer:\n      case MailboxTag::WasmMemory:\n
        \       mbx->val.sarb.buffer->dropReference();\n        break;\n      case
        MailboxTag::WasmModule:\n        mbx->val.module->Release();\n        break;\n
        \     default:\n        MOZ_CRASH();\n    }\n\n    mbx->tag = tag;\n    mbx->val
        = value;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\ntypedef
        Vector<uint8_t, 0, SystemAllocPolicy> Uint8Vector;\n\nclass StreamCacheEntry
        : public AtomicRefCounted<StreamCacheEntry>,\n                         public
        JS::OptimizedEncodingListener {\n  typedef AtomicRefCounted<StreamCacheEntry>
        AtomicBase;\n\n  Uint8Vector bytes_;\n  ExclusiveData<Uint8Vector> optimized_;\n\n
        public:\n  explicit StreamCacheEntry(Uint8Vector&& original)\n      : bytes_(std::move(original)),\n
        \       optimized_(mutexid::ShellStreamCacheEntryState) {}\n\n  // Implement
        JS::OptimizedEncodingListener:\n\n  MozExternalRefCountType MOZ_XPCOM_ABI
        AddRef() override {\n    AtomicBase::AddRef();\n    return 1;  // unused\n
        \ }\n  MozExternalRefCountType MOZ_XPCOM_ABI Release() override {\n    AtomicBase::Release();\n
        \   return 0;  // unused\n  }\n\n  const Uint8Vector& bytes() const { return
        bytes_; }\n\n  void storeOptimizedEncoding(const uint8_t* srcBytes,\n                              size_t
        srcLength) override {\n    MOZ_ASSERT(srcLength > 0);\n\n    // Tolerate races
        since a single StreamCacheEntry object can be used as\n    // the source of
        multiple streaming compilations.\n    auto dstBytes = optimized_.lock();\n
        \   if (dstBytes->length() > 0) {\n      return;\n    }\n\n    if (!dstBytes->resize(srcLength))
        {\n      return;\n    }\n    memcpy(dstBytes->begin(), srcBytes, srcLength);\n
        \ }\n\n  bool hasOptimizedEncoding() const { return !optimized_.lock()->empty();
        }\n  const Uint8Vector& optimizedEncoding() const {\n    return optimized_.lock().get();\n
        \ }\n};\n\ntypedef RefPtr<StreamCacheEntry> StreamCacheEntryPtr;\n\nclass
        StreamCacheEntryObject : public NativeObject {\n  static const unsigned CACHE_ENTRY_SLOT
        = 0;\n  static const JSClassOps classOps_;\n  static const JSPropertySpec
        properties_;\n\n  static void finalize(JS::GCContext* gcx, JSObject* obj)
        {\n    obj->as<StreamCacheEntryObject>().cache().Release();\n  }\n\n  static
        bool cachedGetter(JSContext* cx, unsigned argc, Value* vp) {\n    CallArgs
        args = CallArgsFromVp(argc, vp);\n    if (!args.thisv().isObject() ||\n        !args.thisv().toObject().is<StreamCacheEntryObject>())
        {\n      return false;\n    }\n\n    StreamCacheEntryObject& obj =\n        args.thisv().toObject().as<StreamCacheEntryObject>();\n
        \   args.rval().setBoolean(obj.cache().hasOptimizedEncoding());\n    return
        true;\n  }\n  static bool getBuffer(JSContext* cx, unsigned argc, Value* vp)
        {\n    CallArgs args = CallArgsFromVp(argc, vp);\n    if (!args.thisv().isObject()
        ||\n        !args.thisv().toObject().is<StreamCacheEntryObject>()) {\n      return
        false;\n    }\n\n    auto& bytes =\n        args.thisv().toObject().as<StreamCacheEntryObject>().cache().bytes();\n
        \   RootedArrayBufferObject buffer(\n        cx, ArrayBufferObject::createZeroed(cx,
        bytes.length()));\n    if (!buffer) {\n      return false;\n    }\n\n    memcpy(buffer->dataPointer(),
        bytes.begin(), bytes.length());\n\n    args.rval().setObject(*buffer);\n    return
        true;\n  }\n\n public:\n  static const unsigned RESERVED_SLOTS = 1;\n  static
        const JSClass class_;\n  static const JSPropertySpec properties[];\n\n  static
        bool construct(JSContext* cx, unsigned argc, Value* vp) {\n    CallArgs args
        = CallArgsFromVp(argc, vp);\n    if (!args.requireAtLeast(cx, \"streamCacheEntry\",
        1)) {\n      return false;\n    }\n\n    SharedMem<uint8_t*> ptr;\n    size_t
        numBytes;\n    if (!args[0].isObject() ||\n        !IsBufferSource(&args[0].toObject(),
        &ptr, &numBytes)) {\n      RootedObject callee(cx, &args.callee());\n      ReportUsageErrorASCII(cx,
        callee, \"Argument must be an ArrayBuffer\");\n      return false;\n    }\n\n
        \   Uint8Vector bytes;\n    if (!bytes.resize(numBytes)) {\n      return false;\n
        \   }\n\n    memcpy(bytes.begin(), ptr.unwrap(), numBytes);\n\n    RefPtr<StreamCacheEntry>
        cache =\n        cx->new_<StreamCacheEntry>(std::move(bytes));\n    if (!cache)
        {\n      return false;\n    }\n\n    Rooted<NativeObject*> obj(\n        cx,
        NewObjectWithGivenProto<StreamCacheEntryObject>(cx, nullptr));\n    if (!obj)
        {\n      return false;\n    }\n    obj->initReservedSlot(CACHE_ENTRY_SLOT,\n
        \                         PrivateValue(cache.forget().take()));\n\n    if
        (!JS_DefineProperty(cx, obj, \"cached\", cachedGetter, nullptr, 0)) {\n      return
        false;\n    }\n    if (!JS_DefineFunction(cx, obj, \"getBuffer\", getBuffer,
        0, 0)) {\n      return false;\n    }\n\n    args.rval().setObject(*obj);\n
        \   return true;\n  }\n\n  StreamCacheEntry& cache() const {\n    return *(StreamCacheEntry*)getReservedSlot(CACHE_ENTRY_SLOT).toPrivate();\n
        \ }\n};\n\nconst JSClassOps StreamCacheEntryObject::classOps_ = {\n    nullptr,
        \                          // addProperty\n    nullptr,                           //
        delProperty\n    nullptr,                           // enumerate\n    nullptr,
        \                          // newEnumerate\n    nullptr,                           //
        resolve\n    nullptr,                           // mayResolve\n    StreamCacheEntryObject::finalize,
        \ // finalize\n    nullptr,                           // call\n    nullptr,
        \                          // construct\n    nullptr,                           //
        trace\n};\n\nconst JSClass StreamCacheEntryObject::class_ = {\n    \"StreamCacheEntryObject\",\n
        \   JSCLASS_HAS_RESERVED_SLOTS(StreamCacheEntryObject::RESERVED_SLOTS) |\n
        \       JSCLASS_BACKGROUND_FINALIZE,\n    &StreamCacheEntryObject::classOps_};\n\nstruct
        BufferStreamJob {\n  Variant<Uint8Vector, StreamCacheEntryPtr> source;\n  Thread
        thread;\n  JS::StreamConsumer* consumer;\n\n  BufferStreamJob(Uint8Vector&&
        source, JS::StreamConsumer* consumer)\n      : source(AsVariant<Uint8Vector>(std::move(source))),
        consumer(consumer) {}\n  BufferStreamJob(StreamCacheEntry& source, JS::StreamConsumer*
        consumer)\n      : source(AsVariant<StreamCacheEntryPtr>(&source)), consumer(consumer)
        {}\n};\n\nstruct BufferStreamState {\n  Vector<UniquePtr<BufferStreamJob>,
        0, SystemAllocPolicy> jobs;\n  size_t delayMillis;\n  size_t chunkSize;\n
        \ bool shutdown;\n\n  BufferStreamState() : delayMillis(1), chunkSize(10),
        shutdown(false) {}\n\n  ~BufferStreamState() { MOZ_ASSERT(jobs.empty()); }\n};\n\nstatic
        ExclusiveWaitableData<BufferStreamState>* bufferStreamState;\n\nstatic void
        BufferStreamMain(BufferStreamJob* job) {\n  const uint8_t* bytes;\n  size_t
        byteLength;\n  JS::OptimizedEncodingListener* listener;\n  if (job->source.is<StreamCacheEntryPtr>())
        {\n    StreamCacheEntry& cache = *job->source.as<StreamCacheEntryPtr>();\n
        \   if (cache.hasOptimizedEncoding()) {\n      const Uint8Vector& optimized
        = cache.optimizedEncoding();\n      job->consumer->consumeOptimizedEncoding(optimized.begin(),\n
        \                                             optimized.length());\n      goto
        done;\n    }\n\n    bytes = cache.bytes().begin();\n    byteLength = cache.bytes().length();\n
        \   listener = &cache;\n  } else {\n    bytes = job->source.as<Uint8Vector>().begin();\n
        \   byteLength = job->source.as<Uint8Vector>().length();\n    listener = nullptr;\n
        \ }\n\n  size_t byteOffset;\n  byteOffset = 0;\n  while (true) {\n    if (byteOffset
        == byteLength) {\n      job->consumer->streamEnd(listener);\n      break;\n
        \   }\n\n    bool shutdown;\n    size_t delayMillis;\n    size_t chunkSize;\n
        \   {\n      auto state = bufferStreamState->lock();\n      shutdown = state->shutdown;\n
        \     delayMillis = state->delayMillis;\n      chunkSize = state->chunkSize;\n
        \   }\n\n    if (shutdown) {\n      job->consumer->streamError(JSMSG_STREAM_CONSUME_ERROR);\n
        \     break;\n    }\n\n    ThisThread::SleepMilliseconds(delayMillis);\n\n
        \   chunkSize = std::min(chunkSize, byteLength - byteOffset);\n\n    if (!job->consumer->consumeChunk(bytes
        + byteOffset, chunkSize)) {\n      break;\n    }\n\n    byteOffset += chunkSize;\n
        \ }\n\ndone:\n  auto state = bufferStreamState->lock();\n  size_t jobIndex
        = 0;\n  while (state->jobs[jobIndex].get() != job) {\n    jobIndex++;\n  }\n
        \ job->thread.detach();  // quiet assert in ~Thread() called by erase().\n
        \ state->jobs.erase(state->jobs.begin() + jobIndex);\n  if (state->jobs.empty())
        {\n    state.notify_all(/* jobs empty */);\n  }\n}\n\nstatic bool ConsumeBufferSource(JSContext*
        cx, JS::HandleObject obj,\n                                JS::MimeType, JS::StreamConsumer*
        consumer) {\n  {\n    RootedValue url(cx);\n    if (!JS_GetProperty(cx, obj,
        \"url\", &url)) {\n      return false;\n    }\n    UniqueChars urlChars;\n
        \   if (url.isString()) {\n      Rooted<JSString*> str(cx, url.toString());\n
        \     urlChars = JS_EncodeStringToUTF8(cx, str);\n      if (!urlChars) {\n
        \       return false;\n      }\n    }\n\n    RootedValue mapUrl(cx);\n    if
        (!JS_GetProperty(cx, obj, \"sourceMappingURL\", &mapUrl)) {\n      return
        false;\n    }\n    UniqueChars mapUrlChars;\n    if (mapUrl.isString()) {\n
        \     Rooted<JSString*> str(cx, mapUrl.toString());\n      mapUrlChars = JS_EncodeStringToUTF8(cx,
        str);\n      if (!mapUrlChars) {\n        return false;\n      }\n    }\n\n
        \   consumer->noteResponseURLs(urlChars.get(), mapUrlChars.get());\n  }\n\n
        \ UniquePtr<BufferStreamJob> job;\n\n  SharedMem<uint8_t*> dataPointer;\n
        \ size_t byteLength;\n  if (IsBufferSource(obj, &dataPointer, &byteLength))
        {\n    Uint8Vector bytes;\n    if (!bytes.resize(byteLength)) {\n      JS_ReportOutOfMemory(cx);\n
        \     return false;\n    }\n\n    memcpy(bytes.begin(), dataPointer.unwrap(),
        byteLength);\n    job = cx->make_unique<BufferStreamJob>(std::move(bytes),
        consumer);\n  } else if (obj->is<StreamCacheEntryObject>()) {\n    job = cx->make_unique<BufferStreamJob>(\n
        \       obj->as<StreamCacheEntryObject>().cache(), consumer);\n  } else {\n
        \   JS_ReportErrorASCII(\n        cx,\n        \"shell streaming consumes
        a buffer source (buffer or view) \"\n        \"or StreamCacheEntryObject\");\n
        \   return false;\n  }\n  if (!job) {\n    return false;\n  }\n\n  BufferStreamJob*
        jobPtr = job.get();\n\n  {\n    auto state = bufferStreamState->lock();\n
        \   MOZ_ASSERT(!state->shutdown);\n    if (!state->jobs.append(std::move(job)))
        {\n      JS_ReportOutOfMemory(cx);\n      return false;\n    }\n  }\n\n  {\n
        \   AutoEnterOOMUnsafeRegion oomUnsafe;\n    if (!jobPtr->thread.init(BufferStreamMain,
        jobPtr)) {\n      oomUnsafe.crash(\"ConsumeBufferSource\");\n    }\n  }\n\n
        \ return true;\n}\n\nstatic void ReportStreamError(JSContext* cx, size_t errorNumber)
        {\n  JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr, errorNumber);\n}\n\nstatic
        bool SetBufferStreamParams(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx, \"setBufferStreamParams\",
        2)) {\n    return false;\n  }\n\n  double delayMillis;\n  if (!ToNumber(cx,
        args[0], &delayMillis)) {\n    return false;\n  }\n\n  double chunkSize;\n
        \ if (!ToNumber(cx, args[1], &chunkSize)) {\n    return false;\n  }\n\n  {\n
        \   auto state = bufferStreamState->lock();\n    state->delayMillis = delayMillis;\n
        \   state->chunkSize = chunkSize;\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic void ShutdownBufferStreams() {\n  auto state =
        bufferStreamState->lock();\n  state->shutdown = true;\n  while (!state->jobs.empty())
        {\n    state.wait(/* jobs empty */);\n  }\n  state->jobs.clearAndFree();\n}\n\nstatic
        bool DumpScopeChain(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (js::SupportDifferentialTesting()) {\n    ReportUsageErrorASCII(\n        cx,
        callee, \"Function not available in differential testing mode.\");\n    return
        false;\n  }\n\n  if (args.length() != 1) {\n    ReportUsageErrorASCII(cx,
        callee, \"Wrong number of arguments\");\n    return false;\n  }\n\n  if (!args[0].isObject()
        ||\n      !(args[0].toObject().is<JSFunction>() ||\n        args[0].toObject().is<ShellModuleObjectWrapper>()))
        {\n    ReportUsageErrorASCII(\n        cx, callee, \"Argument must be an interpreted
        function or a module\");\n    return false;\n  }\n\n  RootedObject obj(cx,
        &args[0].toObject());\n  RootedScript script(cx);\n\n  if (obj->is<JSFunction>())
        {\n    RootedFunction fun(cx, &obj->as<JSFunction>());\n    if (!fun->isInterpreted())
        {\n      ReportUsageErrorASCII(cx, callee,\n                            \"Argument
        must be an interpreted function\");\n      return false;\n    }\n    script
        = JSFunction::getOrCreateScript(cx, fun);\n    if (!script) {\n      return
        false;\n    }\n  } else {\n    script = obj->as<ShellModuleObjectWrapper>().get()->maybeScript();\n
        \   if (!script) {\n      JS_ReportErrorASCII(cx, \"module does not have an
        associated script\");\n      return false;\n    }\n  }\n\n  script->bodyScope()->dump();\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\n// For testing GC marking,
        blackRoot() and grayRoot() will heap-allocate an\n// array whose elements
        (as well as the array itself) will be marked as roots in\n// subsequent GCs.\n//\n//
        Note that EnsureGrayRoot() will blacken the returned object, so it will not\n//
        actually end up marked gray until the following GC clears the black bit\n//
        (assuming nothing is holding onto it.)\n//\n// The idea is that you can set
        up a whole graph of objects to be marked gray,\n// hanging off of the object
        returned from grayRoot(). Then you GC to clear the\n// black bits and set
        the gray bits.\n//\n// To test grayness, register the objects of interest
        with addMarkObservers(),\n// which takes an Array of objects (which will be
        marked black at the time\n// they're passed in). Their mark bits may be retrieved
        at any time with\n// getMarks(), in the form of an array of strings with each
        index corresponding\n// to the original objects passed to addMarkObservers().\n\nstatic
        bool EnsureRootArray(JSContext* cx, gc::MarkColor color, unsigned argc,\n
        \                           Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  auto priv = EnsureShellCompartmentPrivate(cx);\n  if (!priv) {\n
        \   return false;\n  }\n\n  GCPtr<ArrayObject*>& root =\n      (color == gc::MarkColor::Black)
        ? priv->blackRoot : priv->grayRoot;\n\n  if (!root && !(root = NewTenuredDenseEmptyArray(cx)))
        {\n    return false;\n  }\n\n  // Barrier to enforce the invariant that JS
        does not touch gray objects.\n  JSObject* obj = root;\n  JS::ExposeObjectToActiveJS(obj);\n\n
        \ args.rval().setObject(*obj);\n  return true;\n}\n\nstatic bool EnsureBlackRoot(JSContext*
        cx, unsigned argc, Value* vp) {\n  return EnsureRootArray(cx, gc::MarkColor::Black,
        argc, vp);\n}\n\nstatic bool EnsureGrayRoot(JSContext* cx, unsigned argc,
        Value* vp) {\n  return EnsureRootArray(cx, gc::MarkColor::Gray, argc, vp);\n}\n\nstatic
        MarkBitObservers* EnsureMarkBitObservers(JSContext* cx) {\n  ShellContext*
        sc = GetShellContext(cx);\n  if (!sc->markObservers) {\n    auto* observers
        =\n        cx->new_<MarkBitObservers>(cx->runtime(), NonshrinkingGCObjectVector());\n
        \   if (!observers) {\n      return nullptr;\n    }\n    sc->markObservers.reset(observers);\n
        \ }\n  return sc->markObservers.get();\n}\n\nstatic bool ClearMarkObservers(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ auto markObservers = EnsureMarkBitObservers(cx);\n  if (!markObservers)
        {\n    return false;\n  }\n\n  markObservers->get().clear();\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool AddMarkObservers(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  auto
        markObservers = EnsureMarkBitObservers(cx);\n  if (!markObservers) {\n    return
        false;\n  }\n\n  if (!args.get(0).isObject()) {\n    JS_ReportErrorASCII(cx,
        \"argument must be an Array of objects\");\n    return false;\n  }\n\n  RootedObject
        observersArg(cx, &args[0].toObject());\n  uint64_t length;\n  if (!GetLengthProperty(cx,
        observersArg, &length)) {\n    return false;\n  }\n\n  if (length > UINT32_MAX)
        {\n    JS_ReportErrorASCII(cx, \"Invalid length for observers array\");\n
        \   return false;\n  }\n\n  RootedValue value(cx);\n  RootedObject object(cx);\n
        \ for (uint32_t i = 0; i < length; i++) {\n    if (!JS_GetElement(cx, observersArg,
        i, &value)) {\n      return false;\n    }\n\n    if (!value.isObject()) {\n
        \     JS_ReportErrorASCII(cx, \"argument must be an Array of objects\");\n
        \     return false;\n    }\n\n    object = &value.toObject();\n    if (gc::IsInsideNursery(object))
        {\n      // WeakCaches are not swept during a minor GC. To prevent\n      //
        nursery-allocated contents from having the mark bits be deceptively\n      //
        black until the second GC, they would need to be marked weakly (cf\n      //
        NurseryAwareHashMap). It is simpler to evict the nursery to prevent\n      //
        nursery objects from being observed.\n      cx->runtime()->gc.evictNursery();\n
        \   }\n\n    if (!markObservers->get().append(object)) {\n      return false;\n
        \   }\n  }\n\n  args.rval().setInt32(length);\n  return true;\n}\n\nstatic
        bool GetMarks(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  auto& observers = GetShellContext(cx)->markObservers;\n
        \ if (!observers) {\n    args.rval().setUndefined();\n    return true;\n  }\n\n
        \ size_t length = observers->get().length();\n  Rooted<ArrayObject*> ret(cx,
        js::NewDenseEmptyArray(cx));\n  if (!ret) {\n    return false;\n  }\n\n  for
        (uint32_t i = 0; i < length; i++) {\n    const char* color;\n    JSObject*
        obj = observers->get()[i];\n    if (!obj) {\n      color = \"dead\";\n    }
        else if (obj->zone()->isGCPreparing()) {\n      color = \"unmarked\";\n    }
        else {\n      gc::TenuredCell* cell = &obj->asTenured();\n      if (cell->isMarkedGray())
        {\n        color = \"gray\";\n      } else if (cell->isMarkedBlack()) {\n
        \       color = \"black\";\n      } else {\n        color = \"unmarked\";\n
        \     }\n    }\n    JSString* s = JS_NewStringCopyZ(cx, color);\n    if (!s)
        {\n      return false;\n    }\n    if (!NewbornArrayPush(cx, ret, StringValue(s)))
        {\n      return false;\n    }\n  }\n\n  args.rval().setObject(*ret);\n  return
        true;\n}\n\nnamespace js {\nnamespace shell {\n\nclass ShellAutoEntryMonitor
        : JS::dbg::AutoEntryMonitor {\n  Vector<UniqueChars, 1, js::SystemAllocPolicy>
        log;\n  bool oom;\n  bool enteredWithoutExit;\n\n public:\n  explicit ShellAutoEntryMonitor(JSContext*
        cx)\n      : AutoEntryMonitor(cx), oom(false), enteredWithoutExit(false) {}\n\n
        \ ~ShellAutoEntryMonitor() { MOZ_ASSERT(!enteredWithoutExit); }\n\n  void
        Entry(JSContext* cx, JSFunction* function, JS::HandleValue asyncStack,\n             const
        char* asyncCause) override {\n    MOZ_ASSERT(!enteredWithoutExit);\n    enteredWithoutExit
        = true;\n\n    RootedString displayId(cx, JS_GetFunctionDisplayId(function));\n
        \   if (displayId) {\n      UniqueChars displayIdStr = JS_EncodeStringToUTF8(cx,
        displayId);\n      if (!displayIdStr) {\n        // We report OOM in buildResult.\n
        \       cx->recoverFromOutOfMemory();\n        oom = true;\n        return;\n
        \     }\n      oom = !log.append(std::move(displayIdStr));\n      return;\n
        \   }\n\n    oom = !log.append(DuplicateString(\"anonymous\"));\n  }\n\n  void
        Entry(JSContext* cx, JSScript* script, JS::HandleValue asyncStack,\n             const
        char* asyncCause) override {\n    MOZ_ASSERT(!enteredWithoutExit);\n    enteredWithoutExit
        = true;\n\n    UniqueChars label(JS_smprintf(\"eval:%s\", JS_GetScriptFilename(script)));\n
        \   oom = !label || !log.append(std::move(label));\n  }\n\n  void Exit(JSContext*
        cx) override {\n    MOZ_ASSERT(enteredWithoutExit);\n    enteredWithoutExit
        = false;\n  }\n\n  bool buildResult(JSContext* cx, MutableHandleValue resultValue)
        {\n    if (oom) {\n      JS_ReportOutOfMemory(cx);\n      return false;\n
        \   }\n\n    RootedObject result(cx, JS::NewArrayObject(cx, log.length()));\n
        \   if (!result) {\n      return false;\n    }\n\n    for (size_t i = 0; i
        < log.length(); i++) {\n      char* name = log[i].get();\n      RootedString
        string(cx, AtomizeUTF8Chars(cx, name, strlen(name)));\n      if (!string)
        {\n        return false;\n      }\n      RootedValue value(cx, StringValue(string));\n
        \     if (!JS_SetElement(cx, result, i, value)) {\n        return false;\n
        \     }\n    }\n\n    resultValue.setObject(*result.get());\n    return true;\n
        \ }\n};\n\n}  // namespace shell\n}  // namespace js\n\nstatic bool EntryPoints(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 1) {\n    JS_ReportErrorASCII(cx, \"Wrong number of
        arguments\");\n    return false;\n  }\n\n  RootedObject opts(cx, ToObject(cx,
        args[0]));\n  if (!opts) {\n    return false;\n  }\n\n  // { function: f }
        --- Call f.\n  {\n    RootedValue fun(cx), dummy(cx);\n\n    if (!JS_GetProperty(cx,
        opts, \"function\", &fun)) {\n      return false;\n    }\n    if (!fun.isUndefined())
        {\n      js::shell::ShellAutoEntryMonitor sarep(cx);\n      if (!Call(cx,
        UndefinedHandleValue, fun, JS::HandleValueArray::empty(),\n                &dummy))
        {\n        return false;\n      }\n      return sarep.buildResult(cx, args.rval());\n
        \   }\n  }\n\n  // { object: o, property: p, value: v } --- Fetch o[p], or
        if\n  // v is present, assign o[p] = v.\n  {\n    RootedValue objectv(cx),
        propv(cx), valuev(cx);\n\n    if (!JS_GetProperty(cx, opts, \"object\", &objectv)
        ||\n        !JS_GetProperty(cx, opts, \"property\", &propv))\n      return
        false;\n    if (!objectv.isUndefined() && !propv.isUndefined()) {\n      RootedObject
        object(cx, ToObject(cx, objectv));\n      if (!object) {\n        return false;\n
        \     }\n\n      RootedString string(cx, ToString(cx, propv));\n      if (!string)
        {\n        return false;\n      }\n      RootedId id(cx);\n      if (!JS_StringToId(cx,
        string, &id)) {\n        return false;\n      }\n\n      if (!JS_GetProperty(cx,
        opts, \"value\", &valuev)) {\n        return false;\n      }\n\n      js::shell::ShellAutoEntryMonitor
        sarep(cx);\n\n      if (!valuev.isUndefined()) {\n        if (!JS_SetPropertyById(cx,
        object, id, valuev)) {\n          return false;\n        }\n      } else {\n
        \       if (!JS_GetPropertyById(cx, object, id, &valuev)) {\n          return
        false;\n        }\n      }\n\n      return sarep.buildResult(cx, args.rval());\n
        \   }\n  }\n\n  // { ToString: v } --- Apply JS::ToString to v.\n  {\n    RootedValue
        v(cx);\n\n    if (!JS_GetProperty(cx, opts, \"ToString\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      js::shell::ShellAutoEntryMonitor
        sarep(cx);\n      if (!JS::ToString(cx, v)) {\n        return false;\n      }\n
        \     return sarep.buildResult(cx, args.rval());\n    }\n  }\n\n  // { ToNumber:
        v } --- Apply JS::ToNumber to v.\n  {\n    RootedValue v(cx);\n    double
        dummy;\n\n    if (!JS_GetProperty(cx, opts, \"ToNumber\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      js::shell::ShellAutoEntryMonitor
        sarep(cx);\n      if (!JS::ToNumber(cx, v, &dummy)) {\n        return false;\n
        \     }\n      return sarep.buildResult(cx, args.rval());\n    }\n  }\n\n
        \ // { eval: code } --- Apply ToString and then Evaluate to code.\n  {\n    RootedValue
        code(cx), dummy(cx);\n\n    if (!JS_GetProperty(cx, opts, \"eval\", &code))
        {\n      return false;\n    }\n    if (!code.isUndefined()) {\n      RootedString
        codeString(cx, ToString(cx, code));\n      if (!codeString) {\n        return
        false;\n      }\n\n      AutoStableStringChars linearChars(cx);\n      if
        (!linearChars.initTwoByte(cx, codeString)) {\n        return false;\n      }\n
        \     JS::SourceText<char16_t> srcBuf;\n      if (!srcBuf.initMaybeBorrowed(cx,
        linearChars)) {\n        return false;\n      }\n\n      CompileOptions options(cx);\n
        \     options.setIntroductionType(\"entryPoint eval\")\n          .setFileAndLine(\"entryPoint
        eval\", 1);\n\n      js::shell::ShellAutoEntryMonitor sarep(cx);\n      if
        (!JS::Evaluate(cx, options, srcBuf, &dummy)) {\n        return false;\n      }\n
        \     return sarep.buildResult(cx, args.rval());\n    }\n  }\n\n  JS_ReportErrorASCII(cx,
        \"bad 'params' object\");\n  return false;\n}\n\n#ifndef __wasi__\nstatic
        bool WasmTextToBinary(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (!args.requireAtLeast(cx, \"wasmTextToBinary\", 1)) {\n    return false;\n
        \ }\n\n  if (!args[0].isString()) {\n    ReportUsageErrorASCII(cx, callee,
        \"First argument must be a String\");\n    return false;\n  }\n\n  size_t
        textLen = args[0].toString()->length();\n\n  AutoStableStringChars twoByteChars(cx);\n
        \ if (!twoByteChars.initTwoByte(cx, args[0].toString())) {\n    return false;\n
        \ }\n\n  wasm::Bytes bytes;\n  UniqueChars error;\n  if (!wasm::TextToBinary(twoByteChars.twoByteChars(),
        textLen, &bytes,\n                          &error)) {\n    JS_ReportErrorNumberUTF8(cx,
        GetErrorMessage, nullptr, JSMSG_WASM_TEXT_FAIL,\n                             error.get()
        ? error.get() : \"out of memory\");\n    return false;\n  }\n\n  RootedObject
        binary(cx, JS_NewUint8Array(cx, bytes.length()));\n  if (!binary) {\n    return
        false;\n  }\n\n  memcpy(binary->as<TypedArrayObject>().dataPointerUnshared(),
        bytes.begin(),\n         bytes.length());\n\n  args.rval().setObject(*binary);\n
        \ return true;\n}\n\n#  ifndef __AFL_HAVE_MANUAL_CONTROL\n#    define __AFL_LOOP(x)
        true\n#  endif\n\nstatic bool WasmLoop(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx,
        &args.callee());\n\n  if (args.length() < 1 || args.length() > 2) {\n    ReportUsageErrorASCII(cx,
        callee, \"Wrong number of arguments\");\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be a String\");\n
        \   return false;\n  }\n\n  RootedObject importObj(cx);\n  if (!args.get(1).isUndefined())
        {\n    if (!args.get(1).isObject()) {\n      ReportUsageErrorASCII(cx, callee,\n
        \                           \"Second argument, if present, must be an Object\");\n
        \     return false;\n    }\n    importObj = &args[1].toObject();\n  }\n\n
        \ RootedString givenPath(cx, args[0].toString());\n  RootedString filename(cx,
        ResolvePath(cx, givenPath, RootRelative));\n  if (!filename) {\n    return
        false;\n  }\n\n  while (__AFL_LOOP(1000)) {\n    Rooted<JSObject*> ret(cx,
        FileAsTypedArray(cx, filename));\n    if (!ret) {\n      return false;\n    }\n\n
        \   Rooted<TypedArrayObject*> typedArray(cx, &ret->as<TypedArrayObject>());\n
        \   Rooted<WasmInstanceObject*> instanceObj(cx);\n    if (!wasm::Eval(cx,
        typedArray, importObj, &instanceObj)) {\n      // Clear any pending exceptions,
        we don't care about them\n      cx->clearPendingException();\n    }\n  }\n\n#
        \ ifdef __AFL_HAVE_MANUAL_CONTROL  // to silence unreachable code warning\n
        \ return true;\n#  endif\n}\n#endif  // __wasi__\n\nstatic constexpr uint32_t
        DOM_OBJECT_SLOT = 0;\nstatic constexpr uint32_t DOM_OBJECT_SLOT2 = 1;\n\nstatic
        const JSClass* GetDomClass();\n\nstatic JSObject* GetDOMPrototype(JSContext*
        cx, JSObject* global);\n\nstatic const JSClass TransplantableDOMObjectClass
        = {\n    \"TransplantableDOMObject\",\n    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)};\n\nstatic
        const JSClass TransplantableDOMProxyObjectClass =\n    PROXY_CLASS_DEF(\"TransplantableDOMProxyObject\",\n
        \                   JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1));\n\nclass
        TransplantableDOMProxyHandler final : public ForwardingProxyHandler {\n public:\n
        \ static const TransplantableDOMProxyHandler singleton;\n  static const char
        family;\n\n  constexpr TransplantableDOMProxyHandler() : ForwardingProxyHandler(&family)
        {}\n\n  // These two proxy traps are called in |js::DeadProxyTargetValue|,
        which in\n  // turn is called when nuking proxies. Because this proxy can
        temporarily be\n  // without an object in its private slot, see |EnsureExpandoObject|,
        the\n  // default implementation inherited from ForwardingProxyHandler can't
        be used,\n  // since it tries to derive the callable/constructible value from
        the target.\n  bool isCallable(JSObject* obj) const override { return false;
        }\n  bool isConstructor(JSObject* obj) const override { return false; }\n\n
        \ // Simplified implementation of |DOMProxyHandler::GetAndClearExpandoObject|.\n
        \ static JSObject* GetAndClearExpandoObject(JSObject* obj) {\n    const Value&
        v = GetProxyPrivate(obj);\n    if (v.isUndefined()) {\n      return nullptr;\n
        \   }\n\n    JSObject* expandoObject = &v.toObject();\n    SetProxyPrivate(obj,
        UndefinedValue());\n    return expandoObject;\n  }\n\n  // Simplified implementation
        of |DOMProxyHandler::EnsureExpandoObject|.\n  static JSObject* EnsureExpandoObject(JSContext*
        cx, JS::HandleObject obj) {\n    const Value& v = GetProxyPrivate(obj);\n
        \   if (v.isObject()) {\n      return &v.toObject();\n    }\n    MOZ_ASSERT(v.isUndefined());\n\n
        \   JSObject* expando = JS_NewObjectWithGivenProto(cx, nullptr, nullptr);\n
        \   if (!expando) {\n      return nullptr;\n    }\n    SetProxyPrivate(obj,
        ObjectValue(*expando));\n    return expando;\n  }\n};\n\nconst TransplantableDOMProxyHandler
        TransplantableDOMProxyHandler::singleton;\nconst char TransplantableDOMProxyHandler::family
        = 0;\n\nenum TransplantObjectSlots {\n  TransplantSourceObject = 0,\n};\n\nstatic
        bool TransplantObject(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedFunction callee(cx, &args.callee().as<JSFunction>());\n\n
        \ if (args.length() != 1 || !args[0].isObject()) {\n    JS_ReportErrorASCII(cx,
        \"transplant() must be called with an object\");\n    return false;\n  }\n\n
        \ // |newGlobal| needs to be a GlobalObject.\n  RootedObject newGlobal(\n
        \     cx, js::CheckedUnwrapDynamic(&args[0].toObject(), cx,\n                                   /*
        stopAtWindowProxy = */ false));\n  if (!newGlobal) {\n    ReportAccessDenied(cx);\n
        \   return false;\n  }\n  if (!JS_IsGlobalObject(newGlobal)) {\n    JS_ReportErrorNumberASCII(\n
        \       cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,\n        \"\\\"global\\\"
        passed to transplant()\", \"not a global object\");\n    return false;\n  }\n\n
        \ const Value& reserved =\n      GetFunctionNativeReserved(callee, TransplantSourceObject);\n
        \ RootedObject source(cx, CheckedUnwrapStatic(&reserved.toObject()));\n  if
        (!source) {\n    ReportAccessDenied(cx);\n    return false;\n  }\n  MOZ_ASSERT(source->getClass()->isDOMClass());\n\n
        \ // The following steps aim to replicate the behavior of UpdateReflectorGlobal\n
        \ // in dom/bindings/BindingUtils.cpp. In detail:\n  // 1. Check the recursion
        depth using checkConservative.\n  // 2. Enter the target compartment.\n  //
        3. Clone the source object using JS_CloneObject.\n  // 4. Check if new wrappers
        can be created if source and target are in\n  //    different compartments.\n
        \ // 5. Copy all properties from source to a temporary holder object.\n  //
        6. Actually transplant the object.\n  // 7. And finally copy the properties
        back to the source object.\n  //\n  // As an extension to the algorithm in
        UpdateReflectorGlobal, we also allow\n  // to transplant an object into the
        same compartment as the source object to\n  // cover all operations supported
        by JS_TransplantObject.\n\n  AutoCheckRecursionLimit recursion(cx);\n  if
        (!recursion.checkConservative(cx)) {\n    return false;\n  }\n\n  bool isProxy
        = IsProxy(source);\n  RootedObject expandoObject(cx);\n  if (isProxy) {\n
        \   expandoObject =\n        TransplantableDOMProxyHandler::GetAndClearExpandoObject(source);\n
        \ }\n\n  JSAutoRealm ar(cx, newGlobal);\n\n  RootedObject proto(cx);\n  if
        (JS::GetClass(source) == GetDomClass()) {\n    proto = GetDOMPrototype(cx,
        newGlobal);\n  } else {\n    proto = JS::GetRealmObjectPrototype(cx);\n  }\n
        \ if (!proto) {\n    return false;\n  }\n\n  RootedObject target(cx, JS_CloneObject(cx,
        source, proto));\n  if (!target) {\n    return false;\n  }\n\n  if (JS::GetCompartment(source)
        != JS::GetCompartment(target) &&\n      !AllowNewWrapper(JS::GetCompartment(source),
        target)) {\n    JS_ReportErrorASCII(cx, \"Cannot transplant into nuked compartment\");\n
        \   return false;\n  }\n\n  RootedObject copyFrom(cx, isProxy ? expandoObject
        : source);\n  RootedObject propertyHolder(cx,\n                              JS_NewObjectWithGivenProto(cx,
        nullptr, nullptr));\n  if (!propertyHolder) {\n    return false;\n  }\n\n
        \ if (!JS_CopyOwnPropertiesAndPrivateFields(cx, propertyHolder, copyFrom))
        {\n    return false;\n  }\n\n  JS::SetReservedSlot(target, DOM_OBJECT_SLOT,\n
        \                     JS::GetReservedSlot(source, DOM_OBJECT_SLOT));\n  JS::SetReservedSlot(source,
        DOM_OBJECT_SLOT, JS::PrivateValue(nullptr));\n  if (JS::GetClass(source) ==
        GetDomClass()) {\n    JS::SetReservedSlot(target, DOM_OBJECT_SLOT2,\n                        JS::GetReservedSlot(source,
        DOM_OBJECT_SLOT2));\n    JS::SetReservedSlot(source, DOM_OBJECT_SLOT2, UndefinedValue());\n
        \ }\n\n  source = JS_TransplantObject(cx, source, target);\n  if (!source)
        {\n    return false;\n  }\n\n  RootedObject copyTo(cx);\n  if (isProxy) {\n
        \   copyTo = TransplantableDOMProxyHandler::EnsureExpandoObject(cx, source);\n
        \   if (!copyTo) {\n      return false;\n    }\n  } else {\n    copyTo = source;\n
        \ }\n  if (!JS_CopyOwnPropertiesAndPrivateFields(cx, copyTo, propertyHolder))
        {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool TransplantableObject(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() > 1) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments\");\n    return false;\n  }\n\n  bool createProxy = false;\n
        \ RootedObject source(cx);\n  if (args.length() == 1 && !args[0].isUndefined())
        {\n    if (!args[0].isObject()) {\n      ReportUsageErrorASCII(cx, callee,
        \"Argument must be an object\");\n      return false;\n    }\n\n    RootedObject
        options(cx, &args[0].toObject());\n    RootedValue value(cx);\n\n    if (!JS_GetProperty(cx,
        options, \"proxy\", &value)) {\n      return false;\n    }\n    createProxy
        = JS::ToBoolean(value);\n\n    if (!JS_GetProperty(cx, options, \"object\",
        &value)) {\n      return false;\n    }\n    if (!value.isUndefined()) {\n
        \     if (!value.isObject()) {\n        ReportUsageErrorASCII(cx, callee,
        \"'object' option must be an object\");\n        return false;\n      }\n\n
        \     source = &value.toObject();\n      if (JS::GetClass(source) != GetDomClass())
        {\n        ReportUsageErrorASCII(cx, callee, \"Object not a FakeDOMObject\");\n
        \       return false;\n      }\n\n      // |source| must be a tenured object
        to be transplantable.\n      if (gc::IsInsideNursery(source)) {\n        JS_GC(cx);\n\n
        \       MOZ_ASSERT(!gc::IsInsideNursery(source),\n                   \"Live
        objects should be tenured after one GC, because \"\n                   \"the
        nursery has only a single generation\");\n      }\n    }\n  }\n\n  if (!source)
        {\n    if (!createProxy) {\n      source = NewBuiltinClassInstance(cx, &TransplantableDOMObjectClass,\n
        \                                      TenuredObject);\n      if (!source)
        {\n        return false;\n      }\n\n      JS::SetReservedSlot(source, DOM_OBJECT_SLOT,
        JS::PrivateValue(nullptr));\n    } else {\n      JSObject* expando = JS_NewPlainObject(cx);\n
        \     if (!expando) {\n        return false;\n      }\n      RootedValue expandoVal(cx,
        ObjectValue(*expando));\n\n      ProxyOptions options;\n      options.setClass(&TransplantableDOMProxyObjectClass);\n
        \     options.setLazyProto(true);\n\n      source = NewProxyObject(cx, &TransplantableDOMProxyHandler::singleton,\n
        \                             expandoVal, nullptr, options);\n      if (!source)
        {\n        return false;\n      }\n\n      SetProxyReservedSlot(source, DOM_OBJECT_SLOT,
        JS::PrivateValue(nullptr));\n    }\n  }\n\n  jsid emptyId = NameToId(cx->names().empty);\n
        \ RootedObject transplant(\n      cx, NewFunctionByIdWithReserved(cx, TransplantObject,
        0, 0, emptyId));\n  if (!transplant) {\n    return false;\n  }\n\n  SetFunctionNativeReserved(transplant,
        TransplantSourceObject,\n                            ObjectValue(*source));\n\n
        \ RootedObject result(cx, JS_NewPlainObject(cx));\n  if (!result) {\n    return
        false;\n  }\n\n  RootedValue sourceVal(cx, ObjectValue(*source));\n  RootedValue
        transplantVal(cx, ObjectValue(*transplant));\n  if (!JS_DefineProperty(cx,
        result, \"object\", sourceVal, 0) ||\n      !JS_DefineProperty(cx, result,
        \"transplant\", transplantVal, 0)) {\n    return false;\n  }\n\n  args.rval().setObject(*result);\n
        \ return true;\n}\n\n#ifdef DEBUG\nstatic bool DebugGetQueuedJobs(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ JSObject* jobs = js::GetJobsInInternalJobQueue(cx);\n  if (!jobs) {\n    return
        false;\n  }\n\n  args.rval().setObject(*jobs);\n  return true;\n}\n#endif\n\n#ifdef
        FUZZING_INTERFACES\nextern \"C\" {\nsize_t gluesmith(uint8_t* data, size_t
        size, uint8_t* out, size_t maxsize);\n}\n\nstatic bool GetWasmSmithModule(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ RootedObject callee(cx, &args.callee());\n\n  if (args.length() != 1) {\n
        \   ReportUsageErrorASCII(cx, callee, \"Wrong number of arguments\");\n    return
        false;\n  }\n\n  if (!args[0].isObject() || !args[0].toObject().is<ArrayBufferObject>())
        {\n    ReportUsageErrorASCII(cx, callee, \"Argument must be ArrayBuffer.\");\n
        \   return false;\n  }\n\n  ArrayBufferObject* arrayBuffer = &args[0].toObject().as<ArrayBufferObject>();\n
        \ size_t length = arrayBuffer->byteLength();\n  uint8_t* data = arrayBuffer->dataPointer();\n\n
        \ const size_t maxModuleSize = 4096;\n  uint8_t tmp[maxModuleSize];\n\n  size_t
        outSize = gluesmith(data, length, tmp, maxModuleSize);\n  if (!outSize) {\n
        \   JS_ReportErrorASCII(cx, \"Generated module is too large.\");\n    return
        false;\n  }\n\n  JS::Rooted<JSObject*> outArr(cx, JS_NewUint8ClampedArray(cx,
        outSize));\n  if (!outArr) {\n    return false;\n  }\n\n  {\n    JS::AutoCheckCannotGC
        nogc;\n    bool isShared;\n    uint8_t* data = JS_GetUint8ClampedArrayData(outArr,
        &isShared, nogc);\n    MOZ_RELEASE_ASSERT(!isShared);\n    memcpy(data, tmp,
        outSize);\n  }\n\n  args.rval().setObject(*outArr);\n  return true;\n}\n\n#endif\n\nstatic
        bool IsValidJSON(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (!args.get(0).isString()) {\n    ReportUsageErrorASCII(cx, callee, \"First
        argument must be a String\");\n    return false;\n  }\n\n  JS::Rooted<JSLinearString*>
        input(cx, args[0].toString()->ensureLinear(cx));\n  if (!input) {\n    return
        false;\n  }\n\n  bool result;\n  if (input->hasLatin1Chars()) {\n    JS::AutoCheckCannotGC
        nogc;\n    result = JS::IsValidJSON(input->latin1Chars(nogc), input->length());\n
        \ } else {\n    JS::AutoCheckCannotGC nogc;\n    result = JS::IsValidJSON(input->twoByteChars(nogc),
        input->length());\n  }\n\n  args.rval().setBoolean(result);\n  return true;\n}\n\n//
        clang-format off\nstatic const JSFunctionSpecWithHelp shell_functions[] =
        {\n    JS_FN_HELP(\"options\", Options, 0, 0,\n\"options([option ...])\",\n\"
        \ Get or toggle JavaScript options.\"),\n\n    JS_FN_HELP(\"load\", Load,
        1, 0,\n\"load(['foo.js' ...])\",\n\"  Load files named by string arguments.
        Filename is relative to the\\n\"\n\"      current working directory.\"),\n\n
        \   JS_FN_HELP(\"loadRelativeToScript\", LoadScriptRelativeToScript, 1, 0,\n\"loadRelativeToScript(['foo.js'
        ...])\",\n\"  Load files named by string arguments. Filename is relative to
        the\\n\"\n\"      calling script.\"),\n\n    JS_FN_HELP(\"evaluate\", Evaluate,
        2, 0,\n\"evaluate(code[, options])\",\n\"  Evaluate code as though it were
        the contents of a file.\\n\"\n\"  options is an optional object that may have
        these properties:\\n\"\n\"      isRunOnce: use the isRunOnce compiler option
        (default: false)\\n\"\n\"      noScriptRval: use the no-script-rval compiler
        option (default: false)\\n\"\n\"      fileName: filename for error messages
        and debug info\\n\"\n\"      skipFileNameValidation: skip the filename-validation
        callback\\n\"\n\"      lineNumber: starting line number for error messages
        and debug info\\n\"\n\"      columnNumber: starting column number for error
        messages and debug info\\n\"\n\"      global: global in which to execute the
        code\\n\"\n\"      newContext: if true, create and use a new cx (default:
        false)\\n\"\n\"      catchTermination: if true, catch termination (failure
        without\\n\"\n\"         an exception value, as for slow scripts or out-of-memory)\\n\"\n\"
        \        and return 'terminated'\\n\"\n\"      element: if present with value
        |v|, convert |v| to an object |o| and\\n\"\n\"         mark the source as
        being attached to the DOM element |o|. If the\\n\"\n\"         property is
        omitted or |v| is null, don't attribute the source to\\n\"\n\"         any
        DOM element.\\n\"\n\"      elementAttributeName: if present and not undefined,
        the name of\\n\"\n\"         property of 'element' that holds this code. This
        is what\\n\"\n\"         Debugger.Source.prototype.elementAttributeName returns.\\n\"\n\"
        \     sourceMapURL: if present with value |v|, convert |v| to a string, and\\n\"\n\"
        \        provide that as the code's source map URL. If omitted, attach no\\n\"\n\"
        \        source map URL to the code (although the code may provide one itself,\\n\"\n\"
        \        via a //#sourceMappingURL comment).\\n\"\n\"      sourceIsLazy: if
        present and true, indicates that, after compilation, \\n\"\n\"          script
        source should not be cached by the JS engine and should be \\n\"\n\"          lazily
        loaded from the embedding as-needed.\\n\"\n\"      forceFullParse: if present
        and true, disable syntax-parse.\\n\"\n\"      loadBytecode: if true, and if
        the source is a CacheEntryObject,\\n\"\n\"         the bytecode would be loaded
        and decoded from the cache entry instead\\n\"\n\"         of being parsed,
        then it would be executed as usual.\\n\"\n\"      saveIncrementalBytecode:
        if true, and if the source is a\\n\"\n\"         CacheEntryObject, the bytecode
        would be incrementally encoded and\\n\"\n\"         saved into the cache entry.\\n\"\n\"
        \     execute: if false, do not execute the script, but do parse and/or\\n\"\n\"
        \              transcode.\\n\"\n\"      assertEqBytecode: if true, and if
        both loadBytecode and either\\n\"\n\"         saveIncrementalBytecode is true,
        then the loaded\\n\"\n\"         bytecode and the encoded bytecode are compared.\\n\"\n\"
        \        and an assertion is raised if they differ.\\n\"\n\"      envChainObject:
        object to put on the scope chain, with its fields added\\n\"\n\"         as
        var bindings, akin to how elements are added to the environment in\\n\"\n\"
        \        event handlers in Gecko.\\n\"\n),\n\n    JS_FN_HELP(\"run\", Run,
        1, 0,\n\"run('foo.js')\",\n\"  Run the file named by the first argument, returning
        the number of\\n\"\n\"  of milliseconds spent compiling and executing it.\"),\n\n
        \   JS_FN_HELP(\"readline\", ReadLine, 0, 0,\n\"readline()\",\n\"  Read a
        single line from stdin.\"),\n\n    JS_FN_HELP(\"readlineBuf\", ReadLineBuf,
        1, 0,\n\"readlineBuf([ buf ])\",\n\"  Emulate readline() on the specified
        string. The first call with a string\\n\"\n\"  argument sets the source buffer.
        Subsequent calls without an argument\\n\"\n\"  then read from this buffer
        line by line.\\n\"),\n\n    JS_FN_HELP(\"print\", Print, 0, 0,\n\"print([exp
        ...])\",\n\"  Evaluate and print expressions to stdout.\"),\n\n    JS_FN_HELP(\"printErr\",
        PrintErr, 0, 0,\n\"printErr([exp ...])\",\n\"  Evaluate and print expressions
        to stderr.\"),\n\n    JS_FN_HELP(\"putstr\", PutStr, 0, 0,\n\"putstr([exp])\",\n\"
        \ Evaluate and print expression without newline.\"),\n\n    JS_FN_HELP(\"dateNow\",
        Now, 0, 0,\n\"dateNow()\",\n\"  Return the current time with sub-ms precision.\"),\n\n
        \   JS_FN_HELP(\"help\", Help, 0, 0,\n\"help([function or interface object
        or /pattern/])\",\n\"  Display usage and help messages.\"),\n\n    JS_FN_HELP(\"quit\",
        Quit, 0, 0,\n\"quit()\",\n\"  Quit the shell.\"),\n\n    JS_FN_HELP(\"assertEq\",
        AssertEq, 2, 0,\n\"assertEq(actual, expected[, msg])\",\n\"  Throw if the
        first two arguments are not the same (both +0 or both -0,\\n\"\n\"  both NaN,
        or non-zero and ===).\"),\n\n    JS_FN_HELP(\"startTimingMutator\", StartTimingMutator,
        0, 0,\n\"startTimingMutator()\",\n\"  Start accounting time to mutator vs
        GC.\"),\n\n    JS_FN_HELP(\"stopTimingMutator\", StopTimingMutator, 0, 0,\n\"stopTimingMutator()\",\n\"
        \ Stop accounting time to mutator vs GC and dump the results.\"),\n\n    JS_FN_HELP(\"throwError\",
        ThrowError, 0, 0,\n\"throwError()\",\n\"  Throw an error from JS_ReportError.\"),\n\n
        \   JS_FN_HELP(\"createErrorReport\", CreateErrorReport, 1, 0,\n\"createErrorReport(value)\",\n\"
        \ Create an JS::ErrorReportBuilder object from the given value and serialize\\n\"\n\"
        \ to an object.\"),\n\n#if defined(DEBUG) || defined(JS_JITSPEW)\n    JS_FN_HELP(\"disassemble\",
        DisassembleToString, 1, 0,\n\"disassemble([fun/code])\",\n\"  Return the disassembly
        for the given function or code.\\n\"\n\"  All disassembly functions take these
        options as leading string arguments:\\n\"\n\"    \\\"-r\\\" (disassemble recursively)\\n\"\n\"
        \   \\\"-l\\\" (show line numbers)\\n\"\n\"    \\\"-S\\\" (omit source notes)\"),\n\n
        \   JS_FN_HELP(\"dis\", Disassemble, 1, 0,\n\"dis([fun/code])\",\n\"  Disassemble
        functions into bytecodes.\"),\n\n    JS_FN_HELP(\"disfile\", DisassFile, 1,
        0,\n\"disfile('foo.js')\",\n\"  Disassemble script file into bytecodes.\\n\"),\n\n
        \   JS_FN_HELP(\"dissrc\", DisassWithSrc, 1, 0,\n\"dissrc([fun/code])\",\n\"
        \ Disassemble functions with source lines.\"),\n\n    JS_FN_HELP(\"notes\",
        Notes, 1, 0,\n\"notes([fun])\",\n\"  Show source notes for functions.\"),\n\n
        \   JS_FN_HELP(\"stackDump\", StackDump, 3, 0,\n\"stackDump(showArgs, showLocals,
        showThisProps)\",\n\"  Tries to print a lot of information about the current
        stack. \\n\"\n\"  Similar to the DumpJSStack() function in the browser.\"),\n\n#endif\n\n
        \   JS_FN_HELP(\"getslx\", GetSLX, 1, 0,\n\"getslx(obj)\",\n\"  Get script
        line extent.\"),\n\n    JS_FN_HELP(\"evalcx\", EvalInContext, 1, 0,\n\"evalcx(s[,
        o])\",\n\"  Evaluate s in optional sandbox object o.\\n\"\n\"  if (s == ''
        && !o) return new o with eager standard classes\\n\"\n\"  if (s == 'lazy'
        && !o) return new o with lazy standard classes\"),\n\n    JS_FN_HELP(\"evalInWorker\",
        EvalInWorker, 1, 0,\n\"evalInWorker(str)\",\n\"  Evaluate 'str' in a separate
        thread with its own runtime.\\n\"),\n\n    JS_FN_HELP(\"getSharedObject\",
        GetSharedObject, 0, 0,\n\"getSharedObject()\",\n\"  Retrieve the shared object
        from the cross-worker mailbox.\\n\"\n\"  The object retrieved may not be identical
        to the object that was\\n\"\n\"  installed, but it references the same shared
        memory.\\n\"\n\"  getSharedObject performs an ordering memory barrier.\\n\"),\n\n
        \   JS_FN_HELP(\"setSharedObject\", SetSharedObject, 0, 0,\n\"setSharedObject(obj)\",\n\"
        \ Install the shared object in the cross-worker mailbox.  The object\\n\"\n\"
        \ may be null.  setSharedObject performs an ordering memory barrier.\\n\"),\n\n
        \   JS_FN_HELP(\"getSharedArrayBuffer\", GetSharedObject, 0, 0,\n\"getSharedArrayBuffer()\",\n\"
        \ Obsolete alias for getSharedObject().\\n\"),\n\n    JS_FN_HELP(\"setSharedArrayBuffer\",
        SetSharedObject, 0, 0,\n\"setSharedArrayBuffer(obj)\",\n\"  Obsolete alias
        for setSharedObject(obj).\\n\"),\n\n    JS_FN_HELP(\"shapeOf\", ShapeOf, 1,
        0,\n\"shapeOf(obj)\",\n\"  Get the shape of obj (an implementation detail).\"),\n\n#ifdef
        DEBUG\n    JS_FN_HELP(\"arrayInfo\", ArrayInfo, 1, 0,\n\"arrayInfo(a1, a2,
        ...)\",\n\"  Report statistics about arrays.\"),\n#endif\n\n    JS_FN_HELP(\"sleep\",
        Sleep_fn, 1, 0,\n\"sleep(dt)\",\n\"  Sleep for dt seconds.\"),\n\n    JS_FN_HELP(\"parseModule\",
        ParseModule, 1, 0,\n\"parseModule(code)\",\n\"  Parses source text as a module
        and returns a ModuleObject wrapper object.\"),\n\n    JS_FN_HELP(\"instantiateModuleStencil\",
        InstantiateModuleStencil, 1, 0,\n\"instantiateModuleStencil(stencil, [options])\",\n\"
        \ Instantiates the given stencil as module, and return the module object.\"),\n\n
        \   JS_FN_HELP(\"instantiateModuleStencilXDR\", InstantiateModuleStencilXDR,
        1, 0,\n\"instantiateModuleStencilXDR(stencil, [options])\",\n\"  Reads the
        given stencil XDR object, instantiates the stencil as module, and\"\n\"  return
        the module object.\"),\n\n    JS_FN_HELP(\"registerModule\", RegisterModule,
        2, 0,\n\"registerModule(specifier, module)\",\n\"  Register a module with
        the module loader, so that subsequent import from\\n\"\n\"  |specifier| will
        resolve to |module|.  Returns |module|.\"),\n\n    JS_FN_HELP(\"clearModules\",
        ClearModules, 0, 0,\n\"clearModules()\",\n\"  Clear knowledge of all loaded
        modules.\"),\n\n    JS_FN_HELP(\"moduleLink\", ModuleLink, 1, 0,\n\"moduleLink(moduleOjbect)\",\n\"
        \ Link a module graph, performing the spec's Link method.\"),\n\n    JS_FN_HELP(\"moduleEvaluate\",
        ModuleEvaluate, 1, 0,\n\"moduleEvaluate(moduleOjbect)\",\n\"  Evaluate a module
        graph, performing the spec's Evaluate method.\"),\n\n    JS_FN_HELP(\"getModuleEnvironmentNames\",
        GetModuleEnvironmentNames, 1, 0,\n\"getModuleEnvironmentNames(module)\",\n\"
        \ Get the list of a module environment's bound names for a specified module.\\n\"),\n\n
        \   JS_FN_HELP(\"getModuleEnvironmentValue\", GetModuleEnvironmentValue, 2,
        0,\n\"getModuleEnvironmentValue(module, name)\",\n\"  Get the value of a bound
        name in a module environment.\\n\"),\n\n    JS_FN_HELP(\"dumpStencil\", DumpStencil,
        1, 0,\n\"dumpStencil(code, [options])\",\n\"  Parses a string and returns
        string that represents stencil.\\n\"\n\"  If present, |options| may have properties
        saying how the code should be\\n\"\n\"  compiled:\\n\"\n\"      module: if
        present and true, compile the source as module.\\n\"\n\"      smoosh: if present
        and true, use SmooshMonkey.\\n\"\n\"  CompileOptions-related properties of
        evaluate function's option can also\\n\"\n\"  be used.\"),\n\n    JS_FN_HELP(\"parse\",
        Parse, 1, 0,\n\"parse(code, [options])\",\n\"  Parses a string, potentially
        throwing. If present, |options| may\\n\"\n\"  have properties saying how the
        code should be compiled:\\n\"\n\"      module: if present and true, compile
        the source as module.\\n\"\n\"      smoosh: if present and true, use SmooshMonkey.\\n\"\n\"
        \ CompileOptions-related properties of evaluate function's option can also\\n\"\n\"
        \ be used. except forceFullParse. This function always use full parse.\"),\n\n
        \   JS_FN_HELP(\"syntaxParse\", SyntaxParse, 1, 0,\n\"syntaxParse(code)\",\n\"
        \ Check the syntax of a string, returning success value\"),\n\n    JS_FN_HELP(\"offThreadCompileModuleToStencil\",
        OffThreadCompileModuleToStencil, 1, 0,\n\"offThreadCompileModuleToStencil(code)\",\n\"
        \ Compile |code| on a helper thread, returning a job ID. To wait for the\\n\"\n\"
        \ compilation to finish and and get the module stencil object call\\n\"\n\"
        \ |finishOffThreadStencil| passing the job ID.\"),\n\n    JS_FN_HELP(\"offThreadDecodeStencil\",
        OffThreadDecodeStencil, 1, 0,\n\"offThreadDecodeStencil(cacheEntry[, options])\",\n\"
        \ Decode |code| on a helper thread, returning a job ID. To wait for the\\n\"\n\"
        \ decoding to finish and run the code, call |finishOffThreadStencil| passing\\n\"\n\"
        \ the job ID. If present, |options| may have properties saying how the code\\n\"\n\"
        \ should be compiled (see also offThreadCompileToStencil).\"),\n\n    JS_FN_HELP(\"offThreadCompileToStencil\",
        OffThreadCompileToStencil, 1, 0,\n\"offThreadCompileToStencil(code[, options])\",\n\"
        \ Compile |code| on a helper thread, returning a job ID. To wait for the\\n\"\n\"
        \ compilation to finish and get the stencil object, call\\n\"\n\"  |finishOffThreadStencil|
        passing the job ID.  If present, \\n\"\n\"  |options| may have properties
        saying how the code should be compiled:\\n\"\n\"      noScriptRval: use the
        no-script-rval compiler option (default: false)\\n\"\n\"      fileName: filename
        for error messages and debug info\\n\"\n\"      lineNumber: starting line
        number for error messages and debug info\\n\"\n\"      columnNumber: starting
        column number for error messages and debug info\\n\"\n\"      element: if
        present with value |v|, convert |v| to an object |o| and\\n\"\n\"         mark
        the source as being attached to the DOM element |o|. If the\\n\"\n\"         property
        is omitted or |v| is null, don't attribute the source to\\n\"\n\"         any
        DOM element.\\n\"\n\"      elementAttributeName: if present and not undefined,
        the name of\\n\"\n\"         property of 'element' that holds this code. This
        is what\\n\"\n\"         Debugger.Source.prototype.elementAttributeName returns.\"),\n\n
        \   JS_FN_HELP(\"finishOffThreadStencil\", FinishOffThreadStencil, 0, 0,\n\"finishOffThreadStencil([jobID])\",\n\"
        \ Wait for an off-thread compilation or decode job to complete. The job ID\\n\"\n\"
        \ can be ommitted if there is only one job pending. If an error occurred,\\n\"\n\"
        \ throw the appropriate exception; otherwise, return the stencil object,\"\n\"
        \ that can be passed to |evalStencil|.\"),\n\n    JS_FN_HELP(\"timeout\",
        Timeout, 1, 0,\n\"timeout([seconds], [func])\",\n\"  Get/Set the limit in
        seconds for the execution time for the current context.\\n\"\n\"  When the
        timeout expires the current interrupt callback is invoked.\\n\"\n\"  The timeout
        is used just once.  If the callback returns a falsy value, the\\n\"\n\"  script
        is aborted.  A negative value for seconds (this is the default) cancels\\n\"\n\"
        \ any pending timeout.\\n\"\n\"  If a second argument is provided, it is installed
        as the interrupt handler,\\n\"\n\"  exactly as if by |setInterruptCallback|.\\n\"),\n\n
        \   JS_FN_HELP(\"interruptIf\", InterruptIf, 1, 0,\n\"interruptIf(cond)\",\n\"
        \ Requests interrupt callback if cond is true. If a callback function is set
        via\\n\"\n\"  |timeout| or |setInterruptCallback|, it will be called. No-op
        otherwise.\"),\n\n    JS_FN_HELP(\"invokeInterruptCallback\", InvokeInterruptCallbackWrapper,
        0, 0,\n\"invokeInterruptCallback(fun)\",\n\"  Forcefully set the interrupt
        flag and invoke the interrupt handler. If a\\n\"\n\"  callback function is
        set via |timeout| or |setInterruptCallback|, it will\\n\"\n\"  be called.
        Before returning, fun is called with the return value of the\\n\"\n\"  interrupt
        handler.\"),\n\n    JS_FN_HELP(\"setInterruptCallback\", SetInterruptCallback,
        1, 0,\n\"setInterruptCallback(func)\",\n\"  Sets func as the interrupt callback
        function.\\n\"\n\"  Calling this function will replace any callback set by
        |timeout|.\\n\"\n\"  If the callback returns a falsy value, the script is
        aborted.\\n\"),\n\n    JS_FN_HELP(\"setJitCompilerOption\", SetJitCompilerOption,
        2, 0,\n\"setJitCompilerOption(<option>, <number>)\",\n\"  Set a compiler option
        indexed in JSCompileOption enum to a number.\\n\"),\n#ifdef DEBUG\n    JS_FN_HELP(\"interruptRegexp\",
        InterruptRegexp, 2, 0,\n\"interruptRegexp(<regexp>, <string>)\",\n\"  Interrrupt
        the execution of regular expression.\\n\"),\n#endif\n    JS_FN_HELP(\"enableLastWarning\",
        EnableLastWarning, 0, 0,\n\"enableLastWarning()\",\n\"  Enable storing the
        last warning.\"),\n\n    JS_FN_HELP(\"disableLastWarning\", DisableLastWarning,
        0, 0,\n\"disableLastWarning()\",\n\"  Disable storing the last warning.\"),\n\n
        \   JS_FN_HELP(\"getLastWarning\", GetLastWarning, 0, 0,\n\"getLastWarning()\",\n\"
        \ Returns an object that represents the last warning.\"),\n\n    JS_FN_HELP(\"clearLastWarning\",
        ClearLastWarning, 0, 0,\n\"clearLastWarning()\",\n\"  Clear the last warning.\"),\n\n
        \   JS_FN_HELP(\"elapsed\", Elapsed, 0, 0,\n\"elapsed()\",\n\"  Execution
        time elapsed for the current thread.\"),\n\n    JS_FN_HELP(\"decompileFunction\",
        DecompileFunction, 1, 0,\n\"decompileFunction(func)\",\n\"  Decompile a function.\"),\n\n
        \   JS_FN_HELP(\"decompileThis\", DecompileThisScript, 0, 0,\n\"decompileThis()\",\n\"
        \ Decompile the currently executing script.\"),\n\n    JS_FN_HELP(\"valueToSource\",
        ValueToSource, 1, 0,\n\"valueToSource(value)\",\n\"  Format a value for inspection.\"),\n\n
        \   JS_FN_HELP(\"thisFilename\", ThisFilename, 0, 0,\n\"thisFilename()\",\n\"
        \ Return the filename of the current script\"),\n\n    JS_FN_HELP(\"newGlobal\",
        NewGlobal, 1, 0,\n\"newGlobal([options])\",\n\"  Return a new global object/realm.
        The new global is created in the\\n\"\n\"  'newGlobal' function object's compartment
        and zone, unless the\\n\"\n\"  '--more-compartments' command-line flag was
        given, in which case new\\n\"\n\"  globals get a fresh compartment and zone.
        If options is given, it may\\n\"\n\"  have any of the following properties:\\n\"\n\"
        \     sameCompartmentAs: If an object, the global will be in the same\\n\"\n\"
        \        compartment and zone as the given object.\\n\"\n\"      sameZoneAs:
        The global will be in a new compartment in the same zone\\n\"\n\"         as
        the given object.\\n\"\n\"      newCompartment: If true, the global will always
        be created in a new\\n\"\n\"         compartment and zone.\\n\"\n\"      invisibleToDebugger:
        If true, the global will be invisible to the\\n\"\n\"         debugger (default
        false)\\n\"\n\"      discardSource: If true, discard source after compiling
        a script\\n\"\n\"         (default false).\\n\"\n\"      useWindowProxy: the
        global will be created with a WindowProxy attached. In this\\n\"\n\"          case,
        the WindowProxy will be returned.\\n\"\n\"      freezeBuiltins: certain builtin
        constructors will be frozen when created and\\n\"\n\"          their prototypes
        will be sealed. These constructors will be defined on the\\n\"\n\"          global
        as non-configurable and non-writable.\\n\"\n\"      immutablePrototype: whether
        the global's prototype is immutable.\\n\"\n\"      principal: if present,
        its value converted to a number must be an\\n\"\n\"         integer that fits
        in 32 bits; use that as the new realm's\\n\"\n\"         principal. Shell
        principals are toys, meant only for testing; one\\n\"\n\"         shell principal
        subsumes another if its set bits are a superset of\\n\"\n\"         the other's.
        Thus, a principal of 0 subsumes nothing, while a\\n\"\n\"         principals
        of ~0 subsumes all other principals. The absence of a\\n\"\n\"         principal
        is treated as if its bits were 0xffff, for subsumption\\n\"\n\"         purposes.
        If this property is omitted, supply no principal.\\n\"\n\"      systemPrincipal:
        If true, use the shell's trusted principals for the\\n\"\n\"         new realm.
        This creates a realm that's marked as a 'system' realm.\"),\n\n    JS_FN_HELP(\"nukeAllCCWs\",
        NukeAllCCWs, 0, 0,\n\"nukeAllCCWs()\",\n\"  Like nukeCCW, but for all CrossCompartmentWrappers
        targeting the current realm.\"),\n\n    JS_FN_HELP(\"recomputeWrappers\",
        RecomputeWrappers, 2, 0,\n\"recomputeWrappers([src, [target]])\",\n\"  Recompute
        all cross-compartment wrappers. src and target are both optional\\n\"\n\"
        \ and can be used to filter source or target compartments: the unwrapped\\n\"\n\"
        \ object's compartment is used as CompartmentFilter.\\n\"),\n\n    JS_FN_HELP(\"dumpObjectWrappers\",
        DumpObjectWrappers, 2, 0,\n\"dumpObjectWrappers()\",\n\"  Print information
        about cross-compartment object wrappers.\\n\"),\n\n    JS_FN_HELP(\"wrapWithProto\",
        WrapWithProto, 2, 0,\n\"wrapWithProto(obj)\",\n\"  Wrap an object into a noop
        wrapper with prototype semantics.\"),\n\n    JS_FN_HELP(\"createExternalArrayBuffer\",
        CreateExternalArrayBuffer, 1, 0,\n\"createExternalArrayBuffer(size)\",\n\"
        \ Create an array buffer that has external data of size.\"),\n\n    JS_FN_HELP(\"createMappedArrayBuffer\",
        CreateMappedArrayBuffer, 1, 0,\n\"createMappedArrayBuffer(filename, [offset,
        [size]])\",\n\"  Create an array buffer that mmaps the given file.\"),\n\n
        \   JS_FN_HELP(\"addPromiseReactions\", AddPromiseReactions, 3, 0,\n\"addPromiseReactions(promise,
        onResolve, onReject)\",\n\"  Calls the JS::AddPromiseReactions JSAPI function
        with the given arguments.\"),\n\n    JS_FN_HELP(\"ignoreUnhandledRejections\",
        IgnoreUnhandledRejections, 0, 0,\n\"ignoreUnhandledRejections()\",\n\"  By
        default, js shell tracks unhandled promise rejections and reports\\n\"\n\"
        \ them at the end of the exectuion.  If a testcase isn't interested\\n\"\n\"
        \ in those rejections, call this to stop tracking and reporting.\"),\n\n    JS_FN_HELP(\"getMaxArgs\",
        GetMaxArgs, 0, 0,\n\"getMaxArgs()\",\n\"  Return the maximum number of supported
        args for a call.\"),\n\n    JS_FN_HELP(\"createIsHTMLDDA\", CreateIsHTMLDDA,
        0, 0,\n\"createIsHTMLDDA()\",\n\"  Return an object |obj| that \\\"looks like\\\"
        the |document.all| object in\\n\"\n\"  browsers in certain ways: |typeof obj
        === \\\"undefined\\\"|, |obj == null|\\n\"\n\"  and |obj == undefined| (vice
        versa for !=), |ToBoolean(obj) === false|,\\n\"\n\"  and when called with
        no arguments or the single argument \\\"\\\" returns\\n\"\n\"  null.  (Calling
        |obj| any other way crashes or throws an exception.)\\n\"\n\"  This function
        implements the exact requirements of the $262.IsHTMLDDA\\n\"\n\"  property
        in test262.\"),\n\n    JS_FN_HELP(\"cacheEntry\", CacheEntry, 1, 0,\n\"cacheEntry(code)\",\n\"
        \ Return a new opaque object which emulates a cache entry of a script.  This\\n\"\n\"
        \ object encapsulates the code and its cached content. The cache entry is
        filled\\n\"\n\"  and read by the \\\"evaluate\\\" function by using it in
        place of the source, and\\n\"\n\"  by setting \\\"saveIncrementalBytecode\\\"
        and \\\"loadBytecode\\\" options.\"),\n\n    JS_FN_HELP(\"streamCacheEntry\",
        StreamCacheEntryObject::construct, 1, 0,\n\"streamCacheEntry(buffer)\",\n\"
        \ Create a shell-only object that holds wasm bytecode and can be streaming-\\n\"\n\"
        \ compiled and cached by WebAssembly.{compile,instantiate}Streaming(). On
        a\\n\"\n\"  second compilation of the same cache entry, the cached code will
        be used.\"),\n\n    JS_FN_HELP(\"printProfilerEvents\", PrintProfilerEvents,
        0, 0,\n\"printProfilerEvents()\",\n\"  Register a callback with the profiler
        that prints javascript profiler events\\n\"\n\"  to stderr.  Callback is only
        registered if profiling is enabled.\"),\n\n    JS_FN_HELP(\"enableSingleStepProfiling\",
        EnableSingleStepProfiling, 0, 0,\n\"enableSingleStepProfiling()\",\n\"  This
        function will fail on platforms that don't support single-step profiling\\n\"\n\"
        \ (currently ARM and MIPS64 support it). When enabled, at every instruction
        a\\n\"\n\"  backtrace will be recorded and stored in an array. Adjacent duplicate
        backtraces\\n\"\n\"  are discarded.\"),\n\n    JS_FN_HELP(\"disableSingleStepProfiling\",
        DisableSingleStepProfiling, 0, 0,\n\"disableSingleStepProfiling()\",\n\"  Return
        the array of backtraces recorded by enableSingleStepProfiling.\"),\n\n    JS_FN_HELP(\"enableGeckoProfiling\",
        EnableGeckoProfiling, 0, 0,\n\"enableGeckoProfiling()\",\n\"  Enables Gecko
        Profiler instrumentation and corresponding assertions, with slow\\n\"\n\"
        \ assertions disabled.\\n\"),\n\n    JS_FN_HELP(\"enableGeckoProfilingWithSlowAssertions\",
        EnableGeckoProfilingWithSlowAssertions, 0, 0,\n\"enableGeckoProfilingWithSlowAssertions()\",\n\"
        \ Enables Gecko Profiler instrumentation and corresponding assertions, with
        slow\\n\"\n\"  assertions enabled.\\n\"),\n\n    JS_FN_HELP(\"disableGeckoProfiling\",
        DisableGeckoProfiling, 0, 0,\n\"disableGeckoProfiling()\",\n\"  Disables Gecko
        Profiler instrumentation\"),\n\n    JS_FN_HELP(\"isLatin1\", IsLatin1, 1,
        0,\n\"isLatin1(s)\",\n\"  Return true iff the string's characters are stored
        as Latin1.\"),\n\n    JS_FN_HELP(\"stackPointerInfo\", StackPointerInfo, 0,
        0,\n\"stackPointerInfo()\",\n\"  Return an int32 value which corresponds to
        the offset of the latest stack\\n\"\n\"  pointer, such that one can take the
        differences of 2 to estimate a frame-size.\"),\n\n    JS_FN_HELP(\"entryPoints\",
        EntryPoints, 1, 0,\n\"entryPoints(params)\",\n\"Carry out some JSAPI operation
        as directed by |params|, and return an array of\\n\"\n\"objects describing
        which JavaScript entry points were invoked as a result.\\n\"\n\"|params| is
        an object whose properties indicate what operation to perform. Here\\n\"\n\"are
        the recognized groups of properties:\\n\"\n\"\\n\"\n\"{ function }: Call the
        object |params.function| with no arguments.\\n\"\n\"\\n\"\n\"{ object, property
        }: Fetch the property named |params.property| of\\n\"\n\"|params.object|.\\n\"\n\"\\n\"\n\"{
        ToString }: Apply JS::ToString to |params.toString|.\\n\"\n\"\\n\"\n\"{ ToNumber
        }: Apply JS::ToNumber to |params.toNumber|.\\n\"\n\"\\n\"\n\"{ eval }: Apply
        JS::Evaluate to |params.eval|.\\n\"\n\"\\n\"\n\"The return value is an array
        of strings, with one element for each\\n\"\n\"JavaScript invocation that occurred
        as a result of the given\\n\"\n\"operation. Each element is the name of the
        function invoked, or the\\n\"\n\"string 'eval:FILENAME' if the code was invoked
        by 'eval' or something\\n\"\n\"similar.\\n\"),\n\n    JS_FN_HELP(\"enqueueJob\",
        EnqueueJob, 1, 0,\n\"enqueueJob(fn)\",\n\"  Enqueue 'fn' on the shell's job
        queue.\"),\n\n    JS_FN_HELP(\"globalOfFirstJobInQueue\", GlobalOfFirstJobInQueue,
        0, 0,\n\"globalOfFirstJobInQueue()\",\n\"  Returns the global of the first
        item in the job queue. Throws an exception\\n\"\n\"  if the queue is empty.\\n\"),\n\n
        \   JS_FN_HELP(\"drainJobQueue\", DrainJobQueue, 0, 0,\n\"drainJobQueue()\",\n\"Take
        jobs from the shell's job queue in FIFO order and run them until the\\n\"\n\"queue
        is empty.\\n\"),\n\n    JS_FN_HELP(\"setPromiseRejectionTrackerCallback\",
        SetPromiseRejectionTrackerCallback, 1, 0,\n\"setPromiseRejectionTrackerCallback()\",\n\"Sets
        the callback to be invoked whenever a Promise rejection is unhandled\\n\"\n\"or
        a previously-unhandled rejection becomes handled.\"),\n\n    JS_FN_HELP(\"dumpScopeChain\",
        DumpScopeChain, 1, 0,\n\"dumpScopeChain(obj)\",\n\"  Prints the scope chain
        of an interpreted function or a module.\"),\n\n    JS_FN_HELP(\"blackRoot\",
        EnsureBlackRoot, 0, 0,\n\"blackRoot()\",\n\"  Return an array in the current
        compartment whose elements will be marked\\n\"\n\"  as black roots by the
        GC.\"),\n\n    JS_FN_HELP(\"grayRoot\", EnsureGrayRoot, 0, 0,\n\"grayRoot()\",\n\"
        \ Return an array in the current compartment whose elements will be marked\\n\"\n\"
        \ as gray roots by the GC.\"),\n\n    JS_FN_HELP(\"addMarkObservers\", AddMarkObservers,
        1, 0,\n\"addMarkObservers(array_of_objects)\",\n\"  Register an array of objects
        whose mark bits will be tested by calls to\\n\"\n\"  getMarks. The objects
        will be in calling compartment. Objects from\\n\"\n\"  multiple compartments
        may be monitored by calling this function in\\n\"\n\"  different compartments.\"),\n\n
        \   JS_FN_HELP(\"clearMarkObservers\", ClearMarkObservers, 1, 0,\n\"clearMarkObservers()\",\n\"
        \ Clear out the list of objects whose mark bits will be tested.\\n\"),\n\n
        \   JS_FN_HELP(\"getMarks\", GetMarks, 0, 0,\n\"getMarks()\",\n\"  Return
        an array of strings representing the current state of the mark\\n\"\n\"  bits
        ('gray' or 'black', or 'dead' if the object has been collected)\\n\"\n\"  for
        the objects registered via addMarkObservers. Note that some of the\\n\"\n\"
        \ objects tested may be from different compartments than the one in which\\n\"\n\"
        \ this function runs.\"),\n\n    JS_FN_HELP(\"bindToAsyncStack\", BindToAsyncStack,
        2, 0,\n\"bindToAsyncStack(fn, { stack, cause, explicit })\",\n\"  Returns
        a new function that calls 'fn' with no arguments, passing\\n\"\n\"  'undefined'
        as the 'this' value, and supplies an async stack for the\\n\"\n\"  call as
        described by the second argument, an object with the following\\n\"\n\"  properties
        (which are not optional, unless specified otherwise):\\n\"\n\"\\n\"\n\"  stack:
        \   A SavedFrame object, like that returned by 'saveStack'. Stacks\\n\"\n\"
        \           captured during calls to the returned function capture this as\\n\"\n\"
        \           their async stack parent, accessible via a SavedFrame's\\n\"\n\"
        \           'asyncParent' property.\\n\"\n\"\\n\"\n\"  cause:    A string,
        supplied as the async cause on the top frame of\\n\"\n\"            captured
        async stacks.\\n\"\n\"\\n\"\n\"  explicit: A boolean value, indicating whether
        the given 'stack' should\\n\"\n\"            always supplant the returned
        function's true callers (true),\\n\"\n\"            or only when there are
        no other JavaScript frames on the stack\\n\"\n\"            below it (false).
        If omitted, this is treated as 'true'.\"),\n\n#ifdef JS_HAS_INTL_API\n    JS_FN_HELP(\"addIntlExtras\",
        AddIntlExtras, 1, 0,\n\"addIntlExtras(obj)\",\n\"Adds various not-yet-standardized
        Intl functions as properties on the\\n\"\n\"provided object (this should generally
        be Intl itself).  The added\\n\"\n\"functions and their behavior are experimental:
        don't depend upon them\\n\"\n\"unless you're willing to update your code if
        these experimental APIs change\\n\"\n\"underneath you.\"),\n#endif // JS_HAS_INTL_API\n\n#ifndef
        __wasi__\n    JS_FN_HELP(\"wasmCompileInSeparateProcess\", WasmCompileInSeparateProcess,
        1, 0,\n\"wasmCompileInSeparateProcess(buffer)\",\n\"  Compile the given buffer
        in a separate process, serialize the resulting\\n\"\n\"  wasm::Module into
        bytes, and deserialize those bytes in the current\\n\"\n\"  process, returning
        the resulting WebAssembly.Module.\"),\n\n    JS_FN_HELP(\"wasmTextToBinary\",
        WasmTextToBinary, 1, 0,\n\"wasmTextToBinary(str)\",\n\"  Translates the given
        text wasm module into its binary encoding.\"),\n#endif // __wasi__\n\n    JS_FN_HELP(\"transplantableObject\",
        TransplantableObject, 0, 0,\n\"transplantableObject([options])\",\n\"  Returns
        the pair {object, transplant}. |object| is an object which can be\\n\"\n\"
        \ transplanted into a new object when the |transplant| function, which must\\n\"\n\"
        \ be invoked with a global object, is called.\\n\"\n\"  |object| is swapped
        with a cross-compartment wrapper if the global object\\n\"\n\"  is in a different
        compartment.\\n\"\n\"\\n\"\n\"  If options is given, it may have any of the
        following properties:\\n\"\n\"    proxy: Create a DOM Proxy object instead
        of a plain DOM object.\\n\"\n\"    object: Don't create a new DOM object,
        but instead use the supplied\\n\"\n\"            FakeDOMObject.\"),\n\n    JS_FN_HELP(\"cpuNow\",
        CpuNow, /* nargs= */ 0, /* flags = */ 0,\n\"cpuNow()\",\n\" Returns the approximate
        processor time used by the process since an arbitrary epoch, in seconds.\\n\"\n\"
        Only the difference between two calls to `cpuNow()` is meaningful.\"),\n\n#ifdef
        FUZZING_JS_FUZZILLI\n    JS_FN_HELP(\"fuzzilli\", Fuzzilli, 0, 0,\n\"fuzzilli(operation,
        arg)\",\n\"  Exposes functionality used by the Fuzzilli JavaScript fuzzer.\"),\n#endif\n\n#ifdef
        FUZZING_INTERFACES\n    JS_FN_HELP(\"getWasmSmithModule\", GetWasmSmithModule,
        1, 0,\n\"getWasmSmithModule(arrayBuffer)\",\n\"  Call wasm-smith to generate
        a random wasm module from the provided data.\"),\n#endif\n\n    JS_FN_HELP(\"isValidJSON\",
        IsValidJSON, 1, 0,\n\"isValidJSON(source)\",\n\" Returns true if the given
        source is valid JSON.\"),\n\n    JS_FS_HELP_END\n};\n// clang-format on\n\n//
        clang-format off\n#ifdef FUZZING_JS_FUZZILLI\nstatic const JSFunctionSpec
        shell_function_fuzzilli_hash[] = {\n    JS_INLINABLE_FN(\"fuzzilli_hash\",
        fuzzilli_hash, 1, 0, FuzzilliHash),\n    JS_FS_END\n};\n#endif\n// clang-format
        on\n\n// clang-format off\nstatic const JSFunctionSpecWithHelp diff_testing_unsafe_functions[]
        = {\n\n    JS_FS_HELP_END\n};\n// clang-format on\n\n// clang-format off\nstatic
        const JSFunctionSpecWithHelp fuzzing_unsafe_functions[] = {\n    JS_FN_HELP(\"getSelfHostedValue\",
        GetSelfHostedValue, 1, 0,\n\"getSelfHostedValue()\",\n\"  Get a self-hosted
        value by its name. Note that these values don't get \\n\"\n\"  cached, so
        repeatedly getting the same value creates multiple distinct clones.\"),\n\n
        \   JS_FN_HELP(\"line2pc\", LineToPC, 0, 0,\n\"line2pc([fun,] line)\",\n\"
        \ Map line number to PC.\"),\n\n    JS_FN_HELP(\"pc2line\", PCToLine, 0, 0,\n\"pc2line(fun[,
        pc])\",\n\"  Map PC to line number.\"),\n\n    JS_INLINABLE_FN_HELP(\"assertFloat32\",
        testingFunc_assertFloat32, 2, 0, TestAssertFloat32,\n\"assertFloat32(value,
        isFloat32)\",\n\"  In IonMonkey only, asserts that value has (resp. hasn't)
        the MIRType::Float32 if isFloat32 is true (resp. false).\"),\n\n    JS_INLINABLE_FN_HELP(\"assertRecoveredOnBailout\",
        testingFunc_assertRecoveredOnBailout, 2, 0,\nTestAssertRecoveredOnBailout,\n\"assertRecoveredOnBailout(var)\",\n\"
        \ In IonMonkey only, asserts that variable has RecoveredOnBailout flag.\"),\n\n
        \   JS_FN_HELP(\"withSourceHook\", WithSourceHook, 1, 0,\n\"withSourceHook(hook,
        fun)\",\n\"  Set this JS runtime's lazy source retrieval hook (that is, the
        hook\\n\"\n\"  used to find sources compiled with |CompileOptions::LAZY_SOURCE|)
        to\\n\"\n\"  |hook|; call |fun| with no arguments; and then restore the runtime's\\n\"\n\"
        \ original hook. Return or throw whatever |fun| did. |hook| gets\\n\"\n\"
        \ passed the requested code's URL, and should return a string.\\n\"\n\"\\n\"\n\"
        \ Notes:\\n\"\n\"\\n\"\n\"  1) SpiderMonkey may assert if the returned code
        isn't close enough\\n\"\n\"  to the script's real code, so this function is
        not fuzzer-safe.\\n\"\n\"\\n\"\n\"  2) The runtime can have only one source
        retrieval hook active at a\\n\"\n\"  time. If |fun| is not careful, |hook|
        could be asked to retrieve the\\n\"\n\"  source code for compilations that
        occurred long before it was set,\\n\"\n\"  and that it knows nothing about.
        The reverse applies as well: the\\n\"\n\"  original hook, that we reinstate
        after the call to |fun| completes,\\n\"\n\"  might be asked for the source
        code of compilations that |fun|\\n\"\n\"  performed, and which, presumably,
        only |hook| knows how to find.\\n\"),\n\n    JS_FN_HELP(\"crash\", Crash,
        0, 0,\n\"crash([message, [{disable_minidump:true}]])\",\n\"  Crashes the process
        with a MOZ_CRASH, optionally providing a message.\\n\"\n\"  An options object
        may be passed as the second argument. If the key\\n\"\n\"  'suppress_minidump'
        is set to true, then a minidump will not be\\n\"\n\"  generated by the crash
        (which only has an effect if the breakpad\\n\"\n\"  dumping library is loaded.)\"),\n\n#ifndef
        __wasi__\n    JS_FN_HELP(\"wasmLoop\", WasmLoop, 2, 0,\n\"wasmLoop(filename,
        imports)\",\n\"  Performs an AFL-style persistent loop reading data from the
        given file and passing it\\n\"\n\"  to the 'wasmEval' function together with
        the specified imports object.\"),\n#endif // __wasi__\n\n    JS_FN_HELP(\"setBufferStreamParams\",
        SetBufferStreamParams, 2, 0,\n\"setBufferStreamParams(delayMillis, chunkByteSize)\",\n\"
        \ Set the delay time (between calls to StreamConsumer::consumeChunk) and chunk\\n\"\n\"
        \ size (in bytes).\"),\n\n#ifdef JS_CACHEIR_SPEW\n  JS_FN_HELP(\"cacheIRHealthReport\",
        CacheIRHealthReport, 0, 0,\n\"cacheIRHealthReport()\",\n\"  Show health rating
        of CacheIR stubs.\"),\n#endif\n\n#ifdef DEBUG\n  JS_FN_HELP(\"debugGetQueuedJobs\",
        DebugGetQueuedJobs, 0, 0,\n\"debugGetQueuedJobs()\",\n\"  Returns an array
        of queued jobs.\"),\n#endif\n\n    JS_FS_HELP_END\n};\n// clang-format on\n\n//
        clang-format off\nstatic const JSFunctionSpecWithHelp performance_functions[]
        = {\n    JS_FN_HELP(\"now\", Now, 0, 0,\n\"now()\",\n\"  Return the current
        time with sub-ms precision.\\n\"\n\"  This function is an alias of the dateNow()
        function.\"),\n    JS_FS_HELP_END\n};\n// clang-format on\n\n// clang-format
        off\nstatic const JSFunctionSpecWithHelp console_functions[] = {\n    JS_FN_HELP(\"log\",
        Print, 0, 0,\n\"log([exp ...])\",\n\"  Evaluate and print expressions to stdout.\\n\"\n\"
        \ This function is an alias of the print() function.\"),\n    JS_FS_HELP_END\n};\n//
        clang-format on\n\nbool DefineConsole(JSContext* cx, HandleObject global)
        {\n  RootedObject obj(cx, JS_NewPlainObject(cx));\n  return obj && JS_DefineFunctionsWithHelp(cx,
        obj, console_functions) &&\n         JS_DefineProperty(cx, global, \"console\",
        obj, 0);\n}\n\n#ifdef MOZ_PROFILING\n#  define PROFILING_FUNCTION_COUNT 5\n#
        \ ifdef MOZ_CALLGRIND\n#    define CALLGRIND_FUNCTION_COUNT 3\n#  else\n#
        \   define CALLGRIND_FUNCTION_COUNT 0\n#  endif\n#  ifdef MOZ_VTUNE\n#    define
        VTUNE_FUNCTION_COUNT 4\n#  else\n#    define VTUNE_FUNCTION_COUNT 0\n#  endif\n#
        \ define EXTERNAL_FUNCTION_COUNT \\\n    (PROFILING_FUNCTION_COUNT + CALLGRIND_FUNCTION_COUNT
        + VTUNE_FUNCTION_COUNT)\n#else\n#  define EXTERNAL_FUNCTION_COUNT 0\n#endif\n\n#undef
        PROFILING_FUNCTION_COUNT\n#undef CALLGRIND_FUNCTION_COUNT\n#undef VTUNE_FUNCTION_COUNT\n#undef
        EXTERNAL_FUNCTION_COUNT\n\nstatic bool PrintHelpString(JSContext* cx, HandleValue
        v) {\n  RootedString str(cx, v.toString());\n  MOZ_ASSERT(gOutFile->isOpen());\n\n
        \ UniqueChars bytes = JS_EncodeStringToUTF8(cx, str);\n  if (!bytes) {\n    return
        false;\n  }\n\n  fprintf(gOutFile->fp, \"%s\\n\", bytes.get());\n  return
        true;\n}\n\nstatic bool PrintHelp(JSContext* cx, HandleObject obj) {\n  RootedValue
        usage(cx);\n  if (!JS_GetProperty(cx, obj, \"usage\", &usage)) {\n    return
        false;\n  }\n  RootedValue help(cx);\n  if (!JS_GetProperty(cx, obj, \"help\",
        &help)) {\n    return false;\n  }\n\n  if (!usage.isString() || !help.isString())
        {\n    return true;\n  }\n\n  return PrintHelpString(cx, usage) && PrintHelpString(cx,
        help);\n}\n\nstatic bool PrintEnumeratedHelp(JSContext* cx, HandleObject obj,\n
        \                               HandleObject pattern, bool brief) {\n  RootedIdVector
        idv(cx);\n  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN,
        &idv)) {\n    return false;\n  }\n\n  Rooted<RegExpObject*> regex(cx);\n  if
        (pattern) {\n    regex = &UncheckedUnwrap(pattern)->as<RegExpObject>();\n
        \ }\n\n  for (size_t i = 0; i < idv.length(); i++) {\n    RootedValue v(cx);\n
        \   RootedId id(cx, idv[i]);\n    if (!JS_GetPropertyById(cx, obj, id, &v))
        {\n      return false;\n    }\n    if (!v.isObject()) {\n      continue;\n
        \   }\n\n    RootedObject funcObj(cx, &v.toObject());\n    if (regex) {\n
        \     // Only pay attention to objects with a 'help' property, which will\n
        \     // either be documented functions or interface objects.\n      if (!JS_GetProperty(cx,
        funcObj, \"help\", &v)) {\n        return false;\n      }\n      if (!v.isString())
        {\n        continue;\n      }\n\n      // For functions, match against the
        name. For interface objects,\n      // match against the usage string.\n      if
        (!JS_GetProperty(cx, funcObj, \"name\", &v)) {\n        return false;\n      }\n
        \     if (!v.isString()) {\n        if (!JS_GetProperty(cx, funcObj, \"usage\",
        &v)) {\n          return false;\n        }\n        if (!v.isString()) {\n
        \         continue;\n        }\n      }\n\n      Rooted<JSString*> inputStr(cx,
        v.toString());\n      if (!inputStr->ensureLinear(cx)) {\n        return false;\n
        \     }\n\n      // Execute the regular expression in |regex|'s compartment.\n
        \     AutoRealm ar(cx, regex);\n      if (!cx->compartment()->wrap(cx, &inputStr))
        {\n        return false;\n      }\n      Rooted<JSLinearString*> input(cx,
        &inputStr->asLinear());\n      size_t ignored = 0;\n      if (!ExecuteRegExpLegacy(cx,
        nullptr, regex, input, &ignored, true, &v)) {\n        return false;\n      }\n
        \     if (v.isNull()) {\n        continue;\n      }\n    }\n\n    if (!PrintHelp(cx,
        funcObj)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nstatic
        bool Help(JSContext* cx, unsigned argc, Value* vp) {\n  if (!gOutFile->isOpen())
        {\n    JS_ReportErrorASCII(cx, \"output file is closed\");\n    return false;\n
        \ }\n\n  CallArgs args = CallArgsFromVp(argc, vp);\n  args.rval().setUndefined();\n
        \ RootedObject global(cx, JS::CurrentGlobalOrNull(cx));\n\n  // help() - display
        the version and dump out help for all functions on the\n  // global.\n  if
        (args.length() == 0) {\n    fprintf(gOutFile->fp, \"%s\\n\", JS_GetImplementationVersion());\n\n
        \   if (!PrintEnumeratedHelp(cx, global, nullptr, false)) {\n      return
        false;\n    }\n    return true;\n  }\n\n  RootedValue v(cx);\n\n  if (args[0].isPrimitive())
        {\n    // help(\"foo\")\n    JS_ReportErrorASCII(cx, \"primitive arg\");\n
        \   return false;\n  }\n\n  RootedObject obj(cx, &args[0].toObject());\n  if
        (!obj) {\n    return true;\n  }\n  bool isRegexp;\n  if (!JS::ObjectIsRegExp(cx,
        obj, &isRegexp)) {\n    return false;\n  }\n\n  if (isRegexp) {\n    // help(/pattern/)\n
        \   return PrintEnumeratedHelp(cx, global, obj, false);\n  }\n\n  // help(function)\n
        \ // help(namespace_obj)\n  return PrintHelp(cx, obj);\n}\n\nstatic const
        JSErrorFormatString jsShell_ErrorFormatString[JSShellErr_Limit] = {\n#define
        MSG_DEF(name, count, exception, format) \\\n  {#name, format, count, JSEXN_ERR},\n#include
        \"jsshell.msg\"\n#undef MSG_DEF\n};\n\nconst JSErrorFormatString* js::shell::my_GetErrorMessage(\n
        \   void* userRef, const unsigned errorNumber) {\n  if (errorNumber == 0 ||
        errorNumber >= JSShellErr_Limit) {\n    return nullptr;\n  }\n\n  return &jsShell_ErrorFormatString[errorNumber];\n}\n\nstatic
        bool CreateLastWarningObject(JSContext* cx, JSErrorReport* report) {\n  RootedObject
        warningObj(cx, JS_NewObject(cx, nullptr));\n  if (!warningObj) {\n    return
        false;\n  }\n\n  if (!CopyErrorReportToObject(cx, report, warningObj)) {\n
        \   return false;\n  }\n\n  GetShellContext(cx)->lastWarning.setObject(*warningObj);\n
        \ return true;\n}\n\nstatic FILE* ErrorFilePointer() {\n  if (gErrFile->isOpen())
        {\n    return gErrFile->fp;\n  }\n\n  fprintf(stderr, \"error file is closed;
        falling back to stderr\\n\");\n  return stderr;\n}\n\nbool shell::PrintStackTrace(JSContext*
        cx, HandleObject stackObj) {\n  if (!stackObj || !stackObj->is<SavedFrame>())
        {\n    return true;\n  }\n\n  JSPrincipals* principals = stackObj->nonCCWRealm()->principals();\n
        \ RootedString stackStr(cx);\n  if (!BuildStackString(cx, principals, stackObj,
        &stackStr, 2)) {\n    return false;\n  }\n\n  UniqueChars stack = JS_EncodeStringToUTF8(cx,
        stackStr);\n  if (!stack) {\n    return false;\n  }\n\n  FILE* fp = ErrorFilePointer();\n
        \ fputs(\"Stack:\\n\", fp);\n  fputs(stack.get(), fp);\n\n  return true;\n}\n\njs::shell::AutoReportException::~AutoReportException()
        {\n  if (!JS_IsExceptionPending(cx)) {\n    return;\n  }\n\n  auto printError
        = [](JSContext* cx, auto& report, const auto& exnStack,\n                       const
        char* prefix = nullptr) {\n    if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects))
        {\n      fprintf(stderr, \"out of memory initializing JS::ErrorReportBuilder\\n\");\n
        \     fflush(stderr);\n      JS_ClearPendingException(cx);\n      return false;\n
        \   }\n\n    MOZ_ASSERT(!report.report()->isWarning());\n\n    FILE* fp =
        ErrorFilePointer();\n    if (prefix) {\n      fputs(prefix, fp);\n    }\n
        \   JS::PrintError(fp, report, reportWarnings);\n    JS_ClearPendingException(cx);\n\n
        \   // If possible, use the original error stack as the source of truth, because\n
        \   // finally block handlers may have overwritten the exception stack.\n
        \   RootedObject stack(cx, exnStack.stack());\n    if (exnStack.exception().isObject())
        {\n      RootedObject exception(cx, &exnStack.exception().toObject());\n      if
        (JSObject* exceptionStack = JS::ExceptionStackOrNull(exception)) {\n        stack.set(exceptionStack);\n
        \     }\n    }\n\n    if (!PrintStackTrace(cx, stack)) {\n      fputs(\"(Unable
        to print stack trace)\\n\", fp);\n      JS_ClearPendingException(cx);\n    }\n\n
        \   return true;\n  };\n\n  // Get exception object and stack before printing
        and clearing exception.\n  JS::ExceptionStack exnStack(cx);\n  if (!JS::StealPendingExceptionStack(cx,
        &exnStack)) {\n    fprintf(stderr, \"out of memory while stealing exception\\n\");\n
        \   fflush(stderr);\n    JS_ClearPendingException(cx);\n    return;\n  }\n\n
        \ ShellContext* sc = GetShellContext(cx);\n  JS::ErrorReportBuilder report(cx);\n
        \ if (!printError(cx, report, exnStack)) {\n    // Return if we couldn't initialize
        the error report.\n    return;\n  }\n\n  // Print the error's cause, if available.\n
        \ if (exnStack.exception().isObject()) {\n    JSObject* exception = &exnStack.exception().toObject();\n
        \   if (exception->is<ErrorObject>()) {\n      auto* error = &exception->as<ErrorObject>();\n
        \     if (auto maybeCause = error->getCause()) {\n        RootedValue cause(cx,
        maybeCause.value());\n\n        RootedObject causeStack(cx);\n        if (cause.isObject())
        {\n          RootedObject causeObj(cx, &cause.toObject());\n          causeStack
        = JS::ExceptionStackOrNull(causeObj);\n        }\n\n        JS::ExceptionStack
        exnStack(cx, cause, causeStack);\n        JS::ErrorReportBuilder report(cx);\n
        \       printError(cx, report, exnStack, \"Caused by: \");\n      }\n    }\n
        \ }\n\n#if defined(DEBUG) || defined(JS_OOM_BREAKPOINT)\n  // Don't quit the
        shell if an unhandled exception is reported during OOM\n  // testing.\n  if
        (cx->runningOOMTest) {\n    return;\n  }\n#endif\n\n  if (report.report()->errorNumber
        == JSMSG_OUT_OF_MEMORY) {\n    sc->exitCode = EXITCODE_OUT_OF_MEMORY;\n  }
        else {\n    sc->exitCode = EXITCODE_RUNTIME_ERROR;\n  }\n}\n\nvoid js::shell::WarningReporter(JSContext*
        cx, JSErrorReport* report) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ FILE* fp = ErrorFilePointer();\n\n  MOZ_ASSERT(report->isWarning());\n\n
        \ if (sc->lastWarningEnabled) {\n    JS::AutoSaveExceptionState savedExc(cx);\n
        \   if (!CreateLastWarningObject(cx, report)) {\n      fputs(\"Unhandled error
        happened while creating last warning object.\\n\",\n            fp);\n      fflush(fp);\n
        \   }\n    savedExc.restore();\n  }\n\n  // Print the warning.\n  JS::PrintError(fp,
        report, reportWarnings);\n}\n\nstatic bool global_enumerate(JSContext* cx,
        JS::HandleObject obj,\n                             JS::MutableHandleIdVector
        properties,\n                             bool enumerableOnly) {\n#ifdef LAZY_STANDARD_CLASSES\n
        \ return JS_NewEnumerateStandardClasses(cx, obj, properties, enumerableOnly);\n#else\n
        \ return true;\n#endif\n}\n\nstatic bool global_resolve(JSContext* cx, HandleObject
        obj, HandleId id,\n                           bool* resolvedp) {\n#ifdef LAZY_STANDARD_CLASSES\n
        \ if (!JS_ResolveStandardClass(cx, obj, id, resolvedp)) {\n    return false;\n
        \ }\n#endif\n  return true;\n}\n\nstatic bool global_mayResolve(const JSAtomState&
        names, jsid id,\n                              JSObject* maybeObj) {\n  return
        JS_MayResolveStandardClass(names, id, maybeObj);\n}\n\nstatic const JSClassOps
        global_classOps = {\n    nullptr,                   // addProperty\n    nullptr,
        \                  // delProperty\n    nullptr,                   // enumerate\n
        \   global_enumerate,          // newEnumerate\n    global_resolve,            //
        resolve\n    global_mayResolve,         // mayResolve\n    nullptr,                   //
        finalize\n    nullptr,                   // call\n    nullptr,                   //
        construct\n    JS_GlobalObjectTraceHook,  // trace\n};\n\nstatic constexpr
        uint32_t DOM_PROTOTYPE_SLOT = JSCLASS_GLOBAL_SLOT_COUNT;\nstatic constexpr
        uint32_t DOM_GLOBAL_SLOTS = 1;\n\nstatic const JSClass global_class = {\n
        \   \"global\",\n    JSCLASS_GLOBAL_FLAGS | JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(DOM_GLOBAL_SLOTS),\n
        \   &global_classOps};\n\n/*\n * Define a FakeDOMObject constructor. It returns
        an object with a getter,\n * setter and method with attached JitInfo. This
        object can be used to test\n * IonMonkey DOM optimizations in the shell.\n
        */\n\n/* Fow now just use to a constant we can check. */\nstatic const void*
        DOM_PRIVATE_VALUE = (void*)0x1234;\n\nstatic bool dom_genericGetter(JSContext*
        cx, unsigned argc, JS::Value* vp);\n\nstatic bool dom_genericSetter(JSContext*
        cx, unsigned argc, JS::Value* vp);\n\nstatic bool dom_genericMethod(JSContext*
        cx, unsigned argc, JS::Value* vp);\n\nstatic bool dom_get_x(JSContext* cx,
        HandleObject obj, void* self,\n                      JSJitGetterCallArgs args)
        {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self ==
        DOM_PRIVATE_VALUE);\n  args.rval().set(JS_NumberValue(double(3.14)));\n  return
        true;\n}\n\nstatic bool dom_set_x(JSContext* cx, HandleObject obj, void* self,\n
        \                     JSJitSetterCallArgs args) {\n  MOZ_ASSERT(JS::GetClass(obj)
        == GetDomClass());\n  MOZ_ASSERT(self == DOM_PRIVATE_VALUE);\n  return true;\n}\n\nstatic
        bool dom_get_slot(JSContext* cx, HandleObject obj, void* self,\n                         JSJitGetterCallArgs
        args) {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self
        == DOM_PRIVATE_VALUE);\n\n  Value v = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT2);\n
        \ MOZ_ASSERT(v.toInt32() == 42);\n  args.rval().set(v);\n  return true;\n}\n\nstatic
        bool dom_get_global(JSContext* cx, HandleObject obj, void* self,\n                           JSJitGetterCallArgs
        args) {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self
        == DOM_PRIVATE_VALUE);\n\n  // Return the current global (instead of obj->global())
        to test cx->realm\n  // switching in the JIT.\n  args.rval().setObject(*ToWindowProxyIfWindow(cx->global()));\n\n
        \ return true;\n}\n\nstatic bool dom_set_global(JSContext* cx, HandleObject
        obj, void* self,\n                           JSJitSetterCallArgs args) {\n
        \ MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self == DOM_PRIVATE_VALUE);\n\n
        \ // Throw an exception if our argument is not the current global. This lets\n
        \ // us test cx->realm switching.\n  if (!args[0].isObject() ||\n      ToWindowIfWindowProxy(&args[0].toObject())
        != cx->global()) {\n    JS_ReportErrorASCII(cx, \"Setter not called with matching
        global argument\");\n    return false;\n  }\n\n  return true;\n}\n\nstatic
        bool dom_doFoo(JSContext* cx, HandleObject obj, void* self,\n                      const
        JSJitMethodCallArgs& args) {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n
        \ MOZ_ASSERT(self == DOM_PRIVATE_VALUE);\n  MOZ_ASSERT(cx->realm() == args.callee().as<JSFunction>().realm());\n\n
        \ /* Just return args.length(). */\n  args.rval().setInt32(args.length());\n
        \ return true;\n}\n\nstatic const JSJitInfo dom_x_getterinfo = {\n    {(JSJitGetterOp)dom_get_x},\n
        \   {0}, /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Getter,\n    JSJitInfo::AliasNone,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,   /* returnType */\n    true,                 /*
        isInfallible. False in setters. */\n    true,                 /* isMovable
        */\n    true,                 /* isEliminatable */\n    false,                /*
        isAlwaysInSlot */\n    false,                /* isLazilyCachedInSlot */\n
        \   false,                /* isTypedMethod */\n    0                     /*
        slotIndex */\n};\n\nstatic const JSJitInfo dom_x_setterinfo = {\n    {(JSJitGetterOp)dom_set_x},\n
        \   {0}, /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Setter,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,         /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable. */\n    false,                      /* isEliminatable. */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSJitInfo
        dom_slot_getterinfo = {\n    {(JSJitGetterOp)dom_get_slot},\n    {0}, /* protoID
        */\n    {0}, /* depth */\n    JSJitInfo::Getter,\n    JSJitInfo::AliasNone,
        /* aliasSet */\n    JSVAL_TYPE_INT32,     /* returnType */\n    false,                /*
        isInfallible. False in setters. */\n    true,                 /* isMovable
        */\n    true,                 /* isEliminatable */\n    true,                 /*
        isAlwaysInSlot */\n    false,                /* isLazilyCachedInSlot */\n
        \   false,                /* isTypedMethod */\n    DOM_OBJECT_SLOT2      /*
        slotIndex */\n};\n\n// Note: this getter uses AliasEverything and is marked
        as fallible and\n// non-movable (1) to prevent Ion from getting too clever
        optimizing it and\n// (2) it's nice to have a few different kinds of getters
        in the shell.\nstatic const JSJitInfo dom_global_getterinfo = {\n    {(JSJitGetterOp)dom_get_global},\n
        \   {0}, /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Getter,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_OBJECT,          /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable */\n    false,                      /* isEliminatable */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSJitInfo
        dom_global_setterinfo = {\n    {(JSJitGetterOp)dom_set_global},\n    {0},
        /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Setter,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,         /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable. */\n    false,                      /* isEliminatable. */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSJitInfo
        doFoo_methodinfo = {\n    {(JSJitGetterOp)dom_doFoo},\n    {0}, /* protoID
        */\n    {0}, /* depth */\n    JSJitInfo::Method,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,         /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable */\n    false,                      /* isEliminatable */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSPropertySpec
        dom_props[] = {\n    JSPropertySpec::nativeAccessors(\"x\", JSPROP_ENUMERATE,
        dom_genericGetter,\n                                    &dom_x_getterinfo,
        dom_genericSetter,\n                                    &dom_x_setterinfo),\n
        \   JSPropertySpec::nativeAccessors(\"slot\", JSPROP_ENUMERATE, dom_genericGetter,\n
        \                                   &dom_slot_getterinfo),\n    JSPropertySpec::nativeAccessors(\"global\",
        JSPROP_ENUMERATE,\n                                    dom_genericGetter,
        &dom_global_getterinfo,\n                                    dom_genericSetter,
        &dom_global_setterinfo),\n    JS_PS_END};\n\nstatic const JSFunctionSpec dom_methods[]
        = {\n    JS_FNINFO(\"doFoo\", dom_genericMethod, &doFoo_methodinfo, 3,\n              JSPROP_ENUMERATE),\n
        \   JS_FS_END};\n\nstatic const JSClass dom_class = {\n    \"FakeDOMObject\",
        JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2)};\n\nstatic const JSClass*
        GetDomClass() { return &dom_class; }\n\nstatic bool dom_genericGetter(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (!args.thisv().isObject()) {\n    args.rval().setUndefined();\n
        \   return true;\n  }\n\n  RootedObject obj(cx, &args.thisv().toObject());\n
        \ if (JS::GetClass(obj) != &dom_class) {\n    args.rval().set(UndefinedValue());\n
        \   return true;\n  }\n\n  JS::Value val = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT);\n\n
        \ const JSJitInfo* info = FUNCTION_VALUE_TO_JITINFO(args.calleev());\n  MOZ_ASSERT(info->type()
        == JSJitInfo::Getter);\n  JSJitGetterOp getter = info->getter;\n  return getter(cx,
        obj, val.toPrivate(), JSJitGetterCallArgs(args));\n}\n\nstatic bool dom_genericSetter(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (args.length() < 1 || !args.thisv().isObject()) {\n    args.rval().setUndefined();\n
        \   return true;\n  }\n\n  RootedObject obj(cx, &args.thisv().toObject());\n
        \ if (JS::GetClass(obj) != &dom_class) {\n    args.rval().set(UndefinedValue());\n
        \   return true;\n  }\n\n  JS::Value val = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT);\n\n
        \ const JSJitInfo* info = FUNCTION_VALUE_TO_JITINFO(args.calleev());\n  MOZ_ASSERT(info->type()
        == JSJitInfo::Setter);\n  JSJitSetterOp setter = info->setter;\n  if (!setter(cx,
        obj, val.toPrivate(), JSJitSetterCallArgs(args))) {\n    return false;\n  }\n
        \ args.rval().set(UndefinedValue());\n  return true;\n}\n\nstatic bool dom_genericMethod(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (!args.thisv().isObject()) {\n    args.rval().setUndefined();\n
        \   return true;\n  }\n\n  RootedObject obj(cx, &args.thisv().toObject());\n
        \ if (JS::GetClass(obj) != &dom_class) {\n    args.rval().set(UndefinedValue());\n
        \   return true;\n  }\n\n  JS::Value val = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT);\n\n
        \ const JSJitInfo* info = FUNCTION_VALUE_TO_JITINFO(args.calleev());\n  MOZ_ASSERT(info->type()
        == JSJitInfo::Method);\n  JSJitMethodOp method = info->method;\n  return method(cx,
        obj, val.toPrivate(), JSJitMethodCallArgs(args));\n}\n\nstatic void InitDOMObject(HandleObject
        obj) {\n  JS::SetReservedSlot(obj, DOM_OBJECT_SLOT,\n                      PrivateValue(const_cast<void*>(DOM_PRIVATE_VALUE)));\n
        \ JS::SetReservedSlot(obj, DOM_OBJECT_SLOT2, Int32Value(42));\n}\n\nstatic
        JSObject* GetDOMPrototype(JSContext* cx, JSObject* global) {\n  MOZ_ASSERT(JS_IsGlobalObject(global));\n
        \ if (JS::GetClass(global) != &global_class) {\n    JS_ReportErrorASCII(cx,
        \"Can't get FakeDOMObject prototype in sandbox\");\n    return nullptr;\n
        \ }\n\n  const JS::Value& slot = JS::GetReservedSlot(global, DOM_PROTOTYPE_SLOT);\n
        \ MOZ_ASSERT(slot.isObject());\n  return &slot.toObject();\n}\n\nstatic bool
        dom_constructor(JSContext* cx, unsigned argc, JS::Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  RootedObject callee(cx, &args.callee());\n
        \ RootedValue protov(cx);\n  if (!GetProperty(cx, callee, callee, cx->names().prototype,
        &protov)) {\n    return false;\n  }\n\n  if (!protov.isObject()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_BAD_PROTOTYPE,\n                              \"FakeDOMObject\");\n
        \   return false;\n  }\n\n  RootedObject proto(cx, &protov.toObject());\n
        \ RootedObject domObj(cx, JS_NewObjectWithGivenProto(cx, &dom_class, proto));\n
        \ if (!domObj) {\n    return false;\n  }\n\n  InitDOMObject(domObj);\n\n  args.rval().setObject(*domObj);\n
        \ return true;\n}\n\nstatic bool InstanceClassHasProtoAtDepth(const JSClass*
        clasp, uint32_t protoID,\n                                         uint32_t
        depth) {\n  // Only the (fake) DOM object supports any JIT optimizations.\n
        \ return clasp == GetDomClass();\n}\n\nstatic bool ShellBuildId(JS::BuildIdCharVector*
        buildId) {\n  // The browser embeds the date into the buildid and the buildid
        is embedded\n  // in the binary, so every 'make' necessarily builds a new
        firefox binary.\n  // Fortunately, the actual firefox executable is tiny --
        all the code is in\n  // libxul.so and other shared modules -- so this isn't
        a big deal. Not so\n  // for the statically-linked JS shell. To avoid recompiling
        js.cpp and\n  // re-linking 'js' on every 'make', we use a constant buildid
        and rely on\n  // the shell user to manually clear any caches between cache-breaking
        updates.\n  const char buildid[] = \"JS-shell\";\n  return buildId->append(buildid,
        sizeof(buildid));\n}\n\nstatic bool TimesAccessed(JSContext* cx, unsigned
        argc, Value* vp) {\n  static int32_t accessed = 0;\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  args.rval().setInt32(++accessed);\n  return true;\n}\n\nstatic const
        JSPropertySpec TestingProperties[] = {\n    JS_PSG(\"timesAccessed\", TimesAccessed,
        0), JS_PS_END};\n\nstatic JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions&
        options,\n                                 JSPrincipals* principals, ShellGlobalKind
        kind,\n                                 bool immutablePrototype) {\n  RootedObject
        glob(cx,\n                    JS_NewGlobalObject(cx, &global_class, principals,\n
        \                                      JS::DontFireOnNewGlobalHook, options));\n
        \ if (!glob) {\n    return nullptr;\n  }\n\n  {\n    JSAutoRealm ar(cx, glob);\n\n
        \   if (kind == ShellGlobalKind::WindowProxy) {\n      RootedObject proxy(cx,
        NewShellWindowProxy(cx, glob));\n      if (!proxy) {\n        return nullptr;\n
        \     }\n      js::SetWindowProxy(cx, glob, proxy);\n    }\n\n#ifndef LAZY_STANDARD_CLASSES\n
        \   if (!JS::InitRealmStandardClasses(cx)) {\n      return nullptr;\n    }\n#endif\n\n
        \   if (immutablePrototype) {\n      bool succeeded;\n      if (!JS_SetImmutablePrototype(cx,
        glob, &succeeded)) {\n        return nullptr;\n      }\n      MOZ_ASSERT(succeeded,\n
        \                \"a fresh, unexposed global object is always capable of \"\n
        \                \"having its [[Prototype]] be immutable\");\n    }\n\n#ifdef
        JS_HAS_CTYPES\n    if (!fuzzingSafe && !JS::InitCTypesClass(cx, glob)) {\n
        \     return nullptr;\n    }\n#endif\n    if (!JS_InitReflectParse(cx, glob))
        {\n      return nullptr;\n    }\n    if (!JS_DefineDebuggerObject(cx, glob))
        {\n      return nullptr;\n    }\n    if (!JS_DefineFunctionsWithHelp(cx, glob,
        shell_functions) ||\n        !JS_DefineProfilingFunctions(cx, glob)) {\n      return
        nullptr;\n    }\n#ifdef FUZZING_JS_FUZZILLI\n    if (!JS_DefineFunctions(cx,
        glob, shell_function_fuzzilli_hash)) {\n      return nullptr;\n    }\n#endif\n
        \   if (!js::DefineTestingFunctions(cx, glob, fuzzingSafe,\n                                    disableOOMFunctions))
        {\n      return nullptr;\n    }\n    if (!JS_DefineProperties(cx, glob, TestingProperties))
        {\n      return nullptr;\n    }\n\n    if (!fuzzingSafe) {\n      if (!JS_DefineFunctionsWithHelp(cx,
        glob, fuzzing_unsafe_functions)) {\n        return nullptr;\n      }\n      if
        (!DefineConsole(cx, glob)) {\n        return nullptr;\n      }\n    }\n\n
        \   if (!DefineOS(cx, glob, fuzzingSafe, &gOutFile, &gErrFile)) {\n      return
        nullptr;\n    }\n\n    if (!js::SupportDifferentialTesting()) {\n      if
        (!JS_DefineFunctionsWithHelp(cx, glob,\n                                      diff_testing_unsafe_functions))
        {\n        return nullptr;\n      }\n\n      RootedObject performanceObj(cx,
        JS_NewObject(cx, nullptr));\n      if (!performanceObj) {\n        return
        nullptr;\n      }\n      if (!JS_DefineFunctionsWithHelp(cx, performanceObj,\n
        \                                     performance_functions)) {\n        return
        nullptr;\n      }\n      RootedObject mozMemoryObj(cx, JS_NewObject(cx, nullptr));\n
        \     if (!mozMemoryObj) {\n        return nullptr;\n      }\n      RootedObject
        gcObj(cx, gc::NewMemoryInfoObject(cx));\n      if (!gcObj) {\n        return
        nullptr;\n      }\n      if (!JS_DefineProperty(cx, glob, \"performance\",
        performanceObj,\n                             JSPROP_ENUMERATE)) {\n        return
        nullptr;\n      }\n      if (!JS_DefineProperty(cx, performanceObj, \"mozMemory\",
        mozMemoryObj,\n                             JSPROP_ENUMERATE)) {\n        return
        nullptr;\n      }\n      if (!JS_DefineProperty(cx, mozMemoryObj, \"gc\",
        gcObj, JSPROP_ENUMERATE)) {\n        return nullptr;\n      }\n    }\n\n    /*
        Initialize FakeDOMObject. */\n    static const js::DOMCallbacks DOMcallbacks
        = {InstanceClassHasProtoAtDepth};\n    SetDOMCallbacks(cx, &DOMcallbacks);\n\n
        \   RootedObject domProto(\n        cx, JS_InitClass(cx, glob, &dom_class,
        nullptr, \"FakeDOMObject\",\n                         dom_constructor, 0,
        dom_props, dom_methods, nullptr,\n                         nullptr));\n    if
        (!domProto) {\n      return nullptr;\n    }\n\n    // FakeDOMObject.prototype
        is the only DOM object which needs to retrieved\n    // in the shell; store
        it directly instead of creating a separate layer\n    // (ProtoAndIfaceCache)
        as done in the browser.\n    JS::SetReservedSlot(glob, DOM_PROTOTYPE_SLOT,
        ObjectValue(*domProto));\n\n    /* Initialize FakeDOMObject.prototype */\n
        \   InitDOMObject(domProto);\n\n    if (!DefineToStringTag(cx, glob, cx->names().global))
        {\n      return nullptr;\n    }\n\n    JS_FireOnNewGlobalObject(cx, glob);\n
        \ }\n\n  return glob;\n}\n\nstatic bool BindScriptArgs(JSContext* cx, OptionParser*
        op) {\n  AutoReportException are(cx);\n\n  MultiStringRange msr = op->getMultiStringArg(\"scriptArgs\");\n
        \ RootedObject scriptArgs(cx);\n  scriptArgs = JS::NewArrayObject(cx, 0);\n
        \ if (!scriptArgs) {\n    return false;\n  }\n\n  if (!JS_DefineProperty(cx,
        cx->global(), \"scriptArgs\", scriptArgs, 0)) {\n    return false;\n  }\n\n
        \ for (size_t i = 0; !msr.empty(); msr.popFront(), ++i) {\n    const char*
        scriptArg = msr.front();\n    UniqueChars scriptArgUtf8 = JS::EncodeNarrowToUtf8(cx,
        scriptArg);\n    if (!scriptArgUtf8) {\n      return false;\n    }\n    RootedString
        str(cx, NewStringCopyUTF8(cx, scriptArgUtf8.get()));\n    if (!str || !JS_DefineElement(cx,
        scriptArgs, i, str, JSPROP_ENUMERATE)) {\n      return false;\n    }\n  }\n\n
        \ RootedValue scriptPathValue(cx);\n  if (const char* scriptPath = op->getStringArg(\"script\"))
        {\n    UniqueChars scriptPathUtf8 = JS::EncodeNarrowToUtf8(cx, scriptPath);\n
        \   if (!scriptPathUtf8) {\n      return false;\n    }\n    RootedString scriptPathString(cx,\n
        \                                 NewStringCopyUTF8(cx, scriptPathUtf8.get()));\n
        \   if (!scriptPathString) {\n      return false;\n    }\n    scriptPathValue
        = StringValue(scriptPathString);\n  } else {\n    scriptPathValue = UndefinedValue();\n
        \ }\n\n  if (!JS_DefineProperty(cx, cx->global(), \"scriptPath\", scriptPathValue,
        0)) {\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool OptionFailure(const
        char* option, const char* str) {\n  fprintf(stderr, \"Unrecognized option
        for %s: %s\\n\", option, str);\n  return false;\n}\n\ntemplate <typename...
        Ts>\nauto minVal(Ts... args);\ntemplate <typename T>\nauto minVal(T a) {\n
        \ return a;\n}\n\ntemplate <typename T, typename... Ts>\nauto minVal(T a,
        Ts... args) {\n  return std::min(a, minVal(args...));\n}\n\n[[nodiscard]]
        static bool ProcessArgs(JSContext* cx, OptionParser* op) {\n  ShellContext*
        sc = GetShellContext(cx);\n\n  /* |scriptArgs| gets bound on the global before
        any code is run. */\n  if (!BindScriptArgs(cx, op)) {\n    return false;\n
        \ }\n\n  MultiStringRange filePaths = op->getMultiStringOption('f');\n  MultiStringRange
        utf16FilePaths = op->getMultiStringOption('u');\n  MultiStringRange preludePaths
        = op->getMultiStringOption('p');\n  MultiStringRange codeChunks = op->getMultiStringOption('e');\n
        \ MultiStringRange modulePaths = op->getMultiStringOption('m');\n\n#ifdef
        FUZZING_JS_FUZZILLI\n  // Check for REPRL file source\n  if (op->getBoolOption(\"reprl\"))
        {\n    return FuzzilliReprlGetAndRun(cx);\n  }\n#endif /* FUZZING_JS_FUZZILLI
        */\n\n  if (filePaths.empty() && utf16FilePaths.empty() && codeChunks.empty()
        &&\n      modulePaths.empty() && !op->getStringArg(\"script\")) {\n    //
        Always use the interactive shell when -i is used. Without -i we let\n    //
        Process figure it out based on isatty.\n    bool forceTTY = op->getBoolOption('i');\n
        \   return Process(cx, nullptr, forceTTY, FileScript);\n  }\n\n  while (!preludePaths.empty()
        || !filePaths.empty() ||\n         !utf16FilePaths.empty() || !codeChunks.empty()
        ||\n         !modulePaths.empty()) {\n    size_t ppArgno = preludePaths.empty()
        ? SIZE_MAX : preludePaths.argno();\n    size_t fpArgno = filePaths.empty()
        ? SIZE_MAX : filePaths.argno();\n    size_t ufpArgno =\n        utf16FilePaths.empty()
        ? SIZE_MAX : utf16FilePaths.argno();\n    size_t ccArgno = codeChunks.empty()
        ? SIZE_MAX : codeChunks.argno();\n    size_t mpArgno = modulePaths.empty()
        ? SIZE_MAX : modulePaths.argno();\n    size_t minArgno = minVal(ppArgno, fpArgno,
        ufpArgno, ccArgno, mpArgno);\n\n    if (ppArgno == minArgno) {\n      UniqueChars
        path = JS::EncodeNarrowToUtf8(cx, preludePaths.front());\n      if (!path)
        {\n        return false;\n      }\n      if (!Process(cx, path.get(), false,
        PreludeScript)) {\n        return false;\n      }\n\n      preludePaths.popFront();\n
        \     continue;\n    }\n\n    if (fpArgno == minArgno) {\n      UniqueChars
        path = JS::EncodeNarrowToUtf8(cx, filePaths.front());\n      if (!path) {\n
        \       return false;\n      }\n      if (!Process(cx, path.get(), false,
        FileScript)) {\n        return false;\n      }\n\n      filePaths.popFront();\n
        \     continue;\n    }\n\n    if (ufpArgno == minArgno) {\n      UniqueChars
        path = JS::EncodeNarrowToUtf8(cx, utf16FilePaths.front());\n      if (!path)
        {\n        return false;\n      }\n      if (!Process(cx, path.get(), false,
        FileScriptUtf16)) {\n        return false;\n      }\n\n      utf16FilePaths.popFront();\n
        \     continue;\n    }\n\n    if (ccArgno == minArgno) {\n      UniqueChars
        code = JS::EncodeNarrowToUtf8(cx, codeChunks.front());\n      if (!code) {\n
        \       return false;\n      }\n\n      // Command line scripts are always
        parsed with full-parse to evaluate\n      // conditions which might filter
        code coverage conditions.\n      JS::CompileOptions opts(cx);\n      opts.setFileAndLine(\"-e\",
        1).setForceFullParse();\n\n      JS::SourceText<Utf8Unit> srcBuf;\n      if
        (!srcBuf.init(cx, code.get(), strlen(code.get()),\n                       JS::SourceOwnership::Borrowed))
        {\n        return false;\n      }\n\n      RootedValue rval(cx);\n      if
        (!JS::Evaluate(cx, opts, srcBuf, &rval)) {\n        return false;\n      }\n\n
        \     codeChunks.popFront();\n      if (sc->quitting) {\n        break;\n
        \     }\n\n      continue;\n    }\n\n    MOZ_ASSERT(mpArgno == minArgno);\n\n
        \   UniqueChars path = JS::EncodeNarrowToUtf8(cx, modulePaths.front());\n
        \   if (!path) {\n      return false;\n    }\n    if (!Process(cx, path.get(),
        false, FileModule)) {\n      return false;\n    }\n\n    modulePaths.popFront();\n
        \ }\n\n  if (sc->quitting) {\n    return false;\n  }\n\n  /* The |script|
        argument is processed after all options. */\n  if (const char* path = op->getStringArg(\"script\"))
        {\n    UniqueChars pathUtf8 = JS::EncodeNarrowToUtf8(cx, path);\n    if (!pathUtf8)
        {\n      return false;\n    }\n    if (!Process(cx, pathUtf8.get(), false,
        FileScript)) {\n      return false;\n    }\n  }\n\n  if (op->getBoolOption('i'))
        {\n    if (!Process(cx, nullptr, true, FileScript)) {\n      return false;\n
        \   }\n  }\n\n  return true;\n}\n\nstatic void SetWorkerContextOptions(JSContext*
        cx) {\n  // Copy option values from the main thread.\n  JS::ContextOptionsRef(cx)\n
        \     .setAsmJS(enableAsmJS)\n      .setWasm(enableWasm)\n      .setWasmBaseline(enableWasmBaseline)\n
        \     .setWasmIon(enableWasmOptimizing)\n#define WASM_FEATURE(NAME, ...) .setWasm##NAME(enableWasm##NAME)\n
        \         JS_FOR_WASM_FEATURES(WASM_FEATURE, WASM_FEATURE, WASM_FEATURE)\n#undef
        WASM_FEATURE\n\n      .setWasmVerbose(enableWasmVerbose)\n      .setTestWasmAwaitTier2(enableTestWasmAwaitTier2)\n
        \     .setSourcePragmas(enableSourcePragmas);\n\n  cx->runtime()->setOffthreadIonCompilationEnabled(offthreadCompilation);\n
        \ cx->runtime()->profilingScripts =\n      enableCodeCoverage || enableDisassemblyDumps;\n\n#ifdef
        JS_GC_ZEAL\n  if (gZealBits && gZealFrequency) {\n    for (size_t i = 0; i
        < size_t(gc::ZealMode::Count); i++) {\n      if (gZealBits & (1 << i)) {\n
        \       cx->runtime()->gc.setZeal(i, gZealFrequency);\n      }\n    }\n  }\n#endif\n\n
        \ JS_SetNativeStackQuota(cx, gWorkerStackSize);\n}\n\n[[nodiscard]] static
        bool PrintUnhandledRejection(\n    JSContext* cx, Handle<PromiseObject*> promise)
        {\n  RootedValue reason(cx, promise->reason());\n  RootedObject site(cx, promise->resolutionSite());\n\n
        \ RootedString str(cx, JS_ValueToSource(cx, reason));\n  if (!str) {\n    return
        false;\n  }\n\n  UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, str);\n
        \ if (!utf8chars) {\n    return false;\n  }\n\n  FILE* fp = ErrorFilePointer();\n
        \ fprintf(fp, \"Unhandled rejection: %s\\n\", utf8chars.get());\n\n  if (!site)
        {\n    fputs(\"(no stack trace available)\\n\", stderr);\n    return true;\n
        \ }\n\n  JSPrincipals* principals = cx->realm()->principals();\n  RootedString
        stackStr(cx);\n  if (!BuildStackString(cx, principals, site, &stackStr, 2))
        {\n    return false;\n  }\n\n  UniqueChars stack = JS_EncodeStringToUTF8(cx,
        stackStr);\n  if (!stack) {\n    return false;\n  }\n\n  fputs(\"Stack:\\n\",
        fp);\n  fputs(stack.get(), fp);\n\n  return true;\n}\n\n[[nodiscard]] static
        bool ReportUnhandledRejections(JSContext* cx) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ if (!sc->trackUnhandledRejections) {\n    return true;\n  }\n\n  if (!sc->unhandledRejectedPromises)
        {\n    return true;\n  }\n\n  AutoRealm ar(cx, sc->unhandledRejectedPromises);\n\n
        \ if (!SetObject::size(cx, sc->unhandledRejectedPromises)) {\n    return true;\n
        \ }\n\n  sc->exitCode = EXITCODE_RUNTIME_ERROR;\n\n  RootedValue iter(cx);\n
        \ if (!SetObject::iterator(cx, SetObject::IteratorKind::Values,\n                           sc->unhandledRejectedPromises,
        &iter)) {\n    return false;\n  }\n\n  Rooted<SetIteratorObject*> iterObj(cx,\n
        \                                    &iter.toObject().as<SetIteratorObject>());\n
        \ JSObject* obj = SetIteratorObject::createResult(cx);\n  if (!obj) {\n    return
        false;\n  }\n\n  Rooted<ArrayObject*> resultObj(cx, &obj->as<ArrayObject>());\n
        \ while (true) {\n    bool done = SetIteratorObject::next(iterObj, resultObj);\n
        \   if (done) {\n      break;\n    }\n\n    RootedObject obj(cx, &resultObj->getDenseElement(0).toObject());\n
        \   Rooted<PromiseObject*> promise(cx, obj->maybeUnwrapIf<PromiseObject>());\n
        \   if (!promise) {\n      FILE* fp = ErrorFilePointer();\n      fputs(\n
        \         \"Unhandled rejection: dead proxy found in unhandled \"\n          \"rejections
        set\\n\",\n          fp);\n      continue;\n    }\n\n    AutoRealm ar2(cx,
        promise);\n\n    if (!PrintUnhandledRejection(cx, promise)) {\n      return
        false;\n    }\n  }\n\n  sc->unhandledRejectedPromises = nullptr;\n\n  return
        true;\n}\n\nstatic int Shell(JSContext* cx, OptionParser* op) {\n#ifdef JS_STRUCTURED_SPEW\n
        \ cx->spewer().enableSpewing();\n#endif\n\n  auto exitShell = MakeScopeExit([&]
        {\n#ifdef JS_STRUCTURED_SPEW\n    cx->spewer().disableSpewing();\n#endif\n
        \ });\n\n#ifdef MOZ_CODE_COVERAGE\n  InstallCoverageSignalHandlers();\n#endif\n\n
        \ Maybe<JS::AutoDisableGenerationalGC> noggc;\n  if (op->getBoolOption(\"no-ggc\"))
        {\n    noggc.emplace(cx);\n  }\n\n  Maybe<AutoDisableCompactingGC> nocgc;\n
        \ if (op->getBoolOption(\"no-cgc\")) {\n    nocgc.emplace(cx);\n  }\n\n  if
        (op->getBoolOption(\"fuzzing-safe\")) {\n    fuzzingSafe = true;\n  } else
        {\n    fuzzingSafe =\n        (getenv(\"MOZ_FUZZING_SAFE\") && getenv(\"MOZ_FUZZING_SAFE\")[0]
        != '0');\n  }\n\n#ifdef DEBUG\n  if (op->getBoolOption(\"differential-testing\"))
        {\n    JS::SetSupportDifferentialTesting(true);\n  }\n#endif\n\n  if (op->getBoolOption(\"disable-oom-functions\"))
        {\n    disableOOMFunctions = true;\n  }\n\n  if (op->getBoolOption(\"more-compartments\"))
        {\n    defaultToSameCompartment = false;\n  }\n\n  bool reprl_mode = FuzzilliUseReprlMode(op);\n\n
        \ // Begin REPRL Loop\n  int result = EXIT_SUCCESS;\n  do {\n    JS::RealmOptions
        options;\n    SetStandardRealmOptions(options);\n    RootedObject glob(\n
        \       cx, NewGlobalObject(cx, options, nullptr, ShellGlobalKind::WindowProxy,\n
        \                           /* immutablePrototype = */ true));\n    if (!glob)
        {\n      return 1;\n    }\n\n    JSAutoRealm ar(cx, glob);\n\n    ShellContext*
        sc = GetShellContext(cx);\n    if (!sc->moduleLoader && !InitModuleLoader(cx,
        *op)) {\n      return EXIT_FAILURE;\n    }\n\n#ifdef FUZZING_INTERFACES\n
        \   if (fuzzHaveModule) {\n      return FuzzJSRuntimeStart(cx, &sArgc, &sArgv);\n
        \   }\n#endif\n\n    sc->exitCode = 0;\n    result = EXIT_SUCCESS;\n    {\n
        \     AutoReportException are(cx);\n      if (!ProcessArgs(cx, op) && !sc->quitting)
        {\n        result = EXITCODE_RUNTIME_ERROR;\n      }\n    }\n\n    /*\n     *
        The job queue must be drained even on error to finish outstanding async\n
        \    * tasks before the main thread JSRuntime is torn down. Drain after\n
        \    * uncaught exceptions have been reported since draining runs callbacks.\n
        \    */\n    RunShellJobs(cx);\n\n    // Only if there's no other error, report
        unhandled rejections.\n    if (!result && !sc->exitCode) {\n      AutoReportException
        are(cx);\n      if (!ReportUnhandledRejections(cx)) {\n        FILE* fp =
        ErrorFilePointer();\n        fputs(\"Error while printing unhandled rejection\\n\",
        fp);\n      }\n    }\n\n    if (sc->exitCode) {\n      result = sc->exitCode;\n
        \   }\n\n#ifdef FUZZING_JS_FUZZILLI\n    if (reprl_mode) {\n      fflush(stdout);\n
        \     fflush(stderr);\n      // Send return code to parent and reset edge
        counters.\n      struct {\n        int status;\n        uint32_t execHash;\n
        \       uint32_t execHashInputs;\n      } s;\n      s.status = (result & 0xff)
        << 8;\n      s.execHash = cx->executionHash;\n      s.execHashInputs = cx->executionHashInputs;\n
        \     MOZ_RELEASE_ASSERT(write(REPRL_CWFD, &s, 12) == 12);\n      __sanitizer_cov_reset_edgeguards();\n
        \     cx->executionHash = 1;\n      cx->executionHashInputs = 0;\n    }\n#endif\n\n
        \   if (enableDisassemblyDumps) {\n      AutoReportException are(cx);\n      if
        (!js::DumpRealmPCCounts(cx)) {\n        result = EXITCODE_OUT_OF_MEMORY;\n
        \     }\n    }\n\n    // End REPRL loop\n  } while (reprl_mode);\n\n  return
        result;\n}\n\n// Used to allocate memory when jemalloc isn't yet initialized.\nJS_DECLARE_NEW_METHODS(SystemAlloc_New,
        malloc, static)\n\nstatic void SetOutputFile(const char* const envVar, RCFile*
        defaultOut,\n                          RCFile** outFileP) {\n  RCFile* outFile;\n\n
        \ const char* outPath = getenv(envVar);\n  FILE* newfp;\n  if (outPath &&
        *outPath && (newfp = fopen(outPath, \"w\"))) {\n    outFile = SystemAlloc_New<RCFile>(newfp);\n
        \ } else {\n    outFile = defaultOut;\n  }\n\n  if (!outFile) {\n    MOZ_CRASH(\"Failed
        to allocate output file\");\n  }\n\n  outFile->acquire();\n  *outFileP = outFile;\n}\n\nstatic
        void PreInit() {\n#ifdef XP_WIN\n  const char* crash_option = getenv(\"XRE_NO_WINDOWS_CRASH_DIALOG\");\n
        \ if (crash_option && crash_option[0] == '1') {\n    // Disable the segfault
        dialog. We want to fail the tests immediately\n    // instead of hanging automation.\n
        \   UINT newMode = SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX;\n    UINT
        prevMode = SetErrorMode(newMode);\n    SetErrorMode(prevMode | newMode);\n
        \ }\n#endif\n}\n\n#ifndef JS_WITHOUT_NSPR\nclass AutoLibraryLoader {\n  Vector<PRLibrary*,
        4, SystemAllocPolicy> libraries;\n\n public:\n  ~AutoLibraryLoader() {\n    for
        (auto dll : libraries) {\n      PR_UnloadLibrary(dll);\n    }\n  }\n\n  PRLibrary*
        load(const char* path) {\n    PRLibSpec libSpec;\n    libSpec.type = PR_LibSpec_Pathname;\n
        \   libSpec.value.pathname = path;\n    PRLibrary* dll = PR_LoadLibraryWithFlags(libSpec,
        PR_LD_NOW | PR_LD_GLOBAL);\n    if (!dll) {\n      fprintf(stderr, \"LoadLibrary
        '%s' failed with code %d\\n\", path,\n              PR_GetError());\n      MOZ_CRASH(\"Failed
        to load library\");\n    }\n\n    MOZ_ALWAYS_TRUE(libraries.append(dll));\n
        \   return dll;\n  }\n};\n#endif\n\nstatic bool ReadSelfHostedXDRFile(JSContext*
        cx, FileContents& buf) {\n  FILE* file = fopen(selfHostedXDRPath, \"rb\");\n
        \ if (!file) {\n    fprintf(stderr, \"Can't open self-hosted stencil XDR file.\\n\");\n
        \   return false;\n  }\n  AutoCloseFile autoClose(file);\n\n  struct stat
        st;\n  if (fstat(fileno(file), &st) < 0) {\n    fprintf(stderr, \"Unable to
        stat self-hosted stencil XDR file.\\n\");\n    return false;\n  }\n\n  if
        (st.st_size >= INT32_MAX) {\n    fprintf(stderr, \"self-hosted stencil XDR
        file too large.\\n\");\n    return false;\n  }\n  uint32_t filesize = uint32_t(st.st_size);\n\n
        \ if (!buf.growBy(filesize)) {\n    return false;\n  }\n  size_t cc = fread(buf.begin(),
        1, filesize, file);\n  if (cc != filesize) {\n    fprintf(stderr, \"Short
        read on self-hosted stencil XDR file.\\n\");\n    return false;\n  }\n\n  return
        true;\n}\n\nstatic bool WriteSelfHostedXDRFile(JSContext* cx, JS::SelfHostedCache
        buffer) {\n  FILE* file = fopen(selfHostedXDRPath, \"wb\");\n  if (!file)
        {\n    JS_ReportErrorUTF8(cx, \"Can't open self-hosted stencil XDR file.\");\n
        \   return false;\n  }\n  AutoCloseFile autoClose(file);\n\n  size_t cc =
        fwrite(buffer.Elements(), 1, buffer.LengthBytes(), file);\n  if (cc != buffer.LengthBytes())
        {\n    JS_ReportErrorUTF8(cx, \"Short write on self-hosted stencil XDR file.\");\n
        \   return false;\n  }\n\n  return true;\n}\n\nstatic bool SetGCParameterFromArg(JSContext*
        cx, char* arg) {\n  char* c = strchr(arg, '=');\n  if (!c) {\n    fprintf(stderr,\n
        \           \"Error: --gc-param argument '%s' must be of the form \"\n            \"name=decimalValue\\n\",\n
        \           arg);\n    return false;\n  }\n\n  *c = '\\0';\n  const char*
        name = arg;\n  const char* valueStr = c + 1;\n\n  JSGCParamKey key;\n  bool
        writable;\n  if (!GetGCParameterInfo(name, &key, &writable)) {\n    fprintf(stderr,
        \"Error: Unknown GC parameter name '%s'\\n\", name);\n    fprintf(stderr,
        \"Writable GC parameter names are:\\n\");\n#define PRINT_WRITABLE_PARAM_NAME(name,
        _, writable) \\\n  if (writable) {                                    \\\n
        \   fprintf(stderr, \"  %s\\n\", name);                 \\\n  }\n    FOR_EACH_GC_PARAM(PRINT_WRITABLE_PARAM_NAME)\n#undef
        PRINT_WRITABLE_PARAM_NAME\n    return false;\n  }\n\n  if (!writable) {\n
        \   fprintf(stderr, \"Error: GC parameter '%s' is not writable\\n\", name);\n
        \   return false;\n  }\n\n  char* end = nullptr;\n  unsigned long int value
        = strtoul(valueStr, &end, 10);\n  if (end == valueStr || *end) {\n    fprintf(stderr,\n
        \           \"Error: Could not parse '%s' as decimal for GC parameter '%s'\\n\",\n
        \           valueStr, name);\n    return false;\n  }\n\n  uint32_t paramValue
        = uint32_t(value);\n  if (value == ULONG_MAX || value != paramValue ||\n      !cx->runtime()->gc.setParameter(cx,
        key, paramValue)) {\n    fprintf(stderr, \"Error: Value %s is out of range
        for GC parameter '%s'\\n\",\n            valueStr, name);\n    return false;\n
        \ }\n\n  return true;\n}\n\nint main(int argc, char** argv) {\n  PreInit();\n\n
        \ sArgc = argc;\n  sArgv = argv;\n\n  int result;\n\n  setlocale(LC_ALL, \"\");\n\n
        \ // Special-case stdout and stderr. We bump their refcounts to prevent them\n
        \ // from getting closed and then having some printf fail somewhere.\n  RCFile
        rcStdout(stdout);\n  rcStdout.acquire();\n  RCFile rcStderr(stderr);\n  rcStderr.acquire();\n\n
        \ SetOutputFile(\"JS_STDOUT\", &rcStdout, &gOutFile);\n  SetOutputFile(\"JS_STDERR\",
        &rcStderr, &gErrFile);\n\n  // Use a larger jemalloc page cache. This should
        match the value for browser\n  // foreground processes in ContentChild::RecvNotifyProcessPriorityChanged.\n
        \ moz_set_max_dirty_page_modifier(4);\n\n  OptionParser op(\"Usage: {progname}
        [options] [[script] scriptArgs*]\");\n  if (!InitOptionParser(op)) {\n    return
        EXIT_FAILURE;\n  }\n\n  switch (op.parseArgs(argc, argv)) {\n    case OptionParser::EarlyExit:\n
        \     return EXIT_SUCCESS;\n    case OptionParser::ParseError:\n      op.printHelp(argv[0]);\n
        \     return EXIT_FAILURE;\n    case OptionParser::Fail:\n      return EXIT_FAILURE;\n
        \   case OptionParser::Okay:\n      break;\n  }\n\n  if (op.getHelpOption())
        {\n    return EXIT_SUCCESS;\n  }\n\n  if (!SetGlobalOptionsPreJSInit(op))
        {\n    return EXIT_FAILURE;\n  }\n\n  // Start the engine.\n  if (const char*
        message = JS_InitWithFailureDiagnostic()) {\n    fprintf(gErrFile->fp, \"JS_Init
        failed: %s\\n\", message);\n    return 1;\n  }\n\n  // `selfHostedXDRBuffer`
        contains XDR buffer of the self-hosted JS.\n  // A part of it is borrowed
        by ImmutableScriptData of the self-hosted scripts.\n  //\n  // This buffer
        should outlive JS_Shutdown.\n  Maybe<FileContents> selfHostedXDRBuffer;\n\n
        \ auto shutdownEngine = MakeScopeExit([] { JS_ShutDown(); });\n\n  if (!SetGlobalOptionsPostJSInit(op))
        {\n    return EXIT_FAILURE;\n  }\n\n  // Record aggregated telemetry data
        on disk. Do this as early as possible such\n  // that the telemetry is recording
        both before starting the context and after\n  // closing it.\n  auto writeTelemetryResults
        = MakeScopeExit([&op] {\n    if (telemetryLock) {\n      const char* dir =
        op.getStringOption(\"telemetry-dir\");\n      WriteTelemetryDataToDisk(dir);\n
        \     js_free(telemetryLock);\n      telemetryLock = nullptr;\n    }\n  });\n\n
        \ if (!InitSharedObjectMailbox()) {\n    return EXIT_FAILURE;\n  }\n\n  JS::SetProcessBuildIdOp(ShellBuildId);\n\n
        \ /* Use the same parameters as the browser in xpcjsruntime.cpp. */\n  JSContext*
        const cx = JS_NewContext(JS::DefaultHeapMaxBytes);\n  if (!cx) {\n    return
        1;\n  }\n\n  // Register telemetry callbacks, if needed.\n  if (telemetryLock)
        {\n    JS_SetAccumulateTelemetryCallback(cx, AccumulateTelemetryDataCallback);\n
        \ }\n\n  auto destroyCx = MakeScopeExit([cx] { JS_DestroyContext(cx); });\n\n
        \ UniquePtr<ShellContext> sc = MakeUnique<ShellContext>(cx);\n  if (!sc) {\n
        \   return 1;\n  }\n  auto destroyShellContext = MakeScopeExit([cx, &sc] {\n
        \   // Must clear out some of sc's pointer containers before JS_DestroyContext.\n
        \   sc->markObservers.reset();\n\n    JS_SetContextPrivate(cx, nullptr);\n
        \   sc.reset();\n  });\n\n  JS_SetContextPrivate(cx, sc.get());\n  JS_AddExtraGCRootsTracer(cx,
        TraceBlackRoots, nullptr);\n  JS_SetGrayGCRootsTracer(cx, TraceGrayRoots,
        nullptr);\n  auto resetGrayGCRootsTracer =\n      MakeScopeExit([cx] { JS_SetGrayGCRootsTracer(cx,
        nullptr, nullptr); });\n\n  // Waiting is allowed on the shell's main thread,
        for now.\n  JS_SetFutexCanWait(cx);\n  JS::SetWarningReporter(cx, WarningReporter);\n\n
        \ if (!SetContextOptions(cx, op)) {\n    return 1;\n  }\n\n  JS_SetTrustedPrincipals(cx,
        &ShellPrincipals::fullyTrusted);\n  JS_SetSecurityCallbacks(cx, &ShellPrincipals::securityCallbacks);\n
        \ JS_InitDestroyPrincipalsCallback(cx, ShellPrincipals::destroy);\n  JS_SetDestroyCompartmentCallback(cx,
        DestroyShellCompartmentPrivate);\n\n  js::SetWindowProxyClass(cx, &ShellWindowProxyClass);\n\n
        \ JS_AddInterruptCallback(cx, ShellInterruptCallback);\n\n  JS::SetGCSliceCallback(cx,
        GCSliceCallback);\n\n  bufferStreamState = js_new<ExclusiveWaitableData<BufferStreamState>>(\n
        \     mutexid::BufferStreamState);\n  if (!bufferStreamState) {\n    return
        1;\n  }\n  auto shutdownBufferStreams = MakeScopeExit([] {\n    ShutdownBufferStreams();\n
        \   js_delete(bufferStreamState);\n  });\n  JS::InitConsumeStreamCallback(cx,
        ConsumeBufferSource, ReportStreamError);\n\n  JS::SetPromiseRejectionTrackerCallback(\n
        \     cx, ForwardingPromiseRejectionTrackerCallback);\n\n  JS::dbg::SetDebuggerMallocSizeOf(cx,
        moz_malloc_size_of);\n\n  js::UseInternalJobQueues(cx);\n\n  JS::SetHostCleanupFinalizationRegistryCallback(\n
        \     cx, ShellCleanupFinalizationRegistryCallback, sc.get());\n\n  auto shutdownShellThreads
        = MakeScopeExit([cx] {\n    KillWatchdog(cx);\n    KillWorkerThreads(cx);\n
        \   DestructSharedObjectMailbox();\n    CancelOffThreadJobsForRuntime(cx);\n
        \ });\n\n  // The file content should stay alive as long as Worker thread
        can be\n  // initialized.\n  JS::SelfHostedCache xdrSpan = nullptr;\n  JS::SelfHostedWriter
        xdrWriter = nullptr;\n  if (selfHostedXDRPath) {\n    if (encodeSelfHostedCode)
        {\n      xdrWriter = WriteSelfHostedXDRFile;\n    } else {\n      selfHostedXDRBuffer.emplace(cx);\n
        \     if (ReadSelfHostedXDRFile(cx, *selfHostedXDRBuffer)) {\n        MOZ_ASSERT(selfHostedXDRBuffer->length()
        > 0);\n        JS::SelfHostedCache span(selfHostedXDRBuffer->begin(),\n                                 selfHostedXDRBuffer->end());\n
        \       xdrSpan = span;\n      } else {\n        fprintf(stderr, \"Falling
        back on parsing source.\\n\");\n        selfHostedXDRPath = nullptr;\n      }\n
        \   }\n  }\n\n  if (!JS::InitSelfHostedCode(cx, xdrSpan, xdrWriter)) {\n    return
        1;\n  }\n\n  EnvironmentPreparer environmentPreparer(cx);\n\n  JS::SetProcessLargeAllocationFailureCallback(my_LargeAllocFailCallback);\n\n
        \ js::SetPreserveWrapperCallbacks(cx, DummyPreserveWrapperCallback,\n                                  DummyHasReleasedWrapperCallback);\n\n
        \ if (op.getBoolOption(\"wasm-compile-and-serialize\")) {\n#ifdef __wasi__\n
        \   MOZ_CRASH(\"WASI doesn't support wasm\");\n#else\n    if (!WasmCompileAndSerialize(cx))
        {\n      // Errors have been printed directly to stderr.\n      MOZ_ASSERT(!cx->isExceptionPending());\n
        \     return EXIT_FAILURE;\n    }\n#endif\n    return EXIT_SUCCESS;\n  }\n\n
        \ result = Shell(cx, &op);\n\n#ifdef DEBUG\n  if (OOM_printAllocationCount)
        {\n    printf(\"OOM max count: %\" PRIu64 \"\\n\", js::oom::simulator.counter());\n
        \ }\n#endif\n\n  return result;\n}\n\nbool InitOptionParser(OptionParser&
        op) {\n  op.setDescription(\n      \"The SpiderMonkey shell provides a command
        line interface to the \"\n      \"JavaScript engine. Code and file options
        provided via the command line \"\n      \"are \"\n      \"run left to right.
        If provided, the optional script argument is run \"\n      \"after \"\n      \"all
        options have been processed. Just-In-Time compilation modes may be \"\n      \"enabled
        via \"\n      \"command line options.\");\n  op.setDescriptionWidth(72);\n
        \ op.setHelpWidth(80);\n  op.setVersion(JS_GetImplementationVersion());\n\n
        \ if (!op.addMultiStringOption(\n          'f', \"file\", \"PATH\",\n          \"File
        path to run, parsing file contents as UTF-8\") ||\n      !op.addMultiStringOption(\n
        \         'u', \"utf16-file\", \"PATH\",\n          \"File path to run, inflating
        the file's UTF-8 contents to UTF-16 and \"\n          \"then parsing that\")
        ||\n      !op.addMultiStringOption('m', \"module\", \"PATH\", \"Module path
        to run\") ||\n      !op.addMultiStringOption('p', \"prelude\", \"PATH\", \"Prelude
        path to run\") ||\n      !op.addMultiStringOption('e', \"execute\", \"CODE\",
        \"Inline code to run\") ||\n      !op.addStringOption('\\0', \"selfhosted-xdr-path\",
        \"[filename]\",\n                          \"Read/Write selfhosted script
        data from/to the given \"\n                          \"XDR file\") ||\n      !op.addStringOption('\\0',
        \"selfhosted-xdr-mode\", \"(encode,decode,off)\",\n                          \"Whether
        to encode/decode data of the file provided\"\n                          \"with
        --selfhosted-xdr-path.\") ||\n      !op.addBoolOption('i', \"shell\", \"Enter
        prompt after running code\") ||\n      !op.addBoolOption('c', \"compileonly\",\n
        \                       \"Only compile, don't run (syntax checking mode)\")
        ||\n      !op.addBoolOption('w', \"warnings\", \"Emit warnings\") ||\n      !op.addBoolOption('W',
        \"nowarnings\", \"Don't emit warnings\") ||\n      !op.addBoolOption('D',
        \"dump-bytecode\",\n                        \"Dump bytecode with exec count
        for all scripts\") ||\n      !op.addBoolOption('b', \"print-timing\",\n                        \"Print
        sub-ms runtime for each file that's run\") ||\n      !op.addBoolOption('\\0',
        \"code-coverage\",\n                        \"Enable code coverage instrumentation.\")
        ||\n      !op.addBoolOption(\n          '\\0', \"disable-parser-deferred-alloc\",\n
        \         \"Disable deferred allocation of GC objects until after parser\")
        ||\n#ifdef DEBUG\n      !op.addBoolOption('O', \"print-alloc\",\n                        \"Print
        the number of allocations at exit\") ||\n#endif\n      !op.addOptionalStringArg(\"script\",\n
        \                              \"A script to execute (after all options)\")
        ||\n      !op.addOptionalMultiStringArg(\n          \"scriptArgs\",\n          \"String
        arguments to bind as |scriptArgs| in the \"\n          \"shell's global\")
        ||\n      !op.addIntOption(\n          '\\0', \"cpu-count\", \"COUNT\",\n
        \         \"Set the number of CPUs (hardware threads) to COUNT, the \"\n          \"default
        is the actual number of CPUs. The total number of \"\n          \"background
        helper threads is the CPU count plus some constant.\",\n          -1) ||\n
        \     !op.addIntOption('\\0', \"thread-count\", \"COUNT\", \"Alias for --cpu-count.\",\n
        \                      -1) ||\n      !op.addBoolOption('\\0', \"ion\", \"Enable
        IonMonkey (default)\") ||\n      !op.addBoolOption('\\0', \"no-ion\", \"Disable
        IonMonkey\") ||\n      !op.addBoolOption('\\0', \"no-ion-for-main-context\",\n
        \                       \"Disable IonMonkey for the main context only\") ||\n
        \     !op.addIntOption('\\0', \"inlining-entry-threshold\", \"COUNT\",\n                       \"The
        minimum stub entry count before trial-inlining a\"\n                       \"
        call\",\n                       -1) ||\n      !op.addIntOption('\\0', \"small-function-length\",
        \"COUNT\",\n                       \"The maximum bytecode length of a 'small
        function' for \"\n                       \"the purpose of inlining.\",\n                       -1)
        ||\n      !op.addBoolOption('\\0', \"only-inline-selfhosted\",\n                        \"Only
        inline selfhosted functions\") ||\n      !op.addBoolOption('\\0', \"no-asmjs\",
        \"Disable asm.js compilation\") ||\n      !op.addStringOption(\n          '\\0',
        \"wasm-compiler\", \"[option]\",\n          \"Choose to enable a subset of
        the wasm compilers, valid options are \"\n          \"'none', 'baseline',
        'ion', 'optimizing', \"\n          \"'baseline+ion', 'baseline+optimizing'.\")
        ||\n      !op.addBoolOption('\\0', \"wasm-verbose\",\n                        \"Enable
        WebAssembly verbose logging\") ||\n      !op.addBoolOption('\\0', \"disable-wasm-huge-memory\",\n
        \                       \"Disable WebAssembly huge memory\") ||\n      !op.addBoolOption('\\0',
        \"test-wasm-await-tier2\",\n                        \"Forcibly activate tiering
        and block \"\n                        \"instantiation on completion of tier2\")
        ||\n#define WASM_DEFAULT_FEATURE(NAME, LOWER_NAME, COMPILE_PRED, COMPILER_PRED,
        \\\n                             FLAG_PRED, SHELL, ...)                         \\\n
        \ !op.addBoolOption('\\0', \"no-wasm-\" SHELL, \"Disable wasm \" SHELL \"feature.\")
        ||\n#define WASM_TENTATIVE_FEATURE(NAME, LOWER_NAME, COMPILE_PRED, COMPILER_PRED,
        \\\n                               FLAG_PRED, SHELL, ...)                         \\\n
        \ !op.addBoolOption('\\0', \"no-wasm-\" SHELL,                                   \\\n
        \                   \"Disable wasm \" SHELL \"feature.\") ||                      \\\n
        \     !op.addBoolOption('\\0', \"wasm-\" SHELL, \"No-op.\") ||\n#define WASM_EXPERIMENTAL_FEATURE(NAME,
        LOWER_NAME, COMPILE_PRED,       \\\n                                  COMPILER_PRED,
        FLAG_PRED, SHELL, ...) \\\n  !op.addBoolOption('\\0', \"wasm-\" SHELL,                                \\\n
        \                   \"Enable experimental wasm \" SHELL \"feature.\") ||    \\\n
        \     !op.addBoolOption('\\0', \"no-wasm-\" SHELL, \"No-op.\") ||\n      JS_FOR_WASM_FEATURES(WASM_DEFAULT_FEATURE,
        WASM_TENTATIVE_FEATURE,\n                           WASM_EXPERIMENTAL_FEATURE)\n#undef
        WASM_DEFAULT_FEATURE\n#undef WASM_TENTATIVE_FEATURE\n#undef WASM_EXPERIMENTAL_FEATURE\n
        \         !op.addBoolOption('\\0', \"no-native-regexp\",\n                            \"Disable
        native regexp compilation\") ||\n      !op.addIntOption(\n          '\\0',
        \"regexp-warmup-threshold\", \"COUNT\",\n          \"Wait for COUNT invocations
        before compiling regexps to native code \"\n          \"(default 10)\",\n
        \         -1) ||\n      !op.addBoolOption('\\0', \"trace-regexp-parser\",
        \"Trace regexp parsing\") ||\n      !op.addBoolOption('\\0', \"trace-regexp-assembler\",\n
        \                       \"Trace regexp assembler\") ||\n      !op.addBoolOption('\\0',
        \"trace-regexp-interpreter\",\n                        \"Trace regexp interpreter\")
        ||\n      !op.addBoolOption('\\0', \"trace-regexp-peephole\",\n                        \"Trace
        regexp peephole optimization\") ||\n      !op.addBoolOption('\\0', \"less-debug-code\",\n
        \                       \"Emit less machine code for \"\n                        \"checking
        assertions under DEBUG.\") ||\n      !op.addBoolOption('\\0', \"disable-weak-refs\",
        \"Disable weak references\") ||\n      !op.addBoolOption('\\0', \"disable-tosource\",
        \"Disable toSource/uneval\") ||\n      !op.addBoolOption('\\0', \"disable-property-error-message-fix\",\n
        \                       \"Disable fix for the error message when accessing
        \"\n                        \"property of null or undefined\") ||\n      !op.addBoolOption('\\0',
        \"enable-iterator-helpers\",\n                        \"Enable iterator helpers\")
        ||\n      !op.addBoolOption('\\0', \"enable-shadow-realms\", \"Enable ShadowRealms\")
        ||\n      !op.addBoolOption('\\0', \"enable-array-grouping\",\n                        \"Enable
        Array.grouping\") ||\n      !op.addBoolOption('\\0', \"enable-array-from-async\",\n
        \                       \"Enable Array.fromAsync\") ||\n      !op.addBoolOption('\\0',
        \"enable-well-formed-unicode-strings\",\n                        \"Enable
        String.prototype.{is,to}WellFormed() methods\"\n                        \"(Well-Formed
        Unicode Strings)\") ||\n      !op.addBoolOption('\\0', \"enable-change-array-by-copy\",\n
        \                       \"Enable change-array-by-copy methods\") ||\n      !op.addBoolOption('\\0',
        \"disable-change-array-by-copy\",\n                        \"Disable change-array-by-copy
        methods\") ||\n#ifdef ENABLE_NEW_SET_METHODS\n      !op.addBoolOption('\\0',
        \"enable-new-set-methods\",\n                        \"Enable New Set methods\")
        ||\n      !op.addBoolOption('\\0', \"disable-new-set-methods\",\n                        \"Disable
        New Set methods\") ||\n#else\n      !op.addBoolOption('\\0', \"enable-new-set-methods\",
        \"no-op\") ||\n      !op.addBoolOption('\\0', \"disable-new-set-methods\",
        \"no-op\") ||\n#endif\n      !op.addBoolOption('\\0', \"enable-top-level-await\",\n
        \                       \"Enable top-level await\") ||\n      !op.addBoolOption('\\0',
        \"enable-class-static-blocks\",\n                        \"(no-op) Enable
        class static blocks\") ||\n      !op.addBoolOption('\\0', \"enable-import-assertions\",\n
        \                       \"Enable import assertions\") ||\n      !op.addStringOption('\\0',
        \"shared-memory\", \"on/off\",\n                          \"SharedArrayBuffer
        and Atomics \"\n#if SHARED_MEMORY_DEFAULT\n                          \"(default:
        on, off to disable)\"\n#else\n                          \"(default: off, on
        to enable)\"\n#endif\n                          ) ||\n      !op.addStringOption('\\0',
        \"spectre-mitigations\", \"on/off\",\n                          \"Whether
        Spectre mitigations are enabled (default: \"\n                          \"off,
        on to enable)\") ||\n      !op.addStringOption('\\0', \"cache-ir-stubs\",
        \"on/off/call\",\n                          \"Use CacheIR stubs (default:
        on, off to disable, \"\n                          \"call to enable work-in-progress
        call ICs)\") ||\n      !op.addStringOption('\\0', \"ion-shared-stubs\", \"on/off\",\n
        \                         \"Use shared stubs (default: on, off to disable)\")
        ||\n      !op.addStringOption('\\0', \"ion-scalar-replacement\", \"on/off\",\n
        \                         \"Scalar Replacement (default: on, off to disable)\")
        ||\n      !op.addStringOption('\\0', \"ion-gvn\", \"[mode]\",\n                          \"Specify
        Ion global value numbering:\\n\"\n                          \"  off: disable
        GVN\\n\"\n                          \"  on:  enable GVN (default)\\n\") ||\n
        \     !op.addStringOption(\n          '\\0', \"ion-licm\", \"on/off\",\n          \"Loop
        invariant code motion (default: on, off to disable)\") ||\n      !op.addStringOption('\\0',
        \"ion-edgecase-analysis\", \"on/off\",\n                          \"Find edge
        cases where Ion can avoid bailouts \"\n                          \"(default:
        on, off to disable)\") ||\n      !op.addStringOption('\\0', \"ion-pruning\",
        \"on/off\",\n                          \"Branch pruning (default: on, off
        to disable)\") ||\n      !op.addStringOption('\\0', \"ion-range-analysis\",
        \"on/off\",\n                          \"Range analysis (default: on, off
        to disable)\") ||\n      !op.addStringOption('\\0', \"ion-sink\", \"on/off\",\n
        \                         \"Sink code motion (default: off, on to enable)\")
        ||\n      !op.addStringOption('\\0', \"ion-optimization-levels\", \"on/off\",\n
        \                         \"No-op for fuzzing\") ||\n      !op.addStringOption('\\0',
        \"ion-loop-unrolling\", \"on/off\",\n                          \"(NOP for
        fuzzers)\") ||\n      !op.addStringOption(\n          '\\0', \"ion-instruction-reordering\",
        \"on/off\",\n          \"Instruction reordering (default: off, on to enable)\")
        ||\n      !op.addStringOption(\n          '\\0', \"ion-optimize-shapeguards\",
        \"on/off\",\n          \"Eliminate redundant shape guards (default: on, off
        to disable)\") ||\n      !op.addStringOption(\n          '\\0', \"ion-optimize-gcbarriers\",
        \"on/off\",\n          \"Eliminate redundant GC barriers (default: on, off
        to disable)\") ||\n      !op.addStringOption('\\0', \"ion-iterator-indices\",
        \"on/off\",\n                          \"Optimize property access in for-in
        loops \"\n                          \"(default: on, off to disable)\") ||\n
        \     !op.addBoolOption('\\0', \"ion-check-range-analysis\",\n                        \"Range
        analysis checking\") ||\n      !op.addBoolOption('\\0', \"ion-extra-checks\",\n
        \                       \"Perform extra dynamic validation checks\") ||\n
        \     !op.addStringOption(\n          '\\0', \"ion-inlining\", \"on/off\",\n
        \         \"Inline methods where possible (default: on, off to disable)\")
        ||\n      !op.addStringOption(\n          '\\0', \"ion-osr\", \"on/off\",\n
        \         \"On-Stack Replacement (default: on, off to disable)\") ||\n      !op.addBoolOption('\\0',
        \"disable-bailout-loop-check\",\n                        \"Turn off bailout
        loop check\") ||\n      !op.addBoolOption('\\0', \"enable-watchtower\",\n
        \                       \"Enable Watchtower optimizations\") ||\n      !op.addBoolOption('\\0',
        \"disable-watchtower\",\n                        \"Disable Watchtower optimizations\")
        ||\n      !op.addBoolOption('\\0', \"enable-ic-frame-pointers\",\n                        \"Use
        frame pointers in all IC stubs\") ||\n      !op.addBoolOption('\\0', \"scalar-replace-arguments\",\n
        \                       \"Use scalar replacement to optimize ArgumentsObject\")
        ||\n      !op.addStringOption(\n          '\\0', \"ion-limit-script-size\",
        \"on/off\",\n          \"Don't compile very large scripts (default: on, off
        to disable)\") ||\n      !op.addIntOption('\\0', \"ion-warmup-threshold\",
        \"COUNT\",\n                       \"Wait for COUNT calls or iterations before
        compiling \"\n                       \"at the normal optimization level (default:
        1000)\",\n                       -1) ||\n      !op.addIntOption('\\0', \"ion-full-warmup-threshold\",
        \"COUNT\",\n                       \"No-op for fuzzing\", -1) ||\n      !op.addStringOption(\n
        \         '\\0', \"ion-regalloc\", \"[mode]\",\n          \"Specify Ion register
        allocation:\\n\"\n          \"  backtracking: Priority based backtracking
        register allocation \"\n          \"(default)\\n\"\n          \"  testbed:
        Backtracking allocator with experimental features\\n\"\n          \"  stupid:
        Simple block local register allocation\") ||\n      !op.addBoolOption(\n          '\\0',
        \"ion-eager\",\n          \"Always ion-compile methods (implies --baseline-eager)\")
        ||\n      !op.addBoolOption('\\0', \"fast-warmup\",\n                        \"Reduce
        warmup thresholds for each tier.\") ||\n      !op.addStringOption('\\0', \"ion-offthread-compile\",
        \"on/off\",\n                          \"Compile scripts off thread (default:
        on)\") ||\n      !op.addStringOption('\\0', \"ion-parallel-compile\", \"on/off\",\n
        \                         \"--ion-parallel compile is deprecated. Use \"\n
        \                         \"--ion-offthread-compile.\") ||\n      !op.addBoolOption('\\0',
        \"baseline\",\n                        \"Enable baseline compiler (default)\")
        ||\n      !op.addBoolOption('\\0', \"no-baseline\", \"Disable baseline compiler\")
        ||\n      !op.addBoolOption('\\0', \"baseline-eager\",\n                        \"Always
        baseline-compile methods\") ||\n      !op.addIntOption(\n          '\\0',
        \"baseline-warmup-threshold\", \"COUNT\",\n          \"Wait for COUNT calls
        or iterations before baseline-compiling \"\n          \"(default: 10)\",\n
        \         -1) ||\n      !op.addBoolOption('\\0', \"blinterp\",\n                        \"Enable
        Baseline Interpreter (default)\") ||\n      !op.addBoolOption('\\0', \"no-blinterp\",
        \"Disable Baseline Interpreter\") ||\n      !op.addBoolOption('\\0', \"disable-jithints\",\n
        \                       \"Disable caching eager baseline compilation hints.\")
        ||\n      !op.addBoolOption(\n          '\\0', \"emit-interpreter-entry\",\n
        \         \"Emit Interpreter entry trampolines (default under --enable-perf)\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-emit-interpreter-entry\",\n
        \         \"Do not emit Interpreter entry trampolines (default).\") ||\n      !op.addBoolOption('\\0',
        \"blinterp-eager\",\n                        \"Always Baseline-interpret scripts\")
        ||\n      !op.addIntOption(\n          '\\0', \"blinterp-warmup-threshold\",
        \"COUNT\",\n          \"Wait for COUNT calls or iterations before Baseline-interpreting
        \"\n          \"(default: 10)\",\n          -1) ||\n      !op.addIntOption(\n
        \         '\\0', \"trial-inlining-warmup-threshold\", \"COUNT\",\n          \"Wait
        for COUNT calls or iterations before trial-inlining \"\n          \"(default:
        500)\",\n          -1) ||\n      !op.addBoolOption(\n          '\\0', \"non-writable-jitcode\",\n
        \         \"(NOP for fuzzers) Allocate JIT code as non-writable memory.\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-sse3\",\n          \"Pretend
        CPU does not support SSE3 instructions and above \"\n          \"to test JIT
        codegen (no-op on platforms other than x86 and x64).\") ||\n      !op.addBoolOption(\n
        \         '\\0', \"no-ssse3\",\n          \"Pretend CPU does not support SSSE3
        [sic] instructions and above \"\n          \"to test JIT codegen (no-op on
        platforms other than x86 and x64).\") ||\n      !op.addBoolOption(\n          '\\0',
        \"no-sse41\",\n          \"Pretend CPU does not support SSE4.1 instructions
        \"\n          \"to test JIT codegen (no-op on platforms other than x86 and
        x64).\") ||\n      !op.addBoolOption('\\0', \"no-sse4\", \"Alias for --no-sse41\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-sse42\",\n          \"Pretend
        CPU does not support SSE4.2 instructions \"\n          \"to test JIT codegen
        (no-op on platforms other than x86 and x64).\") ||\n#ifdef ENABLE_WASM_AVX\n
        \     !op.addBoolOption('\\0', \"enable-avx\",\n                        \"No-op.
        AVX is enabled by default, if available.\") ||\n      !op.addBoolOption(\n
        \         '\\0', \"no-avx\",\n          \"Pretend CPU does not support AVX
        or AVX2 instructions \"\n          \"to test JIT codegen (no-op on platforms
        other than x86 and x64).\") ||\n#else\n      !op.addBoolOption('\\0', \"enable-avx\",\n
        \                       \"AVX is disabled by default. Enable AVX. \"\n                        \"(no-op
        on platforms other than x86 and x64).\") ||\n      !op.addBoolOption('\\0',
        \"no-avx\",\n                        \"No-op. AVX is currently disabled by
        default.\") ||\n#endif\n      !op.addBoolOption('\\0', \"more-compartments\",\n
        \                       \"Make newGlobal default to creating a new \"\n                        \"compartment.\")
        ||\n      !op.addBoolOption('\\0', \"fuzzing-safe\",\n                        \"Don't
        expose functions that aren't safe for \"\n                        \"fuzzers
        to call\") ||\n#ifdef DEBUG\n      !op.addBoolOption('\\0', \"differential-testing\",\n
        \                       \"Avoid random/undefined behavior that disturbs \"\n
        \                       \"differential testing (correctness fuzzing)\") ||\n#endif\n
        \     !op.addBoolOption('\\0', \"disable-oom-functions\",\n                        \"Disable
        functions that cause \"\n                        \"artificial OOMs\") ||\n
        \     !op.addBoolOption('\\0', \"no-threads\", \"Disable helper threads\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-jit-backend\",\n          \"Disable
        the JIT backend completely for this process\") ||\n#ifdef DEBUG\n      !op.addBoolOption('\\0',
        \"dump-entrained-variables\",\n                        \"Print variables which
        are \"\n                        \"unnecessarily entrained by inner functions\")
        ||\n#endif\n      !op.addBoolOption('\\0', \"no-ggc\", \"Disable Generational
        GC\") ||\n      !op.addBoolOption('\\0', \"no-cgc\", \"Disable Compacting
        GC\") ||\n      !op.addBoolOption('\\0', \"no-incremental-gc\", \"Disable
        Incremental GC\") ||\n      !op.addBoolOption('\\0', \"enable-parallel-marking\",\n
        \                       \"Turn on parallel marking\") ||\n      !op.addIntOption(\n
        \         '\\0', \"marking-threads\", \"COUNT\",\n          \"Set the number
        of threads used for parallel marking to COUNT.\", 0) ||\n      !op.addStringOption('\\0',
        \"nursery-strings\", \"on/off\",\n                          \"Allocate strings
        in the nursery\") ||\n      !op.addStringOption('\\0', \"nursery-bigints\",
        \"on/off\",\n                          \"Allocate BigInts in the nursery\")
        ||\n      !op.addIntOption('\\0', \"available-memory\", \"SIZE\",\n                       \"Select
        GC settings based on available memory (MB)\",\n                       0) ||\n
        \     !op.addStringOption('\\0', \"arm-hwcap\", \"[features]\",\n                          \"Specify
        ARM code generation features, or 'help' to \"\n                          \"list
        all features.\") ||\n      !op.addIntOption('\\0', \"arm-asm-nop-fill\", \"SIZE\",\n
        \                      \"Insert the given number of NOP instructions at all
        \"\n                       \"possible pool locations.\",\n                       0)
        ||\n      !op.addIntOption('\\0', \"asm-pool-max-offset\", \"OFFSET\",\n                       \"The
        maximum pc relative OFFSET permitted in pool \"\n                       \"reference
        instructions.\",\n                       1024) ||\n      !op.addBoolOption('\\0',
        \"arm-sim-icache-checks\",\n                        \"Enable icache flush
        checks in the ARM \"\n                        \"simulator.\") ||\n      !op.addIntOption('\\0',
        \"arm-sim-stop-at\", \"NUMBER\",\n                       \"Stop the ARM simulator
        after the given \"\n                       \"NUMBER of instructions.\",\n
        \                      -1) ||\n      !op.addBoolOption('\\0', \"mips-sim-icache-checks\",\n
        \                       \"Enable icache flush checks in the MIPS \"\n                        \"simulator.\")
        ||\n      !op.addIntOption('\\0', \"mips-sim-stop-at\", \"NUMBER\",\n                       \"Stop
        the MIPS simulator after the given \"\n                       \"NUMBER of
        instructions.\",\n                       -1) ||\n      !op.addBoolOption('\\0',
        \"loong64-sim-icache-checks\",\n                        \"Enable icache flush
        checks in the LoongArch64 \"\n                        \"simulator.\") ||\n
        \     !op.addIntOption('\\0', \"loong64-sim-stop-at\", \"NUMBER\",\n                       \"Stop
        the LoongArch64 simulator after the given \"\n                       \"NUMBER
        of instructions.\",\n                       -1) ||\n#ifdef JS_CODEGEN_RISCV64\n
        \     !op.addBoolOption('\\0', \"riscv-debug\", \"debug print riscv info.\")
        ||\n#endif\n#ifdef JS_SIMULATOR_RISCV64\n      !op.addBoolOption('\\0', \"trace-sim\",
        \"print simulator info.\") ||\n      !op.addBoolOption('\\0', \"debug-sim\",
        \"debug simulator.\") ||\n      !op.addBoolOption('\\0', \"riscv-trap-to-simulator-debugger\",\n
        \                       \"trap into simulator debuggger.\") ||\n      !op.addIntOption('\\0',
        \"riscv-sim-stop-at\", \"NUMBER\",\n                       \"Stop the riscv
        simulator after the given \"\n                       \"NUMBER of instructions.\",\n
        \                      -1) ||\n#endif\n      !op.addIntOption('\\0', \"nursery-size\",
        \"SIZE-MB\",\n                       \"Set the maximum nursery size in MB\",\n
        \                      JS::DefaultNurseryMaxBytes / 1024 / 1024) ||\n#ifdef
        JS_GC_ZEAL\n      !op.addStringOption('z', \"gc-zeal\", \"LEVEL(;LEVEL)*[,N]\",\n
        \                         gc::ZealModeHelpText) ||\n#else\n      !op.addStringOption('z',
        \"gc-zeal\", \"LEVEL(;LEVEL)*[,N]\",\n                          \"option ignored
        in non-gc-zeal builds\") ||\n#endif\n      !op.addMultiStringOption('\\0',
        \"gc-param\", \"NAME=VALUE\",\n                               \"Set a named
        GC parameter\") ||\n      !op.addStringOption('\\0', \"module-load-path\",
        \"DIR\",\n                          \"Set directory to load modules from\")
        ||\n      !op.addBoolOption('\\0', \"no-source-pragmas\",\n                        \"Disable
        source(Mapping)URL pragma parsing\") ||\n      !op.addBoolOption('\\0', \"no-async-stacks\",
        \"Disable async stacks\") ||\n      !op.addBoolOption('\\0', \"async-stacks-capture-debuggee-only\",\n
        \                       \"Limit async stack capture to only debuggees\") ||\n
        \     !op.addMultiStringOption('\\0', \"dll\", \"LIBRARY\",\n                               \"Dynamically
        load LIBRARY\") ||\n      !op.addBoolOption('\\0', \"suppress-minidump\",\n
        \                       \"Suppress crash minidumps\") ||\n#ifdef JS_ENABLE_SMOOSH\n
        \     !op.addBoolOption('\\0', \"smoosh\", \"Use SmooshMonkey\") ||\n      !op.addStringOption('\\0',
        \"not-implemented-watchfile\", \"[filename]\",\n                          \"Track
        NotImplemented errors in the new frontend\") ||\n#else\n      !op.addBoolOption('\\0',
        \"smoosh\", \"No-op\") ||\n#endif\n      !op.addStringOption(\n          '\\0',
        \"delazification-mode\", \"[option]\",\n          \"Select one of the delazification
        mode for scripts given on the \"\n          \"command line, valid options
        are: \"\n          \"'on-demand', 'concurrent-df', 'eager', 'concurrent-df+on-demand'.
        \"\n          \"Choosing 'concurrent-df+on-demand' will run both concurrent-df
        and \"\n          \"on-demand delazification mode, and compare compilation
        outcome. \") ||\n      !op.addBoolOption('\\0', \"wasm-compile-and-serialize\",\n
        \                       \"Compile the wasm bytecode from stdin and serialize
        \"\n                        \"the results to stdout\") ||\n#ifdef FUZZING_JS_FUZZILLI\n
        \     !op.addBoolOption('\\0', \"reprl\", \"Enable REPRL mode for fuzzing\")
        ||\n#endif\n      !op.addStringOption('\\0', \"telemetry-dir\", \"[directory]\",\n
        \                         \"Output telemetry results in a directory\") ||\n
        \     !op.addBoolOption('\\0', \"use-fdlibm-for-sin-cos-tan\",\n                        \"Use
        fdlibm for Math.sin, Math.cos, and Math.tan\")) {\n    return false;\n  }\n\n
        \ op.setArgTerminatesOptions(\"script\", true);\n  op.setArgCapturesRest(\"scriptArgs\");\n\n
        \ return true;\n}\n\nbool SetGlobalOptionsPreJSInit(const OptionParser& op)
        {\n  // Note: DisableJitBackend must be called before JS_InitWithFailureDiagnostic.\n
        \ if (op.getBoolOption(\"no-jit-backend\")) {\n    JS::DisableJitBackend();\n
        \ }\n\n#if defined(JS_CODEGEN_ARM)\n  if (const char* str = op.getStringOption(\"arm-hwcap\"))
        {\n    jit::SetARMHwCapFlagsString(str);\n  }\n\n  int32_t fill = op.getIntOption(\"arm-asm-nop-fill\");\n
        \ if (fill >= 0) {\n    jit::Assembler::NopFill = fill;\n  }\n\n  int32_t
        poolMaxOffset = op.getIntOption(\"asm-pool-max-offset\");\n  if (poolMaxOffset
        >= 5 && poolMaxOffset <= 1024) {\n    jit::Assembler::AsmPoolMaxOffset = poolMaxOffset;\n
        \ }\n#endif\n\n  // Fish around in `op` for various important compiler-configuration
        flags\n  // and make sure they get handed on to any child processes we might
        create.\n  // See bug 1700900.  Semantically speaking, this is all rather
        dubious:\n  //\n  // * What set of flags need to be propagated in order to
        guarantee that the\n  //   child produces code that is \"compatible\" (in
        whatever sense) with that\n  //   produced by the parent? This isn't always
        easy to determine.\n  //\n  // * There's nothing that ensures that flags given
        to the child are\n  //   presented in the same order that they exist in the
        parent's `argv[]`.\n  //   That could be a problem in the case where two flags
        with contradictory\n  //   meanings are given, and they are presented to the
        child in the opposite\n  //   order.  For example: --wasm-compiler=optimizing
        --wasm-compiler=baseline.\n\n#if defined(JS_CODEGEN_X86) || defined(JS_CODEGEN_X64)\n
        \ MOZ_ASSERT(!js::jit::CPUFlagsHaveBeenComputed());\n\n  if (op.getBoolOption(\"no-sse3\"))
        {\n    js::jit::CPUInfo::SetSSE3Disabled();\n    if (!sCompilerProcessFlags.append(\"--no-sse3\"))
        {\n      return false;\n    }\n  }\n  if (op.getBoolOption(\"no-ssse3\"))
        {\n    js::jit::CPUInfo::SetSSSE3Disabled();\n    if (!sCompilerProcessFlags.append(\"--no-ssse3\"))
        {\n      return false;\n    }\n  }\n  if (op.getBoolOption(\"no-sse4\") ||
        op.getBoolOption(\"no-sse41\")) {\n    js::jit::CPUInfo::SetSSE41Disabled();\n
        \   if (!sCompilerProcessFlags.append(\"--no-sse41\")) {\n      return false;\n
        \   }\n  }\n  if (op.getBoolOption(\"no-sse42\")) {\n    js::jit::CPUInfo::SetSSE42Disabled();\n
        \   if (!sCompilerProcessFlags.append(\"--no-sse42\")) {\n      return false;\n
        \   }\n  }\n  if (op.getBoolOption(\"no-avx\")) {\n    js::jit::CPUInfo::SetAVXDisabled();\n
        \   if (!sCompilerProcessFlags.append(\"--no-avx\")) {\n      return false;\n
        \   }\n  }\n  if (op.getBoolOption(\"enable-avx\")) {\n    js::jit::CPUInfo::SetAVXEnabled();\n
        \   if (!sCompilerProcessFlags.append(\"--enable-avx\")) {\n      return false;\n
        \   }\n  }\n#endif\n\n  return true;\n}\n\nbool SetGlobalOptionsPostJSInit(const
        OptionParser& op) {\n  if (op.getStringOption(\"telemetry-dir\")) {\n    MOZ_ASSERT(!telemetryLock);\n
        \   telemetryLock = js_new<Mutex>(mutexid::ShellTelemetry);\n    if (!telemetryLock)
        {\n      return false;\n    }\n  }\n\n  // Allow dumping on Linux with the
        fuzzing flag set, even when running with\n  // the suid/sgid flag set on the
        shell.\n#ifdef XP_LINUX\n  if (op.getBoolOption(\"fuzzing-safe\")) {\n    prctl(PR_SET_DUMPABLE,
        1);\n  }\n#endif\n\n#ifdef DEBUG\n  /*\n   * Process OOM options as early
        as possible so that we can observe as many\n   * allocations as possible.\n
        \  */\n  OOM_printAllocationCount = op.getBoolOption('O');\n#endif\n\n  if
        (op.getBoolOption(\"no-threads\")) {\n    js::DisableExtraThreads();\n  }\n\n
        \ enableCodeCoverage = op.getBoolOption(\"code-coverage\");\n  if (enableCodeCoverage)
        {\n    js::EnableCodeCoverage();\n  }\n\n  // If LCov is enabled, then the
        default delazification mode should be changed\n  // to parse everything eagerly,
        such that we know the location of every\n  // instruction, to report them
        in the LCov summary, even if there is no uses\n  // of these instructions.\n
        \ //\n  // Note: code coverage can be enabled either using the --code-coverage
        command\n  // line, or the JS_CODE_COVERAGE_OUTPUT_DIR environment variable,
        which is\n  // processed by JS_InitWithFailureDiagnostic.\n  if (coverage::IsLCovEnabled())
        {\n    defaultDelazificationMode =\n        JS::DelazificationOption::ParseEverythingEagerly;\n
        \ }\n\n  if (const char* xdr = op.getStringOption(\"selfhosted-xdr-path\"))
        {\n    shell::selfHostedXDRPath = xdr;\n  }\n  if (const char* opt = op.getStringOption(\"selfhosted-xdr-mode\"))
        {\n    if (strcmp(opt, \"encode\") == 0) {\n      shell::encodeSelfHostedCode
        = true;\n    } else if (strcmp(opt, \"decode\") == 0) {\n      shell::encodeSelfHostedCode
        = false;\n    } else if (strcmp(opt, \"off\") == 0) {\n      shell::selfHostedXDRPath
        = nullptr;\n    } else {\n      MOZ_CRASH(\n          \"invalid option value
        for --selfhosted-xdr-mode, must be \"\n          \"encode/decode\");\n    }\n
        \ }\n\n#ifdef JS_WITHOUT_NSPR\n  if (!op.getMultiStringOption(\"dll\").empty())
        {\n    fprintf(stderr, \"Error: --dll requires NSPR support!\\n\");\n    return
        false;\n  }\n#else\n  AutoLibraryLoader loader;\n  MultiStringRange dllPaths
        = op.getMultiStringOption(\"dll\");\n  while (!dllPaths.empty()) {\n    char*
        path = dllPaths.front();\n    loader.load(path);\n    dllPaths.popFront();\n
        \ }\n#endif\n\n  if (op.getBoolOption(\"suppress-minidump\")) {\n    js::NoteIntentionalCrash();\n
        \ }\n\n  // The fake CPU count must be set before initializing the Runtime,\n
        \ // which spins up the thread pool.\n  int32_t cpuCount = op.getIntOption(\"cpu-count\");
        \ // What we're really setting\n  if (cpuCount < 0) {\n    cpuCount = op.getIntOption(\"thread-count\");
        \ // Legacy name\n  }\n  if (cpuCount >= 0 && !SetFakeCPUCount(cpuCount))
        {\n    return false;\n  }\n\n  return true;\n}\n\nbool SetContextOptions(JSContext*
        cx, const OptionParser& op) {\n  if (!SetContextWasmOptions(cx, op) || !SetContextJITOptions(cx,
        op) ||\n      !SetContextGCOptions(cx, op)) {\n    return false;\n  }\n\n
        \ enableSourcePragmas = !op.getBoolOption(\"no-source-pragmas\");\n  enableAsyncStacks
        = !op.getBoolOption(\"no-async-stacks\");\n  enableAsyncStackCaptureDebuggeeOnly
        =\n      op.getBoolOption(\"async-stacks-capture-debuggee-only\");\n  enableWeakRefs
        = !op.getBoolOption(\"disable-weak-refs\");\n  enableToSource = !op.getBoolOption(\"disable-tosource\");\n
        \ enablePropertyErrorMessageFix =\n      !op.getBoolOption(\"disable-property-error-message-fix\");\n
        \ enableIteratorHelpers = op.getBoolOption(\"enable-iterator-helpers\");\n
        \ enableShadowRealms = op.getBoolOption(\"enable-shadow-realms\");\n  enableArrayFromAsync
        = op.getBoolOption(\"enable-array-from-async\");\n#ifdef NIGHTLY_BUILD\n  enableArrayGrouping
        = op.getBoolOption(\"enable-array-grouping\");\n  enableWellFormedUnicodeStrings
        =\n      op.getBoolOption(\"enable-well-formed-unicode-strings\");\n#endif\n
        \ enableChangeArrayByCopy = !op.getBoolOption(\"disable-change-array-by-copy\");\n#ifdef
        ENABLE_NEW_SET_METHODS\n  enableNewSetMethods = op.getBoolOption(\"enable-new-set-methods\");\n#endif\n
        \ enableImportAssertions = op.getBoolOption(\"enable-import-assertions\");\n
        \ useFdlibmForSinCosTan = op.getBoolOption(\"use-fdlibm-for-sin-cos-tan\");\n\n
        \ JS::ContextOptionsRef(cx)\n      .setSourcePragmas(enableSourcePragmas)\n
        \     .setAsyncStack(enableAsyncStacks)\n      .setAsyncStackCaptureDebuggeeOnly(enableAsyncStackCaptureDebuggeeOnly)\n
        \     .setImportAssertions(enableImportAssertions);\n\n  JS::SetUseFdlibmForSinCosTan(useFdlibmForSinCosTan);\n\n
        \ if (const char* str = op.getStringOption(\"shared-memory\")) {\n    if (strcmp(str,
        \"off\") == 0) {\n      enableSharedMemory = false;\n    } else if (strcmp(str,
        \"on\") == 0) {\n      enableSharedMemory = true;\n    } else {\n      return
        OptionFailure(\"shared-memory\", str);\n    }\n  }\n\n  reportWarnings = op.getBoolOption('w');\n
        \ compileOnly = op.getBoolOption('c');\n  printTiming = op.getBoolOption('b');\n
        \ enableDisassemblyDumps = op.getBoolOption('D');\n  cx->runtime()->profilingScripts
        =\n      enableCodeCoverage || enableDisassemblyDumps;\n\n#ifdef JS_ENABLE_SMOOSH\n
        \ if (op.getBoolOption(\"smoosh\")) {\n    JS::ContextOptionsRef(cx).setTrySmoosh(true);\n
        \   js::frontend::InitSmoosh();\n  }\n\n  if (const char* filename = op.getStringOption(\"not-implemented-watchfile\"))
        {\n    FILE* out = fopen(filename, \"a\");\n    MOZ_RELEASE_ASSERT(out);\n
        \   setbuf(out, nullptr);  // Make unbuffered\n    cx->runtime()->parserWatcherFile.init(out);\n
        \   JS::ContextOptionsRef(cx).setTrackNotImplemented(true);\n  }\n#endif\n\n
        \ if (const char* mode = op.getStringOption(\"delazification-mode\")) {\n
        \   if (strcmp(mode, \"on-demand\") == 0) {\n      defaultDelazificationMode
        = JS::DelazificationOption::OnDemandOnly;\n    } else if (strcmp(mode, \"concurrent-df\")
        == 0) {\n      defaultDelazificationMode =\n          JS::DelazificationOption::ConcurrentDepthFirst;\n
        \   } else if (strcmp(mode, \"eager\") == 0) {\n      defaultDelazificationMode
        =\n          JS::DelazificationOption::ParseEverythingEagerly;\n    } else
        if (strcmp(mode, \"concurrent-df+on-demand\") == 0 ||\n               strcmp(mode,
        \"on-demand+concurrent-df\") == 0) {\n      defaultDelazificationMode =\n
        \         JS::DelazificationOption::CheckConcurrentWithOnDemand;\n    } else
        {\n      return OptionFailure(\"delazification-mode\", mode);\n    }\n  }\n\n
        \ return true;\n}\n\nbool SetContextWasmOptions(JSContext* cx, const OptionParser&
        op) {\n  enableAsmJS = !op.getBoolOption(\"no-asmjs\");\n\n  enableWasm =
        true;\n  enableWasmBaseline = true;\n  enableWasmOptimizing = true;\n\n  if
        (const char* str = op.getStringOption(\"wasm-compiler\")) {\n    if (strcmp(str,
        \"none\") == 0) {\n      enableWasm = false;\n    } else if (strcmp(str, \"baseline\")
        == 0) {\n      MOZ_ASSERT(enableWasmBaseline);\n      enableWasmOptimizing
        = false;\n    } else if (strcmp(str, \"optimizing\") == 0 ||\n               strcmp(str,
        \"optimized\") == 0) {\n      enableWasmBaseline = false;\n      MOZ_ASSERT(enableWasmOptimizing);\n
        \   } else if (strcmp(str, \"baseline+optimizing\") == 0 ||\n               strcmp(str,
        \"baseline+optimized\") == 0) {\n      MOZ_ASSERT(enableWasmBaseline);\n      MOZ_ASSERT(enableWasmOptimizing);\n
        \   } else if (strcmp(str, \"ion\") == 0) {\n      enableWasmBaseline = false;\n
        \     enableWasmOptimizing = true;\n    } else if (strcmp(str, \"baseline+ion\")
        == 0) {\n      MOZ_ASSERT(enableWasmBaseline);\n      enableWasmOptimizing
        = true;\n    } else {\n      return OptionFailure(\"wasm-compiler\", str);\n
        \   }\n  }\n\n#define WASM_DEFAULT_FEATURE(NAME, LOWER_NAME, COMPILE_PRED,
        COMPILER_PRED, \\\n                             FLAG_PRED, SHELL, ...)                         \\\n
        \ enableWasm##NAME = !op.getBoolOption(\"no-wasm-\" SHELL);\n#define WASM_EXPERIMENTAL_FEATURE(NAME,
        LOWER_NAME, COMPILE_PRED,       \\\n                                  COMPILER_PRED,
        FLAG_PRED, SHELL, ...) \\\n  enableWasm##NAME = op.getBoolOption(\"wasm-\"
        SHELL);\n  JS_FOR_WASM_FEATURES(WASM_DEFAULT_FEATURE, WASM_DEFAULT_FEATURE,\n
        \                      WASM_EXPERIMENTAL_FEATURE);\n#undef WASM_DEFAULT_FEATURE\n#undef
        WASM_EXPERIMENTAL_FEATURE\n\n  enableWasmVerbose = op.getBoolOption(\"wasm-verbose\");\n
        \ enableTestWasmAwaitTier2 = op.getBoolOption(\"test-wasm-await-tier2\");\n\n
        \ JS::ContextOptionsRef(cx)\n      .setAsmJS(enableAsmJS)\n      .setWasm(enableWasm)\n
        \     .setWasmForTrustedPrinciples(enableWasm)\n      .setWasmBaseline(enableWasmBaseline)\n
        \     .setWasmIon(enableWasmOptimizing)\n#define WASM_FEATURE(NAME, ...) .setWasm##NAME(enableWasm##NAME)\n
        \         JS_FOR_WASM_FEATURES(WASM_FEATURE, WASM_FEATURE, WASM_FEATURE)\n#undef
        WASM_FEATURE\n      ;\n\n#ifndef __wasi__\n  // This must be set before self-hosted
        code is initialized, as self-hosted\n  // code reads the property and the
        property may not be changed later.\n  bool disabledHugeMemory = false;\n  if
        (op.getBoolOption(\"disable-wasm-huge-memory\")) {\n    disabledHugeMemory
        = JS::DisableWasmHugeMemory();\n    MOZ_RELEASE_ASSERT(disabledHugeMemory);\n
        \ }\n\n  // --disable-wasm-huge-memory needs to be propagated.  See bug 1518210.\n
        \ if (disabledHugeMemory &&\n      !sCompilerProcessFlags.append(\"--disable-wasm-huge-memory\"))
        {\n    return false;\n  }\n\n  // Also the following are to be propagated.\n
        \ const char* to_propagate[] = {\n#  define WASM_DEFAULT_FEATURE(NAME, LOWER_NAME,
        COMPILE_PRED, COMPILER_PRED, \\\n                               FLAG_PRED,
        SHELL, ...)                         \\\n    \"--no-wasm-\" SHELL,\n#  define
        WASM_EXPERIMENTAL_FEATURE(NAME, LOWER_NAME, COMPILE_PRED,       \\\n                                    COMPILER_PRED,
        FLAG_PRED, SHELL, ...) \\\n    \"--wasm-\" SHELL,\n      JS_FOR_WASM_FEATURES(WASM_DEFAULT_FEATURE,
        WASM_DEFAULT_FEATURE,\n                           WASM_EXPERIMENTAL_FEATURE)\n#
        \ undef WASM_DEFAULT_FEATURE\n#  undef WASM_EXPERIMENTAL_FEATURE\n      //
        Compiler selection options\n      \"--test-wasm-await-tier2\",\n      NULL};\n
        \ for (const char** p = &to_propagate[0]; *p; p++) {\n    if (op.getBoolOption(&(*p)[2]
        /* 2 => skip the leading '--' */)) {\n      if (!sCompilerProcessFlags.append(*p))
        {\n        return false;\n      }\n    }\n  }\n\n  // Also --wasm-compiler=
        is to be propagated.  This is tricky because it is\n  // necessary to reconstitute
        the --wasm-compiler=<whatever> string from its\n  // pieces, without causing
        a leak.  Hence it is copied into a static buffer.\n  // This is thread-unsafe,
        but we're in `main()` and on the process' root\n  // thread.  Also, we do
        this only once -- it wouldn't work properly if we\n  // handled multiple --wasm-compiler=
        flags in a loop.\n  const char* wasm_compiler = op.getStringOption(\"wasm-compiler\");\n
        \ if (wasm_compiler) {\n    size_t n_needed =\n        2 + strlen(\"wasm-compiler\")
        + 1 + strlen(wasm_compiler) + 1;\n    const size_t n_avail = 128;\n    static
        char buf[n_avail];\n    // `n_needed` depends on the compiler name specified.
        \ However, it can't\n    // be arbitrarily long, since previous flag-checking
        should have limited\n    // it to a set of known possibilities: \"baseline\",
        \"ion\",\n    // \"baseline+ion\",  Still, assert this for safety.\n    MOZ_RELEASE_ASSERT(n_needed
        < n_avail);\n    memset(buf, 0, sizeof(buf));\n    SprintfBuf(buf, n_avail,
        \"--%s=%s\", \"wasm-compiler\", wasm_compiler);\n    if (!sCompilerProcessFlags.append(buf))
        {\n      return false;\n    }\n  }\n#endif  // __wasi__\n\n  return true;\n}\n\nbool
        SetContextJITOptions(JSContext* cx, const OptionParser& op) {\n  // Check
        --fast-warmup first because it sets default warm-up thresholds. These\n  //
        thresholds can then be overridden below by --ion-eager and other flags.\n
        \ if (op.getBoolOption(\"fast-warmup\")) {\n    jit::JitOptions.setFastWarmUp();\n
        \ }\n\n  if (op.getBoolOption(\"no-ion-for-main-context\")) {\n    JS::ContextOptionsRef(cx).setDisableIon();\n
        \ }\n\n  if (const char* str = op.getStringOption(\"cache-ir-stubs\")) {\n
        \   if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableCacheIR
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableCacheIR
        = true;\n    } else {\n      return OptionFailure(\"cache-ir-stubs\", str);\n
        \   }\n  }\n\n  if (const char* str = op.getStringOption(\"spectre-mitigations\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.spectreIndexMasking
        = true;\n      jit::JitOptions.spectreObjectMitigations = true;\n      jit::JitOptions.spectreStringMitigations
        = true;\n      jit::JitOptions.spectreValueMasking = true;\n      jit::JitOptions.spectreJitToCxxCalls
        = true;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.spectreIndexMasking
        = false;\n      jit::JitOptions.spectreObjectMitigations = false;\n      jit::JitOptions.spectreStringMitigations
        = false;\n      jit::JitOptions.spectreValueMasking = false;\n      jit::JitOptions.spectreJitToCxxCalls
        = false;\n    } else {\n      return OptionFailure(\"spectre-mitigations\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-scalar-replacement\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableScalarReplacement
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableScalarReplacement
        = true;\n    } else {\n      return OptionFailure(\"ion-scalar-replacement\",
        str);\n    }\n  }\n\n  if (op.getStringOption(\"ion-shared-stubs\")) {\n    //
        Dead option, preserved for now for potential fuzzer interaction.\n  }\n\n
        \ if (const char* str = op.getStringOption(\"ion-gvn\")) {\n    if (strcmp(str,
        \"off\") == 0) {\n      jit::JitOptions.disableGvn = true;\n    } else if
        (strcmp(str, \"on\") != 0 && strcmp(str, \"optimistic\") != 0 &&\n               strcmp(str,
        \"pessimistic\") != 0) {\n      // We accept \"pessimistic\" and \"optimistic\"
        as synonyms for \"on\"\n      // for backwards compatibility.\n      return
        OptionFailure(\"ion-gvn\", str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-licm\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableLicm
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableLicm
        = true;\n    } else {\n      return OptionFailure(\"ion-licm\", str);\n    }\n
        \ }\n\n  if (const char* str = op.getStringOption(\"ion-edgecase-analysis\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableEdgeCaseAnalysis
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableEdgeCaseAnalysis
        = true;\n    } else {\n      return OptionFailure(\"ion-edgecase-analysis\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-pruning\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disablePruning
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disablePruning
        = true;\n    } else {\n      return OptionFailure(\"ion-pruning\", str);\n
        \   }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-range-analysis\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableRangeAnalysis
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableRangeAnalysis
        = true;\n    } else {\n      return OptionFailure(\"ion-range-analysis\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-sink\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableSink
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableSink
        = true;\n    } else {\n      return OptionFailure(\"ion-sink\", str);\n    }\n
        \ }\n\n  if (const char* str = op.getStringOption(\"ion-optimize-shapeguards\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableRedundantShapeGuards
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableRedundantShapeGuards
        = true;\n    } else {\n      return OptionFailure(\"ion-optimize-shapeguards\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-optimize-gcbarriers\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableRedundantGCBarriers
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableRedundantGCBarriers
        = true;\n    } else {\n      return OptionFailure(\"ion-optimize-gcbarriers\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-instruction-reordering\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableInstructionReordering
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableInstructionReordering
        = true;\n    } else {\n      return OptionFailure(\"ion-instruction-reordering\",
        str);\n    }\n  }\n\n  if (op.getBoolOption(\"ion-check-range-analysis\"))
        {\n    jit::JitOptions.checkRangeAnalysis = true;\n  }\n\n  if (op.getBoolOption(\"ion-extra-checks\"))
        {\n    jit::JitOptions.runExtraChecks = true;\n  }\n\n  if (const char* str
        = op.getStringOption(\"ion-inlining\")) {\n    if (strcmp(str, \"on\") ==
        0) {\n      jit::JitOptions.disableInlining = false;\n    } else if (strcmp(str,
        \"off\") == 0) {\n      jit::JitOptions.disableInlining = true;\n    } else
        {\n      return OptionFailure(\"ion-inlining\", str);\n    }\n  }\n\n  if
        (const char* str = op.getStringOption(\"ion-osr\")) {\n    if (strcmp(str,
        \"on\") == 0) {\n      jit::JitOptions.osr = true;\n    } else if (strcmp(str,
        \"off\") == 0) {\n      jit::JitOptions.osr = false;\n    } else {\n      return
        OptionFailure(\"ion-osr\", str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-limit-script-size\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.limitScriptSize
        = true;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.limitScriptSize
        = false;\n    } else {\n      return OptionFailure(\"ion-limit-script-size\",
        str);\n    }\n  }\n\n  int32_t warmUpThreshold = op.getIntOption(\"ion-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.setNormalIonWarmUpThreshold(warmUpThreshold);\n
        \ }\n\n  warmUpThreshold = op.getIntOption(\"baseline-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.baselineJitWarmUpThreshold
        = warmUpThreshold;\n  }\n\n  warmUpThreshold = op.getIntOption(\"trial-inlining-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.trialInliningWarmUpThreshold
        = warmUpThreshold;\n  }\n\n  warmUpThreshold = op.getIntOption(\"regexp-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.regexpWarmUpThreshold =
        warmUpThreshold;\n  }\n\n  if (op.getBoolOption(\"baseline-eager\")) {\n    jit::JitOptions.setEagerBaselineCompilation();\n
        \ }\n\n  if (op.getBoolOption(\"blinterp\")) {\n    jit::JitOptions.baselineInterpreter
        = true;\n  }\n\n  if (op.getBoolOption(\"no-blinterp\")) {\n    jit::JitOptions.baselineInterpreter
        = false;\n  }\n\n  if (op.getBoolOption(\"disable-jithints\")) {\n    jit::JitOptions.disableJitHints
        = true;\n  }\n\n  if (op.getBoolOption(\"emit-interpreter-entry\")) {\n    jit::JitOptions.emitInterpreterEntryTrampoline
        = true;\n  }\n\n  if (op.getBoolOption(\"no-emit-interpreter-entry\")) {\n
        \   jit::JitOptions.emitInterpreterEntryTrampoline = false;\n  }\n\n  warmUpThreshold
        = op.getIntOption(\"blinterp-warmup-threshold\");\n  if (warmUpThreshold >=
        0) {\n    jit::JitOptions.baselineInterpreterWarmUpThreshold = warmUpThreshold;\n
        \ }\n\n  if (op.getBoolOption(\"blinterp-eager\")) {\n    jit::JitOptions.baselineInterpreterWarmUpThreshold
        = 0;\n  }\n\n  if (op.getBoolOption(\"no-baseline\")) {\n    jit::JitOptions.baselineJit
        = false;\n  }\n\n  if (op.getBoolOption(\"no-ion\")) {\n    jit::JitOptions.ion
        = false;\n  }\n\n  if (op.getBoolOption(\"no-native-regexp\")) {\n    jit::JitOptions.nativeRegExp
        = false;\n  }\n\n  if (op.getBoolOption(\"trace-regexp-parser\")) {\n    jit::JitOptions.trace_regexp_parser
        = true;\n  }\n  if (op.getBoolOption(\"trace-regexp-assembler\")) {\n    jit::JitOptions.trace_regexp_assembler
        = true;\n  }\n  if (op.getBoolOption(\"trace-regexp-interpreter\")) {\n    jit::JitOptions.trace_regexp_bytecodes
        = true;\n  }\n  if (op.getBoolOption(\"trace-regexp-peephole\")) {\n    jit::JitOptions.trace_regexp_peephole_optimization
        = true;\n  }\n\n  if (op.getBoolOption(\"less-debug-code\")) {\n    jit::JitOptions.lessDebugCode
        = true;\n  }\n\n  int32_t inliningEntryThreshold = op.getIntOption(\"inlining-entry-threshold\");\n
        \ if (inliningEntryThreshold > 0) {\n    jit::JitOptions.inliningEntryThreshold
        = inliningEntryThreshold;\n  }\n\n  int32_t smallFunctionLength = op.getIntOption(\"small-function-length\");\n
        \ if (smallFunctionLength > 0) {\n    jit::JitOptions.smallFunctionMaxBytecodeLength
        = smallFunctionLength;\n  }\n\n  if (const char* str = op.getStringOption(\"ion-regalloc\"))
        {\n    jit::JitOptions.forcedRegisterAllocator = jit::LookupRegisterAllocator(str);\n
        \   if (!jit::JitOptions.forcedRegisterAllocator.isSome()) {\n      return
        OptionFailure(\"ion-regalloc\", str);\n    }\n  }\n\n  if (op.getBoolOption(\"ion-eager\"))
        {\n    jit::JitOptions.setEagerIonCompilation();\n  }\n\n  offthreadCompilation
        = true;\n  if (const char* str = op.getStringOption(\"ion-offthread-compile\"))
        {\n    if (strcmp(str, \"off\") == 0) {\n      offthreadCompilation = false;\n
        \   } else if (strcmp(str, \"on\") != 0) {\n      return OptionFailure(\"ion-offthread-compile\",
        str);\n    }\n  }\n  cx->runtime()->setOffthreadIonCompilationEnabled(offthreadCompilation);\n\n
        \ if (op.getStringOption(\"ion-parallel-compile\")) {\n    fprintf(stderr,\n
        \           \"--ion-parallel-compile is deprecated. Please use \"\n            \"--ion-offthread-compile
        instead.\\n\");\n    return false;\n  }\n\n  if (op.getBoolOption(\"disable-bailout-loop-check\"))
        {\n    jit::JitOptions.disableBailoutLoopCheck = true;\n  }\n\n  if (op.getBoolOption(\"enable-watchtower\"))
        {\n    jit::JitOptions.enableWatchtowerMegamorphic = true;\n  }\n  if (op.getBoolOption(\"disable-watchtower\"))
        {\n    jit::JitOptions.enableWatchtowerMegamorphic = false;\n  }\n  if (op.getBoolOption(\"only-inline-selfhosted\"))
        {\n    jit::JitOptions.onlyInlineSelfHosted = true;\n  }\n\n  if (op.getBoolOption(\"enable-ic-frame-pointers\"))
        {\n    jit::JitOptions.enableICFramePointers = true;\n  }\n\n  if (const char*
        str = op.getStringOption(\"ion-iterator-indices\")) {\n    if (strcmp(str,
        \"on\") == 0) {\n      jit::JitOptions.disableIteratorIndices = false;\n    }
        else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableIteratorIndices
        = true;\n    } else {\n      return OptionFailure(\"ion-iterator-indices\",
        str);\n    }\n  }\n\n#if defined(JS_SIMULATOR_ARM)\n  if (op.getBoolOption(\"arm-sim-icache-checks\"))
        {\n    jit::SimulatorProcess::ICacheCheckingDisableCount = 0;\n  }\n\n  int32_t
        stopAt = op.getIntOption(\"arm-sim-stop-at\");\n  if (stopAt >= 0) {\n    jit::Simulator::StopSimAt
        = stopAt;\n  }\n#elif defined(JS_SIMULATOR_MIPS32) || defined(JS_SIMULATOR_MIPS64)\n
        \ if (op.getBoolOption(\"mips-sim-icache-checks\")) {\n    jit::SimulatorProcess::ICacheCheckingDisableCount
        = 0;\n  }\n\n  int32_t stopAt = op.getIntOption(\"mips-sim-stop-at\");\n  if
        (stopAt >= 0) {\n    jit::Simulator::StopSimAt = stopAt;\n  }\n#elif defined(JS_SIMULATOR_LOONG64)\n
        \ if (op.getBoolOption(\"loong64-sim-icache-checks\")) {\n    jit::SimulatorProcess::ICacheCheckingDisableCount
        = 0;\n  }\n\n  int32_t stopAt = op.getIntOption(\"loong64-sim-stop-at\");\n
        \ if (stopAt >= 0) {\n    jit::Simulator::StopSimAt = stopAt;\n  }\n#endif\n\n#ifdef
        DEBUG\n#  ifdef JS_CODEGEN_RISCV64\n  if (op.getBoolOption(\"riscv-debug\"))
        {\n    jit::Assembler::FLAG_riscv_debug = true;\n  }\n#  endif\n#  ifdef JS_SIMULATOR_RISCV64\n
        \ if (op.getBoolOption(\"trace-sim\")) {\n    jit::Simulator::FLAG_trace_sim
        = true;\n  }\n  if (op.getBoolOption(\"debug-sim\")) {\n    jit::Simulator::FLAG_debug_sim
        = true;\n  }\n  if (op.getBoolOption(\"riscv-trap-to-simulator-debugger\"))
        {\n    jit::Simulator::FLAG_riscv_trap_to_simulator_debugger = true;\n  }\n
        \ int32_t stopAt = op.getIntOption(\"riscv-sim-stop-at\");\n  if (stopAt >=
        0) {\n    jit::Simulator::StopSimAt = stopAt;\n  }\n#  endif\n#endif\n\n  return
        true;\n}\n\nbool SetContextGCOptions(JSContext* cx, const OptionParser& op)
        {\n  JS_SetGCParameter(cx, JSGC_MAX_BYTES, 0xffffffff);\n\n  size_t nurseryBytes
        = op.getIntOption(\"nursery-size\") * 1024L * 1024L;\n  if (nurseryBytes ==
        0) {\n    fprintf(stderr, \"Error: --nursery-size parameter must be non-zero.\\n\");\n
        \   fprintf(stderr,\n            \"The nursery can be disabled by passing
        the --no-ggc option.\\n\");\n    return false;\n  }\n  JS_SetGCParameter(cx,
        JSGC_MAX_NURSERY_BYTES, nurseryBytes);\n\n  size_t availMemMB = op.getIntOption(\"available-memory\");\n
        \ if (availMemMB > 0) {\n    JS_SetGCParametersBasedOnAvailableMemory(cx,
        availMemMB);\n  }\n\n  if (const char* opt = op.getStringOption(\"nursery-strings\"))
        {\n    if (strcmp(opt, \"on\") == 0) {\n      cx->runtime()->gc.nursery().enableStrings();\n
        \   } else if (strcmp(opt, \"off\") == 0) {\n      cx->runtime()->gc.nursery().disableStrings();\n
        \   } else {\n      MOZ_CRASH(\"invalid option value for --nursery-strings,
        must be on/off\");\n    }\n  }\n\n  if (const char* opt = op.getStringOption(\"nursery-bigints\"))
        {\n    if (strcmp(opt, \"on\") == 0) {\n      cx->runtime()->gc.nursery().enableBigInts();\n
        \   } else if (strcmp(opt, \"off\") == 0) {\n      cx->runtime()->gc.nursery().disableBigInts();\n
        \   } else {\n      MOZ_CRASH(\"invalid option value for --nursery-bigints,
        must be on/off\");\n    }\n  }\n\n  bool incrementalGC = !op.getBoolOption(\"no-incremental-gc\");\n
        \ JS_SetGCParameter(cx, JSGC_INCREMENTAL_GC_ENABLED, incrementalGC);\n\n  if
        (op.getBoolOption(\"enable-parallel-marking\")) {\n    JS_SetGCParameter(cx,
        JSGC_PARALLEL_MARKING_ENABLED, true);\n  }\n  int32_t markingThreads = op.getIntOption(\"marking-threads\");\n
        \ if (markingThreads > 0) {\n    JS_SetGCParameter(cx, JSGC_MARKING_THREAD_COUNT,
        markingThreads);\n  }\n\n  JS_SetGCParameter(cx, JSGC_SLICE_TIME_BUDGET_MS,
        5);\n\n  JS_SetGCParameter(cx, JSGC_PER_ZONE_GC_ENABLED, true);\n\n  for (MultiStringRange
        args = op.getMultiStringOption(\"gc-param\");\n       !args.empty(); args.popFront())
        {\n    if (!SetGCParameterFromArg(cx, args.front())) {\n      return false;\n
        \   }\n  }\n\n#ifdef DEBUG\n  dumpEntrainedVariables = op.getBoolOption(\"dump-entrained-variables\");\n#endif\n\n#ifdef
        JS_GC_ZEAL\n  const char* zealStr = op.getStringOption(\"gc-zeal\");\n  if
        (zealStr) {\n    if (!cx->runtime()->gc.parseAndSetZeal(zealStr)) {\n      return
        false;\n    }\n    uint32_t nextScheduled;\n    cx->runtime()->gc.getZealBits(&gZealBits,
        &gZealFrequency, &nextScheduled);\n  }\n#endif\n\n  return true;\n}\n\nbool
        InitModuleLoader(JSContext* cx, const OptionParser& op) {\n  RootedString
        moduleLoadPath(cx);\n  if (const char* option = op.getStringOption(\"module-load-path\"))
        {\n    UniqueChars pathUtf8 = JS::EncodeNarrowToUtf8(cx, option);\n    if
        (!pathUtf8) {\n      return false;\n    }\n\n    Rooted<JSString*> jspath(cx,
        NewStringCopyUTF8(cx, pathUtf8.get()));\n    if (!jspath) {\n      return
        false;\n    }\n\n    moduleLoadPath = js::shell::ResolvePath(cx, jspath, RootRelative);\n\n
        \   processWideModuleLoadPath = JS_EncodeStringToUTF8(cx, moduleLoadPath);\n
        \   if (!processWideModuleLoadPath) {\n      return false;\n    }\n  } else
        {\n    processWideModuleLoadPath = js::shell::GetCWD(cx);\n    if (!processWideModuleLoadPath)
        {\n      return false;\n    }\n\n    moduleLoadPath = NewStringCopyUTF8(cx,
        processWideModuleLoadPath.get());\n    if (!moduleLoadPath) {\n      return
        false;\n    }\n  }\n\n  ShellContext* sc = GetShellContext(cx);\n  sc->moduleLoader
        = js::MakeUnique<ModuleLoader>();\n  if (!sc->moduleLoader || !sc->moduleLoader->init(cx,
        moduleLoadPath)) {\n    return false;\n  }\n\n  return true;\n}\n"
    headers:
      Access-Control-Allow-Origin:
      - '*'
      Cache-Control:
      - no-cache
      Connection:
      - Keep-Alive
      Content-Disposition:
      - inline; filename="js.cpp"
      Content-Security-Policy:
      - 'default-src ''none''; connect-src ''self'' https://bugzilla.mozilla.org/;
        img-src ''self''; script-src https://hg.mozilla.org/static/ ''nonce-3FIdQkjIStaILVAkYabODQ'';
        style-src ''self'' ''unsafe-inline''; upgrade-insecure-requests; frame-ancestors
        https:'
      Content-Type:
      - text/plain; charset="UTF-8"
      Date:
      - Tue, 23 Jul 2024 14:09:15 GMT
      Server:
      - Apache
      Strict-Transport-Security:
      - max-age=31536000
      Transfer-Encoding:
      - chunked
      Vary:
      - Accept-Encoding
      X-Cache-Info:
      - 'not cacheable; response specified "Cache-Control: no-cache"'
      X-Content-Type-Options:
      - nosniff
      content-length:
      - '387856'
    status:
      code: 200
      message: Script output follows
- request:
    body: null
    headers:
      Accept:
      - '*/*'
      Accept-Encoding:
      - gzip, deflate
      Connection:
      - keep-alive
      User-Agent:
      - python-requests/2.27.1
    method: GET
    uri: https://hg.mozilla.org/mozilla-unified/raw-file/tip/js/src/shell/js.cpp
  response:
    body:
      string: "/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset:
        2 -*-\n * vim: set ts=8 sts=2 et sw=2 tw=80:\n * This Source Code Form is
        subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy
        of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.
        */\n\n/* JS shell. */\n\n#include \"mozilla/AlreadyAddRefed.h\"  // mozilla::already_AddRefed\n#include
        \"mozilla/ArrayUtils.h\"\n#include \"mozilla/Assertions.h\"  // MOZ_ASSERT,
        MOZ_ASSERT_IF, MOZ_RELEASE_ASSERT, MOZ_CRASH\n#include \"mozilla/Atomics.h\"\n#include
        \"mozilla/Attributes.h\"\n#include \"mozilla/Compression.h\"\n#include \"mozilla/DebugOnly.h\"\n#include
        \"mozilla/EnumSet.h\"\n#include \"mozilla/IntegerPrintfMacros.h\"\n#include
        \"mozilla/mozalloc.h\"\n#include \"mozilla/PodOperations.h\"\n#include \"mozilla/RandomNum.h\"\n#include
        \"mozilla/RefPtr.h\"\n#include \"mozilla/ScopeExit.h\"\n#include \"mozilla/Sprintf.h\"\n#include
        \"mozilla/TimeStamp.h\"\n#include \"mozilla/UniquePtrExtensions.h\"  // UniqueFreePtr\n#include
        \"mozilla/Utf8.h\"\n#include \"mozilla/Variant.h\"\n\n#include <algorithm>\n#include
        <chrono>\n#ifdef XP_WIN\n#  include <direct.h>\n#  include <process.h>\n#endif\n#include
        <errno.h>\n#include <fcntl.h>\n#if defined(XP_WIN)\n#  include <io.h> /* for
        isatty() */\n#endif\n#include <locale.h>\n#if defined(MALLOC_H)\n#  include
        MALLOC_H /* for malloc_usable_size, malloc_size, _msize */\n#endif\n#include
        <ctime>\n#include <math.h>\n#ifndef __wasi__\n#  include <signal.h>\n#endif\n#include
        <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include
        <sys/types.h>\n#include <utility>\n#ifdef XP_UNIX\n#  ifndef __wasi__\n#    include
        <sys/mman.h>\n#    include <sys/wait.h>\n#  endif\n#  include <sys/stat.h>\n#
        \ include <unistd.h>\n#endif\n#ifdef XP_LINUX\n#  include <sys/prctl.h>\n#endif\n\n#include
        \"jsapi.h\"\n#include \"jsfriendapi.h\"\n#include \"jstypes.h\"\n#ifndef JS_WITHOUT_NSPR\n#
        \ include \"prerror.h\"\n#  include \"prlink.h\"\n#endif\n\n#include \"builtin/Array.h\"\n#include
        \"builtin/MapObject.h\"\n#include \"builtin/ModuleObject.h\"\n#include \"builtin/RegExp.h\"\n#include
        \"builtin/TestingFunctions.h\"\n#include \"builtin/TestingUtility.h\"  //
        js::ParseCompileOptions, js::ParseDebugMetadata, js::CreateScriptPrivate\n#include
        \"debugger/DebugAPI.h\"\n#include \"frontend/BytecodeCompiler.h\"  // frontend::{CompileGlobalScriptToExtensibleStencil,
        CompileModule, ParseModuleToExtensibleStencil}\n#include \"frontend/CompilationStencil.h\"\n#ifdef
        JS_ENABLE_SMOOSH\n#  include \"frontend/Frontend2.h\"\n#endif\n#include \"frontend/FrontendContext.h\"
        \ // AutoReportFrontendContext\n#include \"frontend/ModuleSharedContext.h\"\n#include
        \"frontend/Parser.h\"\n#include \"frontend/ScopeBindingCache.h\"  // js::frontend::ScopeBindingCache\n#include
        \"gc/GC.h\"\n#include \"gc/PublicIterators.h\"\n#ifdef DEBUG\n#  include \"irregexp/RegExpAPI.h\"\n#endif\n\n#ifdef
        JS_SIMULATOR_ARM\n#  include \"jit/arm/Simulator-arm.h\"\n#endif\n#ifdef JS_SIMULATOR_MIPS32\n#
        \ include \"jit/mips32/Simulator-mips32.h\"\n#endif\n#ifdef JS_SIMULATOR_MIPS64\n#
        \ include \"jit/mips64/Simulator-mips64.h\"\n#endif\n#ifdef JS_SIMULATOR_LOONG64\n#
        \ include \"jit/loong64/Simulator-loong64.h\"\n#endif\n#ifdef JS_SIMULATOR_RISCV64\n#
        \ include \"jit/riscv64/Simulator-riscv64.h\"\n#endif\n#include \"jit/CacheIRHealth.h\"\n#include
        \"jit/InlinableNatives.h\"\n#include \"jit/Ion.h\"\n#include \"jit/JitcodeMap.h\"\n#include
        \"jit/JitZone.h\"\n#include \"jit/shared/CodeGenerator-shared.h\"\n#include
        \"js/Array.h\"        // JS::NewArrayObject\n#include \"js/ArrayBuffer.h\"
        \ // JS::{CreateMappedArrayBufferContents,NewMappedArrayBufferWithContents,IsArrayBufferObject,GetArrayBufferLengthAndData}\n#include
        \"js/BuildId.h\"      // JS::BuildIdCharVector, JS::SetProcessBuildIdOp\n#include
        \"js/CallAndConstruct.h\"  // JS::Call, JS::IsCallable, JS_CallFunction, JS_CallFunctionValue\n#include
        \"js/CharacterEncoding.h\"  // JS::StringIsASCII\n#include \"js/CompilationAndEvaluation.h\"\n#include
        \"js/CompileOptions.h\"  // JS::ReadOnlyCompileOptions, JS::CompileOptions,
        JS::OwningCompileOptions, JS::DecodeOptions, JS::InstantiateOptions\n#include
        \"js/ContextOptions.h\"  // JS::ContextOptions{,Ref}\n#include \"js/Debug.h\"
        \          // JS::dbg::ShouldAvoidSideEffects\n#include \"js/Equality.h\"
        \       // JS::SameValue\n#include \"js/ErrorReport.h\"     // JS::PrintError\n#include
        \"js/Exception.h\"       // JS::StealPendingExceptionStack\n#include \"js/experimental/CodeCoverage.h\"
        \  // js::EnableCodeCoverage\n#include \"js/experimental/CompileScript.h\"
        \ // JS::NewFrontendContext, JS::DestroyFrontendContext, JS::HadFrontendErrors,
        JS::ConvertFrontendErrorsToRuntimeErrors, JS::CompileGlobalScriptToStencil,
        JS::CompileModuleScriptToStencil\n#include \"js/experimental/CTypes.h\"         //
        JS::InitCTypesClass\n#include \"js/experimental/Intl.h\"  // JS::AddMoz{DateTimeFormat,DisplayNames}Constructor\n#include
        \"js/experimental/JitInfo.h\"  // JSJit{Getter,Setter,Method}CallArgs, JSJitGetterInfo,
        JSJit{Getter,Setter}Op, JSJitInfo\n#include \"js/experimental/JSStencil.h\"
        \  // JS::Stencil, JS::DecodeStencil\n#include \"js/experimental/SourceHook.h\"
        \ // js::{Set,Forget,}SourceHook\n#include \"js/experimental/TypedData.h\"
        \  // JS_NewUint8Array\n#include \"js/friend/DumpFunctions.h\"     // JS::FormatStackDump\n#include
        \"js/friend/ErrorMessages.h\"     // js::GetErrorMessage, JSMSG_*\n#include
        \"js/friend/StackLimits.h\"       // js::AutoCheckRecursionLimit\n#include
        \"js/friend/WindowProxy.h\"  // js::IsWindowProxy, js::SetWindowProxyClass,
        js::ToWindowProxyIfWindow, js::ToWindowIfWindowProxy\n#include \"js/GCAPI.h\"
        \              // JS::AutoCheckCannotGC\n#include \"js/GCVector.h\"\n#include
        \"js/GlobalObject.h\"\n#include \"js/Initialization.h\"\n#include \"js/Interrupt.h\"\n#include
        \"js/JSON.h\"\n#include \"js/MemoryCallbacks.h\"\n#include \"js/MemoryFunctions.h\"\n#include
        \"js/Modules.h\"  // JS::GetModulePrivate, JS::SetModule{DynamicImport,Metadata,Resolve}Hook,
        JS::SetModulePrivate\n#include \"js/Object.h\"  // JS::GetClass, JS::GetCompartment,
        JS::GetReservedSlot, JS::SetReservedSlot\n#include \"js/Prefs.h\"\n#include
        \"js/Principals.h\"\n#include \"js/Printer.h\"  // QuoteString\n#include \"js/Printf.h\"\n#include
        \"js/PropertyAndElement.h\"  // JS_DefineElement, JS_DefineFunction, JS_DefineFunctions,
        JS_DefineProperties, JS_DefineProperty, JS_GetElement, JS_GetProperty, JS_GetPropertyById,
        JS_HasProperty, JS_SetElement, JS_SetProperty, JS_SetPropertyById\n#include
        \"js/PropertySpec.h\"\n#include \"js/Realm.h\"\n#include \"js/RegExp.h\"  //
        JS::ObjectIsRegExp\n#include \"js/ScriptPrivate.h\"\n#include \"js/SourceText.h\"
        \ // JS::SourceText\n#include \"js/StableStringChars.h\"\n#include \"js/Stack.h\"\n#include
        \"js/StreamConsumer.h\"\n#include \"js/StructuredClone.h\"\n#include \"js/SweepingAPI.h\"\n#include
        \"js/Transcoding.h\"  // JS::TranscodeBuffer, JS::TranscodeRange, JS::IsTranscodeFailureResult\n#include
        \"js/Warnings.h\"    // JS::SetWarningReporter\n#include \"js/WasmModule.h\"
        \ // JS::WasmModule\n#include \"js/Wrapper.h\"\n#include \"proxy/DeadObjectProxy.h\"
        \ // js::IsDeadProxyObject\n#include \"shell/jsoptparse.h\"\n#include \"shell/jsshell.h\"\n#include
        \"shell/OSObject.h\"\n#include \"shell/ShellModuleObjectWrapper.h\"\n#include
        \"shell/WasmTesting.h\"\n#include \"threading/ConditionVariable.h\"\n#include
        \"threading/ExclusiveData.h\"\n#include \"threading/LockGuard.h\"\n#include
        \"threading/Thread.h\"\n#include \"util/CompleteFile.h\"  // js::FileContents,
        js::ReadCompleteFile\n#include \"util/DifferentialTesting.h\"\n#include \"util/StringBuffer.h\"\n#include
        \"util/Text.h\"\n#include \"util/WindowsWrapper.h\"\n#include \"vm/ArgumentsObject.h\"\n#include
        \"vm/Compression.h\"\n#include \"vm/ErrorObject.h\"\n#include \"vm/ErrorReporting.h\"\n#include
        \"vm/HelperThreads.h\"\n#include \"vm/JSAtomUtils.h\"  // AtomizeUTF8Chars,
        AtomizeString, ToAtom\n#include \"vm/JSContext.h\"\n#include \"vm/JSFunction.h\"\n#include
        \"vm/JSObject.h\"\n#include \"vm/JSScript.h\"\n#include \"vm/ModuleBuilder.h\"
        \ // js::ModuleBuilder\n#include \"vm/Modules.h\"\n#include \"vm/Monitor.h\"\n#include
        \"vm/MutexIDs.h\"\n#include \"vm/PromiseObject.h\"  // js::PromiseObject\n#include
        \"vm/Shape.h\"\n#include \"vm/SharedArrayObject.h\"\n#include \"vm/StencilObject.h\"
        \ // js::StencilObject\n#include \"vm/Time.h\"\n#include \"vm/ToSource.h\"
        \ // js::ValueToSource\n#include \"vm/TypedArrayObject.h\"\n#include \"vm/WrapperObject.h\"\n#include
        \"wasm/WasmFeatures.h\"\n#include \"wasm/WasmJS.h\"\n\n#include \"vm/Compartment-inl.h\"\n#include
        \"vm/ErrorObject-inl.h\"\n#include \"vm/Interpreter-inl.h\"\n#include \"vm/JSObject-inl.h\"\n#include
        \"vm/Realm-inl.h\"\n#include \"vm/Stack-inl.h\"\n\n#undef compress\n\nusing
        namespace js;\nusing namespace js::cli;\nusing namespace js::shell;\n\nusing
        JS::AutoStableStringChars;\nusing JS::CompileOptions;\n\nusing js::shell::RCFile;\n\nusing
        mozilla::ArrayEqual;\nusing mozilla::AsVariant;\nusing mozilla::Atomic;\nusing
        mozilla::MakeScopeExit;\nusing mozilla::Maybe;\nusing mozilla::Nothing;\nusing
        mozilla::NumberEqualsInt32;\nusing mozilla::TimeDuration;\nusing mozilla::TimeStamp;\nusing
        mozilla::Utf8Unit;\nusing mozilla::Variant;\n\nbool InitOptionParser(OptionParser&
        op);\nbool SetGlobalOptionsPreJSInit(const OptionParser& op);\nbool SetGlobalOptionsPostJSInit(const
        OptionParser& op);\nbool SetContextOptions(JSContext* cx, const OptionParser&
        op);\nbool SetContextWasmOptions(JSContext* cx, const OptionParser& op);\nbool
        SetContextJITOptions(JSContext* cx, const OptionParser& op);\nbool SetContextGCOptions(JSContext*
        cx, const OptionParser& op);\nbool InitModuleLoader(JSContext* cx, const OptionParser&
        op);\n\n#ifdef FUZZING_JS_FUZZILLI\n#  define REPRL_CRFD 100\n#  define REPRL_CWFD
        101\n#  define REPRL_DRFD 102\n#  define REPRL_DWFD 103\n\n#  define SHM_SIZE
        0x100000\n#  define MAX_EDGES ((SHM_SIZE - 4) * 8)\n\nstruct shmem_data {\n
        \ uint32_t num_edges;\n  unsigned char edges[];\n};\n\nstruct shmem_data*
        __shmem;\n\nuint32_t *__edges_start, *__edges_stop;\nvoid __sanitizer_cov_reset_edgeguards()
        {\n  uint64_t N = 0;\n  for (uint32_t* x = __edges_start; x < __edges_stop
        && N < MAX_EDGES; x++)\n    *x = ++N;\n}\n\nextern \"C\" void __sanitizer_cov_trace_pc_guard_init(uint32_t*
        start,\n                                                    uint32_t* stop)
        {\n  // Avoid duplicate initialization\n  if (start == stop || *start) return;\n\n
        \ if (__edges_start != NULL || __edges_stop != NULL) {\n    fprintf(stderr,\n
        \           \"Coverage instrumentation is only supported for a single module\\n\");\n
        \   _exit(-1);\n  }\n\n  __edges_start = start;\n  __edges_stop = stop;\n\n
        \ // Map the shared memory region\n  const char* shm_key = getenv(\"SHM_ID\");\n
        \ if (!shm_key) {\n    puts(\"[COV] no shared memory bitmap available, skipping\");\n
        \   __shmem = (struct shmem_data*)malloc(SHM_SIZE);\n  } else {\n    int fd
        = shm_open(shm_key, O_RDWR, S_IREAD | S_IWRITE);\n    if (fd <= -1) {\n      fprintf(stderr,
        \"Failed to open shared memory region: %s\\n\",\n              strerror(errno));\n
        \     _exit(-1);\n    }\n\n    __shmem = (struct shmem_data*)mmap(0, SHM_SIZE,
        PROT_READ | PROT_WRITE,\n                                       MAP_SHARED,
        fd, 0);\n    if (__shmem == MAP_FAILED) {\n      fprintf(stderr, \"Failed
        to mmap shared memory region\\n\");\n      _exit(-1);\n    }\n  }\n\n  __sanitizer_cov_reset_edgeguards();\n\n
        \ __shmem->num_edges = stop - start;\n  printf(\"[COV] edge counters initialized.
        Shared memory: %s with %u edges\\n\",\n         shm_key, __shmem->num_edges);\n}\n\nextern
        \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t* guard) {\n  // There's
        a small race condition here: if this function executes in two\n  // threads
        for the same edge at the same time, the first thread might disable\n  // the
        edge (by setting the guard to zero) before the second thread fetches\n  //
        the guard value (and thus the index). However, our instrumentation ignores\n
        \ // the first edge (see libcoverage.c) and so the race is unproblematic.\n
        \ uint32_t index = *guard;\n  // If this function is called before coverage
        instrumentation is properly\n  // initialized we want to return early.\n  if
        (!index) return;\n  __shmem->edges[index / 8] |= 1 << (index % 8);\n  *guard
        = 0;\n}\n#endif /* FUZZING_JS_FUZZILLI */\n\nenum JSShellExitCode {\n  EXITCODE_RUNTIME_ERROR
        = 3,\n  EXITCODE_FILE_NOT_FOUND = 4,\n  EXITCODE_OUT_OF_MEMORY = 5,\n  EXITCODE_TIMEOUT
        = 6\n};\n\n/*\n * Limit the timeout to 30 minutes to prevent an overflow on
        platfoms\n * that represent the time internally in microseconds using 32-bit
        int.\n */\nstatic const double MAX_TIMEOUT_SECONDS = 1800.0;\n\n// Not necessarily
        in sync with the browser\n#ifdef ENABLE_SHARED_MEMORY\n#  define SHARED_MEMORY_DEFAULT
        1\n#else\n#  define SHARED_MEMORY_DEFAULT 0\n#endif\n\n// Fuzzing support
        for JS runtime fuzzing\n#ifdef FUZZING_INTERFACES\n#  include \"shell/jsrtfuzzing/jsrtfuzzing.h\"\nstatic
        bool fuzzDoDebug = !!getenv(\"MOZ_FUZZ_DEBUG\");\nstatic bool fuzzHaveModule
        = !!getenv(\"FUZZER\");\n#endif  // FUZZING_INTERFACES\n\n// Code to support
        GCOV code coverage measurements on standalone shell\n#ifdef MOZ_CODE_COVERAGE\n#
        \ if defined(__GNUC__) && !defined(__clang__)\nextern \"C\" void __gcov_dump();\nextern
        \"C\" void __gcov_reset();\n\nvoid counters_dump(int) { __gcov_dump(); }\n\nvoid
        counters_reset(int) { __gcov_reset(); }\n#  else\nvoid counters_dump(int)
        { /* Do nothing */ }\n\nvoid counters_reset(int) { /* Do nothing */ }\n#  endif\n\nstatic
        void InstallCoverageSignalHandlers() {\n#  ifndef XP_WIN\n  fprintf(stderr,
        \"[CodeCoverage] Setting handlers for process %d.\\n\",\n          getpid());\n\n
        \ struct sigaction dump_sa;\n  dump_sa.sa_handler = counters_dump;\n  dump_sa.sa_flags
        = SA_RESTART;\n  sigemptyset(&dump_sa.sa_mask);\n  mozilla::DebugOnly<int>
        r1 = sigaction(SIGUSR1, &dump_sa, nullptr);\n  MOZ_ASSERT(r1 == 0, \"Failed
        to install GCOV SIGUSR1 handler\");\n\n  struct sigaction reset_sa;\n  reset_sa.sa_handler
        = counters_reset;\n  reset_sa.sa_flags = SA_RESTART;\n  sigemptyset(&reset_sa.sa_mask);\n
        \ mozilla::DebugOnly<int> r2 = sigaction(SIGUSR2, &reset_sa, nullptr);\n  MOZ_ASSERT(r2
        == 0, \"Failed to install GCOV SIGUSR2 handler\");\n#  endif\n}\n#endif\n\n//
        An off-thread parse or decode job.\nclass js::shell::OffThreadJob {\n  static
        constexpr size_t kCompileStackQuota = 128 * sizeof(size_t) * 1024;\n  static
        constexpr size_t kThreadStackQuota =\n      kCompileStackQuota + 128 * sizeof(size_t)
        * 1024;\n\n  enum State {\n    RUNNING,   // Working; no stencil.\n    DONE,
        \     // Finished; have stencil.\n    CANCELLED  // Cancelled due to error.\n
        \ };\n\n public:\n  enum class Kind {\n    CompileScript,\n    CompileModule,\n
        \   Decode,\n  };\n\n  OffThreadJob(ShellContext* sc, Kind kind, JS::SourceText<char16_t>&&
        srcBuf);\n  OffThreadJob(ShellContext* sc, Kind kind, JS::TranscodeBuffer&&
        xdrBuf);\n\n  ~OffThreadJob();\n\n  bool init(JSContext* cx, const JS::ReadOnlyCompileOptions&
        options);\n  bool dispatch();\n\n  static void OffThreadMain(OffThreadJob*
        self);\n  void run();\n\n  void cancel();\n  void waitUntilDone();\n\n  already_AddRefed<JS::Stencil>
        stealStencil(JSContext* cx);\n\n public:\n  const int32_t id;\n\n private:\n
        \ Kind kind_;\n  State state_;\n\n  JS::FrontendContext* fc_ = nullptr;\n
        \ JS::OwningCompileOptions options_;\n\n  UniquePtr<Thread> thread_;\n\n  JS::SourceText<char16_t>
        srcBuf_;\n  JS::TranscodeBuffer xdrBuf_;\n\n  RefPtr<JS::Stencil> stencil_;\n\n
        \ JS::TranscodeResult transcodeResult_ = JS::TranscodeResult::Ok;\n};\n\ntemplate
        <typename T>\nstatic OffThreadJob* NewOffThreadJob(JSContext* cx, OffThreadJob::Kind
        kind,\n                                     JS::ReadOnlyCompileOptions& options,\n
        \                                    T&& source) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ if (sc->isWorker) {\n    // Off-thread compilation/decode is used by main-thread,
        in order to improve\n    // the responsiveness.  It's not used by worker in
        browser, and there's not\n    // much reason to support worker here.\n    JS_ReportErrorASCII(cx,
        \"Off-thread job is not supported in worker\");\n    return nullptr;\n  }\n\n
        \ UniquePtr<OffThreadJob> job(\n      cx->new_<OffThreadJob>(sc, kind, std::move(source)));\n
        \ if (!job) {\n    return nullptr;\n  }\n\n  if (!job->init(cx, options))
        {\n    return nullptr;\n  }\n\n  if (!sc->offThreadJobs.append(job.get()))
        {\n    job->cancel();\n    JS_ReportErrorASCII(cx, \"OOM adding off-thread
        job\");\n    return nullptr;\n  }\n\n  return job.release();\n}\n\nstatic
        OffThreadJob* GetSingleOffThreadJob(JSContext* cx) {\n  ShellContext* sc =
        GetShellContext(cx);\n  const auto& jobs = sc->offThreadJobs;\n  if (jobs.empty())
        {\n    JS_ReportErrorASCII(cx, \"No off-thread jobs are pending\");\n    return
        nullptr;\n  }\n\n  if (jobs.length() > 1) {\n    JS_ReportErrorASCII(\n        cx,
        \"Multiple off-thread jobs are pending: must specify job ID\");\n    return
        nullptr;\n  }\n\n  return jobs[0];\n}\n\nstatic OffThreadJob* LookupOffThreadJobByID(JSContext*
        cx, int32_t id) {\n  if (id <= 0) {\n    JS_ReportErrorASCII(cx, \"Bad off-thread
        job ID\");\n    return nullptr;\n  }\n\n  ShellContext* sc = GetShellContext(cx);\n
        \ const auto& jobs = sc->offThreadJobs;\n  if (jobs.empty()) {\n    JS_ReportErrorASCII(cx,
        \"No off-thread jobs are pending\");\n    return nullptr;\n  }\n\n  OffThreadJob*
        job = nullptr;\n  for (auto someJob : jobs) {\n    if (someJob->id == id)
        {\n      job = someJob;\n      break;\n    }\n  }\n\n  if (!job) {\n    JS_ReportErrorASCII(cx,
        \"Off-thread job not found\");\n    return nullptr;\n  }\n\n  return job;\n}\n\nstatic
        OffThreadJob* LookupOffThreadJobForArgs(JSContext* cx,\n                                               const
        CallArgs& args,\n                                               size_t arg)
        {\n  // If the optional ID argument isn't present, get the single pending
        job.\n  if (args.length() <= arg) {\n    return GetSingleOffThreadJob(cx);\n
        \ }\n\n  // Lookup the job using the specified ID.\n  int32_t id = 0;\n  RootedValue
        value(cx, args[arg]);\n  if (!ToInt32(cx, value, &id)) {\n    return nullptr;\n
        \ }\n\n  return LookupOffThreadJobByID(cx, id);\n}\n\nstatic void DeleteOffThreadJob(JSContext*
        cx, OffThreadJob* job) {\n  ShellContext* sc = GetShellContext(cx);\n  for
        (size_t i = 0; i < sc->offThreadJobs.length(); i++) {\n    if (sc->offThreadJobs[i]
        == job) {\n      sc->offThreadJobs.erase(&sc->offThreadJobs[i]);\n      js_delete(job);\n
        \     return;\n    }\n  }\n\n  MOZ_CRASH(\"Off-thread job not found\");\n}\n\nstatic
        void CancelOffThreadJobsForRuntime(JSContext* cx) {\n  ShellContext* sc =
        GetShellContext(cx);\n  while (!sc->offThreadJobs.empty()) {\n    OffThreadJob*
        job = sc->offThreadJobs.popCopy();\n    job->waitUntilDone();\n    js_delete(job);\n
        \ }\n}\n\nmozilla::Atomic<int32_t> gOffThreadJobSerial(1);\n\nOffThreadJob::OffThreadJob(ShellContext*
        sc, Kind kind,\n                           JS::SourceText<char16_t>&& srcBuf)\n
        \   : id(gOffThreadJobSerial++),\n      kind_(kind),\n      state_(RUNNING),\n
        \     options_(JS::OwningCompileOptions::ForFrontendContext()),\n      srcBuf_(std::move(srcBuf))
        {\n  MOZ_RELEASE_ASSERT(id > 0, \"Off-thread job IDs exhausted\");\n}\n\nOffThreadJob::OffThreadJob(ShellContext*
        sc, Kind kind,\n                           JS::TranscodeBuffer&& xdrBuf)\n
        \   : id(gOffThreadJobSerial++),\n      kind_(kind),\n      state_(RUNNING),\n
        \     options_(JS::OwningCompileOptions::ForFrontendContext()),\n      xdrBuf_(std::move(xdrBuf))
        {\n  MOZ_RELEASE_ASSERT(id > 0, \"Off-thread job IDs exhausted\");\n}\n\nOffThreadJob::~OffThreadJob()
        {\n  if (fc_) {\n    JS::DestroyFrontendContext(fc_);\n  }\n  MOZ_ASSERT(state_
        != RUNNING);\n}\n\nbool OffThreadJob::init(JSContext* cx,\n                        const
        JS::ReadOnlyCompileOptions& options) {\n  fc_ = JS::NewFrontendContext();\n
        \ if (!fc_) {\n    ReportOutOfMemory(cx);\n    state_ = CANCELLED;\n    return
        false;\n  }\n\n  if (!options_.copy(cx, options)) {\n    state_ = CANCELLED;\n
        \   return false;\n  }\n\n  return true;\n}\n\nbool OffThreadJob::dispatch()
        {\n  thread_ =\n      js::MakeUnique<Thread>(Thread::Options().setStackSize(kThreadStackQuota));\n
        \ if (!thread_) {\n    state_ = CANCELLED;\n    return false;\n  }\n\n  if
        (!thread_->init(OffThreadJob::OffThreadMain, this)) {\n    state_ = CANCELLED;\n
        \   thread_ = nullptr;\n    return false;\n  }\n\n  return true;\n}\n\n/*
        static */ void OffThreadJob::OffThreadMain(OffThreadJob* self) {\n  self->run();\n}\n\nvoid
        OffThreadJob::run() {\n  MOZ_ASSERT(state_ == RUNNING);\n  MOZ_ASSERT(!stencil_);\n\n
        \ JS::SetNativeStackQuota(fc_, kCompileStackQuota);\n\n  switch (kind_) {\n
        \   case Kind::CompileScript: {\n      stencil_ = JS::CompileGlobalScriptToStencil(fc_,
        options_, srcBuf_);\n      break;\n    }\n    case Kind::CompileModule: {\n
        \     stencil_ = JS::CompileModuleScriptToStencil(fc_, options_, srcBuf_);\n
        \     break;\n    }\n    case Kind::Decode: {\n      JS::DecodeOptions decodeOptions(options_);\n
        \     JS::TranscodeRange range(xdrBuf_.begin(), xdrBuf_.length());\n      transcodeResult_
        = JS::DecodeStencil(fc_, decodeOptions, range,\n                                           getter_AddRefs(stencil_));\n
        \     break;\n    }\n  }\n\n  state_ = DONE;\n}\n\nvoid OffThreadJob::cancel()
        {\n  MOZ_ASSERT(state_ == RUNNING);\n  MOZ_ASSERT(!stencil_);\n  MOZ_ASSERT(!thread_,
        \"cannot cancel after starting a thread\");\n\n  state_ = CANCELLED;\n}\n\nvoid
        OffThreadJob::waitUntilDone() {\n  MOZ_ASSERT(state_ != CANCELLED);\n  thread_->join();\n}\n\nalready_AddRefed<JS::Stencil>
        OffThreadJob::stealStencil(JSContext* cx) {\n  JS::FrontendContext* fc = fc_;\n
        \ fc_ = nullptr;\n  auto destroyFrontendContext =\n      mozilla::MakeScopeExit([&]()
        { JS::DestroyFrontendContext(fc); });\n\n  MOZ_ASSERT(fc);\n\n  if (JS::HadFrontendErrors(fc))
        {\n    (void)JS::ConvertFrontendErrorsToRuntimeErrors(cx, fc, options_);\n
        \   return nullptr;\n  }\n\n  if (!stencil_ && JS::IsTranscodeFailureResult(transcodeResult_))
        {\n    JS_ReportErrorASCII(cx, \"failed to decode cache\");\n    return nullptr;\n
        \ }\n\n  // Report warnings.\n  if (!JS::ConvertFrontendErrorsToRuntimeErrors(cx,
        fc, options_)) {\n    return nullptr;\n  }\n\n  return stencil_.forget();\n}\n\nstruct
        ShellCompartmentPrivate {\n  GCPtr<ArrayObject*> blackRoot;\n  GCPtr<ArrayObject*>
        grayRoot;\n};\n\nstruct MOZ_STACK_CLASS EnvironmentPreparer\n    : public
        js::ScriptEnvironmentPreparer {\n  explicit EnvironmentPreparer(JSContext*
        cx) {\n    js::SetScriptEnvironmentPreparer(cx, this);\n  }\n  void invoke(JS::HandleObject
        global, Closure& closure) override;\n};\n\nconst char* shell::selfHostedXDRPath
        = nullptr;\nbool shell::encodeSelfHostedCode = false;\nbool shell::enableCodeCoverage
        = false;\nbool shell::enableDisassemblyDumps = false;\nbool shell::offthreadCompilation
        = false;\nJS::DelazificationOption shell::defaultDelazificationMode =\n    JS::DelazificationOption::OnDemandOnly;\nbool
        shell::enableAsmJS = false;\nbool shell::enableWasm = false;\nbool shell::enableSharedMemory
        = SHARED_MEMORY_DEFAULT;\nbool shell::enableWasmBaseline = false;\nbool shell::enableWasmOptimizing
        = false;\nbool shell::enableWasmVerbose = false;\nbool shell::enableTestWasmAwaitTier2
        = false;\nbool shell::enableSourcePragmas = true;\nbool shell::enableAsyncStacks
        = false;\nbool shell::enableAsyncStackCaptureDebuggeeOnly = false;\nbool shell::enableToSource
        = false;\nbool shell::enableImportAttributes = false;\nbool shell::enableImportAttributesAssertSyntax
        = false;\n#ifdef JS_GC_ZEAL\nuint32_t shell::gZealBits = 0;\nuint32_t shell::gZealFrequency
        = 0;\n#endif\nbool shell::printTiming = false;\nRCFile* shell::gErrFile =
        nullptr;\nRCFile* shell::gOutFile = nullptr;\nbool shell::reportWarnings =
        true;\nbool shell::compileOnly = false;\nbool shell::disableOOMFunctions =
        false;\nbool shell::defaultToSameCompartment = true;\n\n#ifdef DEBUG\nbool
        shell::dumpEntrainedVariables = false;\nbool shell::OOM_printAllocationCount
        = false;\n#endif\n\nUniqueChars shell::processWideModuleLoadPath;\n\nstatic
        bool SetTimeoutValue(JSContext* cx, double t);\n\nstatic void KillWatchdog(JSContext*
        cx);\n\nstatic bool ScheduleWatchdog(JSContext* cx, double t);\n\nstatic void
        CancelExecution(JSContext* cx);\n\nenum class ShellGlobalKind {\n  GlobalObject,\n
        \ WindowProxy,\n};\n\nstatic JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions&
        options,\n                                 JSPrincipals* principals, ShellGlobalKind
        kind,\n                                 bool immutablePrototype);\n\n/*\n
        * A toy WindowProxy class for the shell. This is intended for testing code\n
        * where global |this| is a WindowProxy. All requests are forwarded to the\n
        * underlying global and no navigation is supported.\n */\nconst JSClass ShellWindowProxyClass
        =\n    PROXY_CLASS_DEF(\"ShellWindowProxy\", JSCLASS_HAS_RESERVED_SLOTS(1));\n\nJSObject*
        NewShellWindowProxy(JSContext* cx, JS::HandleObject global) {\n  MOZ_ASSERT(global->is<GlobalObject>());\n\n
        \ js::WrapperOptions options;\n  options.setClass(&ShellWindowProxyClass);\n\n
        \ JSAutoRealm ar(cx, global);\n  JSObject* obj =\n      js::Wrapper::New(cx,
        global, &js::Wrapper::singleton, options);\n  MOZ_ASSERT_IF(obj, js::IsWindowProxy(obj));\n
        \ return obj;\n}\n\n/*\n * A toy principals type for the shell.\n *\n * In
        the shell, a principal is simply a 32-bit mask: P subsumes Q if the\n * set
        bits in P are a superset of those in Q. Thus, the principal 0 is\n * subsumed
        by everything, and the principal ~0 subsumes everything.\n *\n * As a special
        case, a null pointer as a principal is treated like 0xffff.\n *\n * The 'newGlobal'
        function takes an option indicating which principal the\n * new global should
        have; 'evaluate' does for the new code.\n */\nclass ShellPrincipals final
        : public JSPrincipals {\n  uint32_t bits;\n\n  static uint32_t getBits(JSPrincipals*
        p) {\n    if (!p) {\n      return 0xffff;\n    }\n    return static_cast<ShellPrincipals*>(p)->bits;\n
        \ }\n\n public:\n  explicit ShellPrincipals(uint32_t bits, int32_t refcount
        = 0) : bits(bits) {\n    this->refcount = refcount;\n  }\n\n  bool write(JSContext*
        cx, JSStructuredCloneWriter* writer) override {\n    // The shell doesn't
        have a read principals hook, so it doesn't really\n    // matter what we write
        here, but we have to write something so the\n    // fuzzer is happy.\n    return
        JS_WriteUint32Pair(writer, bits, 0);\n  }\n\n  bool isSystemOrAddonPrincipal()
        override { return true; }\n\n  static void destroy(JSPrincipals* principals)
        {\n    MOZ_ASSERT(principals != &fullyTrusted);\n    MOZ_ASSERT(principals->refcount
        == 0);\n    js_delete(static_cast<const ShellPrincipals*>(principals));\n
        \ }\n\n  static bool subsumes(JSPrincipals* first, JSPrincipals* second) {\n
        \   uint32_t firstBits = getBits(first);\n    uint32_t secondBits = getBits(second);\n
        \   return (firstBits | secondBits) == firstBits;\n  }\n\n  static JSSecurityCallbacks
        securityCallbacks;\n\n  // Fully-trusted principals singleton.\n  static ShellPrincipals
        fullyTrusted;\n};\n\nJSSecurityCallbacks ShellPrincipals::securityCallbacks
        = {\n    nullptr,  // contentSecurityPolicyAllows\n    subsumes};\n\n// The
        fully-trusted principal subsumes all other principals.\nShellPrincipals ShellPrincipals::fullyTrusted(-1,
        1);\n\n#ifdef EDITLINE\nextern \"C\" {\nextern MOZ_EXPORT char* readline(const
        char* prompt);\nextern MOZ_EXPORT void add_history(char* line);\n}  // extern
        \"C\"\n#endif\n\nShellContext::ShellContext(JSContext* cx, IsWorkerEnum isWorker_)\n
        \   : cx_(nullptr),\n      isWorker(isWorker_),\n      lastWarningEnabled(false),\n
        \     trackUnhandledRejections(true),\n      timeoutInterval(-1.0),\n      startTime(PRMJ_Now()),\n
        \     serviceInterrupt(false),\n      haveInterruptFunc(false),\n      interruptFunc(cx,
        NullValue()),\n      lastWarning(cx, NullValue()),\n      promiseRejectionTrackerCallback(cx,
        NullValue()),\n      unhandledRejectedPromises(cx),\n      watchdogLock(mutexid::ShellContextWatchdog),\n
        \     exitCode(0),\n      quitting(false),\n      readLineBufPos(0),\n      errFilePtr(nullptr),\n
        \     outFilePtr(nullptr),\n      offThreadMonitor(mutexid::ShellOffThreadState),\n
        \     finalizationRegistryCleanupCallbacks(cx) {}\n\nShellContext* js::shell::GetShellContext(JSContext*
        cx) {\n  ShellContext* sc = static_cast<ShellContext*>(JS_GetContextPrivate(cx));\n
        \ MOZ_ASSERT(sc);\n  return sc;\n}\n\nstatic void TraceRootArrays(JSTracer*
        trc, gc::MarkColor color) {\n  JSRuntime* rt = trc->runtime();\n  for (ZonesIter
        zone(rt, SkipAtoms); !zone.done(); zone.next()) {\n    for (CompartmentsInZoneIter
        comp(zone); !comp.done(); comp.next()) {\n      auto priv = static_cast<ShellCompartmentPrivate*>(\n
        \         JS_GetCompartmentPrivate(comp.get()));\n      if (!priv) {\n        continue;\n
        \     }\n\n      GCPtr<ArrayObject*>& array =\n          (color == gc::MarkColor::Black)
        ? priv->blackRoot : priv->grayRoot;\n      TraceNullableEdge(trc, &array,
        \"shell root array\");\n\n      if (array) {\n        // Trace the array elements
        as part of root marking.\n        for (uint32_t i = 0; i < array->getDenseInitializedLength();
        i++) {\n          Value& value = const_cast<Value&>(array->getDenseElement(i));\n
        \         TraceManuallyBarrieredEdge(trc, &value, \"shell root array element\");\n
        \       }\n      }\n    }\n  }\n}\n\nstatic void TraceBlackRoots(JSTracer*
        trc, void* data) {\n  TraceRootArrays(trc, gc::MarkColor::Black);\n}\n\nstatic
        bool TraceGrayRoots(JSTracer* trc, JS::SliceBudget& budget, void* data) {\n
        \ TraceRootArrays(trc, gc::MarkColor::Gray);\n  return true;\n}\n\nstatic
        inline JSString* NewStringCopyUTF8(JSContext* cx, const char* chars) {\n  return
        JS_NewStringCopyUTF8N(cx, JS::UTF8Chars(chars, strlen(chars)));\n}\n\nstatic
        mozilla::UniqueFreePtr<char[]> GetLine(FILE* file, const char* prompt) {\n#ifdef
        EDITLINE\n  /*\n   * Use readline only if file is stdin, because there's no
        way to specify\n   * another handle.  Are other filehandles interactive?\n
        \  */\n  if (file == stdin) {\n    mozilla::UniqueFreePtr<char[]> linep(readline(prompt));\n
        \   /*\n     * We set it to zero to avoid complaining about inappropriate
        ioctl\n     * for device in the case of EOF. Looks like errno == 251 if line
        is\n     * finished with EOF and errno == 25 (EINVAL on Mac) if there is\n
        \    * nothing left to read.\n     */\n    if (errno == 251 || errno == 25
        || errno == EINVAL) {\n      errno = 0;\n    }\n    if (!linep) {\n      return
        nullptr;\n    }\n    if (linep[0] != '\\0') {\n      add_history(linep.get());\n
        \   }\n    return linep;\n  }\n#endif\n\n  size_t len = 0;\n  if (*prompt
        != '\\0' && gOutFile->isOpen()) {\n    fprintf(gOutFile->fp, \"%s\", prompt);\n
        \   fflush(gOutFile->fp);\n  }\n\n  size_t size = 80;\n  mozilla::UniqueFreePtr<char[]>
        buffer(static_cast<char*>(malloc(size)));\n  if (!buffer) {\n    return nullptr;\n
        \ }\n\n  char* current = buffer.get();\n  do {\n    while (true) {\n      if
        (fgets(current, size - len, file)) {\n        break;\n      }\n      if (errno
        != EINTR) {\n        return nullptr;\n      }\n    }\n\n    len += strlen(current);\n
        \   char* t = buffer.get() + len - 1;\n    if (*t == '\\n') {\n      /* Line
        was read. We remove '\\n' and exit. */\n      *t = '\\0';\n      break;\n
        \   }\n\n    if (len + 1 == size) {\n      size = size * 2;\n      char* raw
        = buffer.release();\n      char* tmp = static_cast<char*>(realloc(raw, size));\n
        \     if (!tmp) {\n        free(raw);\n        return nullptr;\n      }\n
        \     buffer.reset(tmp);\n    }\n    current = buffer.get() + len;\n  } while
        (true);\n  return buffer;\n}\n\nstatic bool ShellInterruptCallback(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  if (!sc->serviceInterrupt)
        {\n    return true;\n  }\n\n  // Reset serviceInterrupt. CancelExecution or
        InterruptIf will set it to\n  // true to distinguish watchdog or user triggered
        interrupts.\n  // Do this first to prevent other interrupts that may occur
        while the\n  // user-supplied callback is executing from re-entering the handler.\n
        \ sc->serviceInterrupt = false;\n\n  bool result;\n  if (sc->haveInterruptFunc)
        {\n    bool wasAlreadyThrowing = cx->isExceptionPending();\n    JS::AutoSaveExceptionState
        savedExc(cx);\n    JSAutoRealm ar(cx, &sc->interruptFunc.toObject());\n    RootedValue
        rval(cx);\n\n    // Report any exceptions thrown by the JS interrupt callback,
        but do\n    // *not* keep it on the cx. The interrupt handler is invoked at
        points\n    // that are not expected to throw catchable exceptions, like at\n
        \   // JSOp::RetRval.\n    //\n    // If the interrupted JS code was already
        throwing, any exceptions\n    // thrown by the interrupt handler are silently
        swallowed.\n    {\n      Maybe<AutoReportException> are;\n      if (!wasAlreadyThrowing)
        {\n        are.emplace(cx);\n      }\n      result = JS_CallFunctionValue(cx,
        nullptr, sc->interruptFunc,\n                                    JS::HandleValueArray::empty(),
        &rval);\n    }\n    savedExc.restore();\n\n    if (rval.isBoolean()) {\n      result
        = rval.toBoolean();\n    } else {\n      result = false;\n    }\n  } else
        {\n    result = false;\n  }\n\n  if (!result && sc->exitCode == 0) {\n    static
        const char msg[] = \"Script terminated by interrupt handler.\\n\";\n    fputs(msg,
        stderr);\n\n    sc->exitCode = EXITCODE_TIMEOUT;\n  }\n\n  return result;\n}\n\nstatic
        void GCSliceCallback(JSContext* cx, JS::GCProgress progress,\n                            const
        JS::GCDescription& desc) {\n  if (progress == JS::GC_CYCLE_END) {\n#if defined(MOZ_MEMORY)\n
        \   // We call this here to match the browser's DOMGCSliceCallback.\n    jemalloc_free_dirty_pages();\n#endif\n
        \ }\n}\n\n/*\n * Some UTF-8 files, notably those written using Notepad, have
        a Unicode\n * Byte-Order-Mark (BOM) as their first character. This is useless
        (byte-order\n * is meaningless for UTF-8) but causes a syntax error unless
        we skip it.\n */\nstatic void SkipUTF8BOM(FILE* file) {\n  int ch1 = fgetc(file);\n
        \ int ch2 = fgetc(file);\n  int ch3 = fgetc(file);\n\n  // Skip the BOM\n
        \ if (ch1 == 0xEF && ch2 == 0xBB && ch3 == 0xBF) {\n    return;\n  }\n\n  //
        No BOM - revert\n  if (ch3 != EOF) {\n    ungetc(ch3, file);\n  }\n  if (ch2
        != EOF) {\n    ungetc(ch2, file);\n  }\n  if (ch1 != EOF) {\n    ungetc(ch1,
        file);\n  }\n}\n\nvoid EnvironmentPreparer::invoke(HandleObject global, Closure&
        closure) {\n  MOZ_ASSERT(JS_IsGlobalObject(global));\n\n  JSContext* cx =
        TlsContext.get();\n  MOZ_ASSERT(!JS_IsExceptionPending(cx));\n\n  AutoRealm
        ar(cx, global);\n  AutoReportException are(cx);\n  if (!closure(cx)) {\n    return;\n
        \ }\n}\n\nstatic bool RegisterScriptPathWithModuleLoader(JSContext* cx,\n
        \                                              HandleScript script,\n                                               const
        char* filename) {\n  // Set the private value associated with a script to
        a object containing the\n  // script's filename so that the module loader
        can use it to resolve\n  // relative imports.\n\n  RootedString path(cx, NewStringCopyUTF8(cx,
        filename));\n  if (!path) {\n    return false;\n  }\n\n  MOZ_ASSERT(JS::GetScriptPrivate(script).isUndefined());\n
        \ RootedObject infoObject(cx, js::CreateScriptPrivate(cx, path));\n  if (!infoObject)
        {\n    return false;\n  }\n\n  JS::SetScriptPrivate(script, ObjectValue(*infoObject));\n
        \ return true;\n}\n\nenum class CompileUtf8 {\n  InflateToUtf16,\n  DontInflate,\n};\n\n[[nodiscard]]
        static bool RunFile(JSContext* cx, const char* filename,\n                                  FILE*
        file, CompileUtf8 compileMethod,\n                                  bool compileOnly,
        bool fullParse) {\n  SkipUTF8BOM(file);\n\n  int64_t t1 = PRMJ_Now();\n  RootedScript
        script(cx);\n\n  {\n    CompileOptions options(cx);\n    options.setIntroductionType(\"js
        shell file\")\n        .setFileAndLine(filename, 1)\n        .setIsRunOnce(true)\n
        \       .setNoScriptRval(true);\n\n    if (fullParse) {\n      options.setForceFullParse();\n
        \   } else {\n      options.setEagerDelazificationStrategy(defaultDelazificationMode);\n
        \   }\n\n    if (compileMethod == CompileUtf8::DontInflate) {\n      script
        = JS::CompileUtf8File(cx, options, file);\n    } else {\n      fprintf(stderr,
        \"(compiling '%s' after inflating to UTF-16)\\n\", filename);\n\n      FileContents
        buffer(cx);\n      if (!ReadCompleteFile(cx, file, buffer)) {\n        return
        false;\n      }\n\n      size_t length = buffer.length();\n      auto chars
        = UniqueTwoByteChars(\n          UTF8CharsToNewTwoByteCharsZ(\n              cx,\n
        \             JS::UTF8Chars(reinterpret_cast<const char*>(buffer.begin()),\n
        \                           buffer.length()),\n              &length, js::MallocArena)\n
        \             .get());\n      if (!chars) {\n        return false;\n      }\n\n
        \     JS::SourceText<char16_t> source;\n      if (!source.init(cx, std::move(chars),
        length)) {\n        return false;\n      }\n\n      script = JS::Compile(cx,
        options, source);\n    }\n\n    if (!script) {\n      return false;\n    }\n
        \ }\n\n  if (!RegisterScriptPathWithModuleLoader(cx, script, filename)) {\n
        \   return false;\n  }\n\n#ifdef DEBUG\n  if (dumpEntrainedVariables) {\n
        \   AnalyzeEntrainedVariables(cx, script);\n  }\n#endif\n  if (!compileOnly)
        {\n    if (!JS_ExecuteScript(cx, script)) {\n      return false;\n    }\n
        \   int64_t t2 = PRMJ_Now() - t1;\n    if (printTiming) {\n      printf(\"runtime
        = %.3f ms\\n\", double(t2) / PRMJ_USEC_PER_MSEC);\n    }\n  }\n  return true;\n}\n\n[[nodiscard]]
        static bool RunModule(JSContext* cx, const char* filename,\n                                    bool
        compileOnly) {\n  ShellContext* sc = GetShellContext(cx);\n\n  RootedString
        path(cx, NewStringCopyUTF8(cx, filename));\n  if (!path) {\n    return false;\n
        \ }\n\n  path = ResolvePath(cx, path, RootRelative);\n  if (!path) {\n    return
        false;\n  }\n\n  return sc->moduleLoader->loadRootModule(cx, path);\n}\n\nstatic
        void ShellCleanupFinalizationRegistryCallback(JSFunction* doCleanup,\n                                                     JSObject*
        incumbentGlobal,\n                                                     void*
        data) {\n  // In the browser this queues a task. Shell jobs correspond to
        microtasks so\n  // we arrange for cleanup to happen after all jobs/microtasks
        have run. The\n  // incumbent global is ignored in the shell.\n\n  auto sc
        = static_cast<ShellContext*>(data);\n  AutoEnterOOMUnsafeRegion oomUnsafe;\n
        \ if (!sc->finalizationRegistryCleanupCallbacks.append(doCleanup)) {\n    oomUnsafe.crash(\"ShellCleanupFinalizationRegistryCallback\");\n
        \ }\n}\n\n// Run any FinalizationRegistry cleanup tasks and return whether
        any ran.\nstatic bool MaybeRunFinalizationRegistryCleanupTasks(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  MOZ_ASSERT(!sc->quitting);\n\n
        \ Rooted<ShellContext::FunctionVector> callbacks(cx);\n  std::swap(callbacks.get(),
        sc->finalizationRegistryCleanupCallbacks.get());\n\n  bool ranTasks = false;\n\n
        \ RootedFunction callback(cx);\n  for (JSFunction* f : callbacks) {\n    callback
        = f;\n\n    JS::ExposeObjectToActiveJS(callback);\n    AutoRealm ar(cx, callback);\n\n
        \   {\n      AutoReportException are(cx);\n      RootedValue unused(cx);\n
        \     (void)JS_CallFunction(cx, nullptr, callback, HandleValueArray::empty(),\n
        \                           &unused);\n    }\n\n    ranTasks = true;\n\n    if
        (sc->quitting) {\n      break;\n    }\n  }\n\n  return ranTasks;\n}\n\nstatic
        bool EnqueueJob(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  if (!IsFunctionObject(args.get(0))) {\n    JS_ReportErrorASCII(cx,
        \"EnqueueJob's first argument must be a function\");\n    return false;\n
        \ }\n\n  args.rval().setUndefined();\n\n  RootedObject job(cx, &args[0].toObject());\n
        \ return js::EnqueueJob(cx, job);\n}\n\nstatic void RunShellJobs(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  if (sc->quitting) {\n
        \   return;\n  }\n\n  while (true) {\n    // Run microtasks.\n    js::RunJobs(cx);\n
        \   if (sc->quitting) {\n      return;\n    }\n\n    // Run tasks (only finalization
        registry clean tasks are possible).\n    bool ranTasks = MaybeRunFinalizationRegistryCleanupTasks(cx);\n
        \   if (!ranTasks) {\n      break;\n    }\n  }\n}\n\nstatic bool DrainJobQueue(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (GetShellContext(cx)->quitting) {\n    JS_ReportErrorASCII(\n        cx,
        \"Mustn't drain the job queue when the shell is quitting\");\n    return false;\n
        \ }\n\n  if (cx->isEvaluatingModule != 0) {\n    JS_ReportErrorASCII(\n        cx,\n
        \       \"Can't drain the job queue when executing the top level of a module\");\n
        \   return false;\n  }\n\n  RunShellJobs(cx);\n\n  if (GetShellContext(cx)->quitting)
        {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool GlobalOfFirstJobInQueue(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  RootedObject job(cx, cx->internalJobQueue->maybeFront());\n
        \ if (!job) {\n    JS_ReportErrorASCII(cx, \"Job queue is empty\");\n    return
        false;\n  }\n\n  RootedObject global(cx, &job->nonCCWGlobal());\n  if (!cx->compartment()->wrap(cx,
        &global)) {\n    return false;\n  }\n\n  args.rval().setObject(*global);\n
        \ return true;\n}\n\nstatic bool TrackUnhandledRejections(JSContext* cx, JS::HandleObject
        promise,\n                                     JS::PromiseRejectionHandlingState
        state) {\n  ShellContext* sc = GetShellContext(cx);\n  if (!sc->trackUnhandledRejections)
        {\n    return true;\n  }\n\n#if defined(DEBUG) || defined(JS_OOM_BREAKPOINT)\n
        \ if (cx->runningOOMTest) {\n    // When OOM happens, we cannot reliably track
        the set of unhandled\n    // promise rejections. Throw error only when simulated
        OOM is used\n    // *and* promises are used in the test.\n    JS_ReportErrorASCII(\n
        \       cx,\n        \"Can't track unhandled rejections while running simulated
        OOM \"\n        \"test. Call ignoreUnhandledRejections before using oomTest
        etc.\");\n    return false;\n  }\n#endif\n\n  if (!sc->unhandledRejectedPromises)
        {\n    sc->unhandledRejectedPromises = SetObject::create(cx);\n    if (!sc->unhandledRejectedPromises)
        {\n      return false;\n    }\n  }\n\n  RootedValue promiseVal(cx, ObjectValue(*promise));\n\n
        \ AutoRealm ar(cx, sc->unhandledRejectedPromises);\n  if (!cx->compartment()->wrap(cx,
        &promiseVal)) {\n    return false;\n  }\n\n  switch (state) {\n    case JS::PromiseRejectionHandlingState::Unhandled:\n
        \     if (!SetObject::add(cx, sc->unhandledRejectedPromises, promiseVal))
        {\n        return false;\n      }\n      break;\n    case JS::PromiseRejectionHandlingState::Handled:\n
        \     bool deleted = false;\n      if (!SetObject::delete_(cx, sc->unhandledRejectedPromises,
        promiseVal,\n                              &deleted)) {\n        return false;\n
        \     }\n      // We can't MOZ_ASSERT(deleted) here, because it's possible
        we failed to\n      // add the promise in the first place, due to OOM.\n      break;\n
        \ }\n\n  return true;\n}\n\nstatic void ForwardingPromiseRejectionTrackerCallback(\n
        \   JSContext* cx, bool mutedErrors, JS::HandleObject promise,\n    JS::PromiseRejectionHandlingState
        state, void* data) {\n  AutoReportException are(cx);\n\n  if (!TrackUnhandledRejections(cx,
        promise, state)) {\n    return;\n  }\n\n  RootedValue callback(cx,\n                       GetShellContext(cx)->promiseRejectionTrackerCallback);\n
        \ if (callback.isNull()) {\n    return;\n  }\n\n  AutoRealm ar(cx, &callback.toObject());\n\n
        \ FixedInvokeArgs<2> args(cx);\n  args[0].setObject(*promise);\n  args[1].setInt32(static_cast<int32_t>(state));\n\n
        \ if (!JS_WrapValue(cx, args[0])) {\n    return;\n  }\n\n  RootedValue rval(cx);\n
        \ (void)Call(cx, callback, UndefinedHandleValue, args, &rval);\n}\n\nstatic
        bool SetPromiseRejectionTrackerCallback(JSContext* cx, unsigned argc,\n                                               Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!IsFunctionObject(args.get(0)))
        {\n    JS_ReportErrorASCII(\n        cx,\n        \"setPromiseRejectionTrackerCallback
        expects a function as its sole \"\n        \"argument\");\n    return false;\n
        \ }\n\n  GetShellContext(cx)->promiseRejectionTrackerCallback = args[0];\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\n// clang-format off\nstatic
        const char* telemetryNames[static_cast<int>(JSMetric::Count)] = {\n#define
        LIT(NAME, _) #NAME,\n  FOR_EACH_JS_METRIC(LIT)\n#undef LIT\n};\n// clang-format
        on\n\n// Telemetry can be executed from multiple threads, and the callback
        is\n// responsible to avoid contention on the recorded telemetry data.\nstatic
        Mutex* telemetryLock = nullptr;\nclass MOZ_RAII AutoLockTelemetry : public
        LockGuard<Mutex> {\n  using Base = LockGuard<Mutex>;\n\n public:\n  AutoLockTelemetry()
        : Base(*telemetryLock) { MOZ_ASSERT(telemetryLock); }\n};\n\nusing TelemetryData
        = uint32_t;\nusing TelemetryVec = Vector<TelemetryData, 0, SystemAllocPolicy>;\nstatic
        mozilla::Array<TelemetryVec, size_t(JSMetric::Count)> telemetryResults;\nstatic
        void AccumulateTelemetryDataCallback(JSMetric id, uint32_t sample) {\n  AutoLockTelemetry
        alt;\n  // We ignore OOMs while writting teleemtry data.\n  if (telemetryResults[static_cast<int>(id)].append(sample))
        {\n    return;\n  }\n}\n\nstatic void WriteTelemetryDataToDisk(const char*
        dir) {\n  const int pathLen = 260;\n  char fileName[pathLen];\n  Fprinter
        output;\n  auto initOutput = [&](const char* name) -> bool {\n    if (SprintfLiteral(fileName,
        \"%s%s.csv\", dir, name) >= pathLen) {\n      return false;\n    }\n    FILE*
        file = fopen(fileName, \"a\");\n    if (!file) {\n      return false;\n    }\n
        \   output.init(file);\n    return true;\n  };\n\n  for (size_t id = 0; id
        < size_t(JSMetric::Count); id++) {\n    auto clear = MakeScopeExit([&] { telemetryResults[id].clearAndFree();
        });\n    if (!initOutput(telemetryNames[id])) {\n      continue;\n    }\n
        \   for (uint32_t data : telemetryResults[id]) {\n      output.printf(\"%u\\n\",
        data);\n    }\n    output.finish();\n  }\n}\n\n#undef MAP_TELEMETRY\n\n//
        Use Counter introspection\nstatic Mutex useCounterLock(mutexid::ShellUseCounters);\nclass
        MOZ_RAII AutoLockUseCounters : public LockGuard<Mutex> {\n  using Base = LockGuard<Mutex>;\n\n
        public:\n  AutoLockUseCounters() : Base(useCounterLock) {}\n};\n\nusing UseCounterArray
        =\n    mozilla::Array<uint32_t, static_cast<size_t>(JSUseCounter::COUNT)>;\nstatic
        UseCounterArray useCounterResults;\nstatic void SetUseCounterCallback(JSObject*
        obj, JSUseCounter counter) {\n  MOZ_RELEASE_ASSERT(obj);\n  AutoLockUseCounters
        aluc;\n  // Maybe should ensure obj is a global object?\n  useCounterResults[static_cast<size_t>(counter)]++;\n}\n\nstatic
        bool GetUseCounterResults(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));\n
        \ if (!obj) {\n    return false;\n  }\n\n  // Make a private copy holding
        the lock then release, because we can't\n  // hold this mutex while doing
        JS_DefineProperty, which holds MemoryTracker\n  // mutex.\n  UseCounterArray
        local;\n  {\n    AutoLockUseCounters aluc;\n    local = useCounterResults;\n
        \ }\n\n  RootedValue val(cx);\n#define ADD_VALUE(ENUM, NAME)                                      \\\n
        \ val.setInt32(local[static_cast<size_t>(JSUseCounter::ENUM)]);    \\\n  if
        (!JS_DefineProperty(cx, obj, #NAME, val, JSPROP_ENUMERATE)) { \\\n    return
        false;                                                  \\\n  }\n\n  FOR_EACH_JS_USE_COUNTER(ADD_VALUE);\n\n
        \ args.rval().setObject(*obj);\n  return true;\n}\n\nstatic bool BoundToAsyncStack(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ RootedValue function(cx, GetFunctionNativeReserved(&args.callee(), 0));\n
        \ RootedObject options(\n      cx, &GetFunctionNativeReserved(&args.callee(),
        1).toObject());\n\n  Rooted<SavedFrame*> stack(cx, nullptr);\n  bool isExplicit;\n\n
        \ RootedValue v(cx);\n\n  if (!JS_GetProperty(cx, options, \"stack\", &v))
        {\n    return false;\n  }\n  if (!v.isObject() || !v.toObject().is<SavedFrame>())
        {\n    JS_ReportErrorASCII(cx,\n                        \"The 'stack' property
        must be a SavedFrame object.\");\n    return false;\n  }\n  stack = &v.toObject().as<SavedFrame>();\n\n
        \ if (!JS_GetProperty(cx, options, \"cause\", &v)) {\n    return false;\n
        \ }\n  RootedString causeString(cx, ToString(cx, v));\n  if (!causeString)
        {\n    return false;\n  }\n\n  UniqueChars cause = JS_EncodeStringToUTF8(cx,
        causeString);\n  if (!cause) {\n    MOZ_ASSERT(cx->isExceptionPending());\n
        \   return false;\n  }\n\n  if (!JS_GetProperty(cx, options, \"explicit\",
        &v)) {\n    return false;\n  }\n  isExplicit = v.isUndefined() ? true : ToBoolean(v);\n\n
        \ auto kind =\n      (isExplicit ? JS::AutoSetAsyncStackForNewCalls::AsyncCallKind::EXPLICIT\n
        \                 : JS::AutoSetAsyncStackForNewCalls::AsyncCallKind::IMPLICIT);\n\n
        \ JS::AutoSetAsyncStackForNewCalls asasfnckthxbye(cx, stack, cause.get(),
        kind);\n  return Call(cx, UndefinedHandleValue, function, JS::HandleValueArray::empty(),\n
        \             args.rval());\n}\n\nstatic bool BindToAsyncStack(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 2) {\n    JS_ReportErrorASCII(cx, \"bindToAsyncStack
        takes exactly two arguments.\");\n    return false;\n  }\n\n  if (!args[0].isObject()
        || !IsCallable(args[0])) {\n    JS_ReportErrorASCII(\n        cx, \"bindToAsyncStack's
        first argument should be a function.\");\n    return false;\n  }\n\n  if (!args[1].isObject())
        {\n    JS_ReportErrorASCII(\n        cx, \"bindToAsyncStack's second argument
        should be an object.\");\n    return false;\n  }\n\n  RootedFunction bound(cx,
        NewFunctionWithReserved(cx, BoundToAsyncStack, 0, 0,\n                                                   \"bindToAsyncStack
        thunk\"));\n  if (!bound) {\n    return false;\n  }\n  SetFunctionNativeReserved(bound,
        0, args[0]);\n  SetFunctionNativeReserved(bound, 1, args[1]);\n\n  args.rval().setObject(*bound);\n
        \ return true;\n}\n\n#ifdef JS_HAS_INTL_API\nstatic bool AddIntlExtras(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (!args.get(0).isObject()) {\n    JS_ReportErrorASCII(cx, \"addIntlExtras
        must be passed an object\");\n    return false;\n  }\n  JS::RootedObject intl(cx,
        &args[0].toObject());\n\n  static const JSFunctionSpec funcs[] = {\n      JS_SELF_HOSTED_FN(\"getCalendarInfo\",
        \"Intl_getCalendarInfo\", 1, 0),\n      JS_FS_END};\n\n  if (!JS_DefineFunctions(cx,
        intl, funcs)) {\n    return false;\n  }\n\n  if (!JS::AddMozDateTimeFormatConstructor(cx,
        intl)) {\n    return false;\n  }\n\n  if (!JS::AddMozDisplayNamesConstructor(cx,
        intl)) {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return
        true;\n}\n#endif  // JS_HAS_INTL_API\n\n[[nodiscard]] static bool EvalUtf8AndPrint(JSContext*
        cx, const char* bytes,\n                                           size_t
        length, int lineno,\n                                           bool compileOnly)
        {\n  // Eval.\n  JS::CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell interactive\")\n      .setIsRunOnce(true)\n      .setFileAndLine(\"typein\",
        lineno)\n      .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \ JS::SourceText<Utf8Unit> srcBuf;\n  if (!srcBuf.init(cx, bytes, length,
        JS::SourceOwnership::Borrowed)) {\n    return false;\n  }\n\n  RootedScript
        script(cx, JS::Compile(cx, options, srcBuf));\n  if (!script) {\n    return
        false;\n  }\n  if (compileOnly) {\n    return true;\n  }\n  RootedValue result(cx);\n
        \ if (!JS_ExecuteScript(cx, script, &result)) {\n    return false;\n  }\n\n
        \ if (!result.isUndefined() && gOutFile->isOpen()) {\n    // Print.\n    RootedString
        str(cx, JS_ValueToSource(cx, result));\n    if (!str) {\n      return false;\n
        \   }\n\n    UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, str);\n    if
        (!utf8chars) {\n      return false;\n    }\n    fprintf(gOutFile->fp, \"%s\\n\",
        utf8chars.get());\n  }\n  return true;\n}\n\n[[nodiscard]] static bool ReadEvalPrintLoop(JSContext*
        cx, FILE* in,\n                                            bool compileOnly)
        {\n  ShellContext* sc = GetShellContext(cx);\n  int lineno = 1;\n  bool hitEOF
        = false;\n\n  do {\n    /*\n     * Accumulate lines until we get a 'compilable
        unit' - one that either\n     * generates an error (before running out of
        source) or that compiles\n     * cleanly.  This should be whenever we get
        a complete statement that\n     * coincides with the end of a line.\n     */\n
        \   int startline = lineno;\n    typedef Vector<char, 32> CharBuffer;\n    RootedObject
        globalLexical(cx, &cx->global()->lexicalEnvironment());\n    CharBuffer buffer(cx);\n
        \   do {\n      ScheduleWatchdog(cx, -1);\n      sc->serviceInterrupt = false;\n
        \     errno = 0;\n\n      mozilla::UniqueFreePtr<char[]> line =\n          GetLine(in,
        startline == lineno ? \"js> \" : \"\");\n      if (!line) {\n        if (errno)
        {\n          if (UniqueChars error = SystemErrorMessage(cx, errno)) {\n            JS_ReportErrorUTF8(cx,
        \"%s\", error.get());\n          }\n          return false;\n        }\n        hitEOF
        = true;\n        break;\n      }\n\n      if (!buffer.append(line.get(), strlen(line.get()))
        ||\n          !buffer.append('\\n')) {\n        return false;\n      }\n\n
        \     lineno++;\n      if (!ScheduleWatchdog(cx, sc->timeoutInterval)) {\n
        \       hitEOF = true;\n        break;\n      }\n    } while (!JS_Utf8BufferIsCompilableUnit(cx,
        cx->global(), buffer.begin(),\n                                            buffer.length()));\n\n
        \   if (hitEOF && buffer.empty()) {\n      break;\n    }\n\n    {\n      //
        Report exceptions but keep going.\n      AutoReportException are(cx);\n      (void)EvalUtf8AndPrint(cx,
        buffer.begin(), buffer.length(), startline,\n                             compileOnly);\n
        \   }\n\n    // If a let or const fail to initialize they will remain in an
        unusable\n    // without further intervention. This call cleans up the global
        scope,\n    // setting uninitialized lexicals to undefined so that they may
        still\n    // be used. This behavior is _only_ acceptable in the context of
        the repl.\n    if (JS::ForceLexicalInitialization(cx, globalLexical) &&\n
        \       gErrFile->isOpen()) {\n      fputs(\n          \"Warning: According
        to the standard, after the above exception,\\n\"\n          \"Warning: the
        global bindings should be permanently uninitialized.\\n\"\n          \"Warning:
        We have non-standard-ly initialized them to `undefined`\"\n          \"for
        you.\\nWarning: This nicety only happens in the JS shell.\\n\",\n          stderr);\n
        \   }\n\n    RunShellJobs(cx);\n  } while (!hitEOF && !sc->quitting);\n\n
        \ if (gOutFile->isOpen()) {\n    fprintf(gOutFile->fp, \"\\n\");\n  }\n\n
        \ return true;\n}\n\nenum FileKind {\n  PreludeScript,    // UTF-8 script,
        fully-parsed, to avoid conflicting\n                    // configurations.\n
        \ FileScript,       // UTF-8, directly parsed as such\n  FileScriptUtf16,
        \ // FileScript, but inflate to UTF-16 before parsing\n  FileModule,\n};\n\n[[nodiscard]]
        static bool Process(JSContext* cx, const char* filename,\n                                  bool
        forceTTY, FileKind kind) {\n  FILE* file;\n  if (forceTTY || !filename ||
        strcmp(filename, \"-\") == 0) {\n    file = stdin;\n  } else {\n    file =
        OpenFile(cx, filename, \"rb\");\n    if (!file) {\n      return false;\n    }\n
        \ }\n  AutoCloseFile autoClose(file);\n\n  bool fullParse = false;\n  if (!forceTTY
        && !isatty(fileno(file))) {\n    // It's not interactive - just execute it.\n
        \   switch (kind) {\n      case PreludeScript:\n        fullParse = true;\n
        \       if (!RunFile(cx, filename, file, CompileUtf8::DontInflate, compileOnly,\n
        \                    fullParse)) {\n          return false;\n        }\n        break;\n
        \     case FileScript:\n        if (!RunFile(cx, filename, file, CompileUtf8::DontInflate,
        compileOnly,\n                     fullParse)) {\n          return false;\n
        \       }\n        break;\n      case FileScriptUtf16:\n        if (!RunFile(cx,
        filename, file, CompileUtf8::InflateToUtf16,\n                     compileOnly,
        fullParse)) {\n          return false;\n        }\n        break;\n      case
        FileModule:\n        if (!RunModule(cx, filename, compileOnly)) {\n          return
        false;\n        }\n        break;\n      default:\n        MOZ_CRASH(\"Impossible
        FileKind!\");\n    }\n  } else {\n    // It's an interactive filehandle; drop
        into read-eval-print loop.\n    MOZ_ASSERT(kind == FileScript);\n    if (!ReadEvalPrintLoop(cx,
        file, compileOnly)) {\n      return false;\n    }\n  }\n#ifdef FUZZING_JS_FUZZILLI\n
        \ fprintf(stderr, \"executionHash is 0x%x with %d inputs\\n\", cx->executionHash,\n
        \         cx->executionHashInputs);\n#endif\n  return true;\n}\n\n#ifdef XP_WIN\n#
        \ define GET_FD_FROM_FILE(a) int(_get_osfhandle(fileno(a)))\n#else\n#  define
        GET_FD_FROM_FILE(a) fileno(a)\n#endif\n\nstatic void freeExternalCallback(void*
        contents, void* userData) {\n  MOZ_ASSERT(!userData);\n  js_free(contents);\n}\n\nstatic
        bool CreateExternalArrayBuffer(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length() != 1) {\n
        \   JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage, nullptr,\n
        \       args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"createExternalArrayBuffer\");\n    return false;\n  }\n\n  int32_t
        bytes = 0;\n  if (!ToInt32(cx, args[0], &bytes)) {\n    return false;\n  }\n\n
        \ if (bytes < 0) {\n    JS_ReportErrorASCII(cx, \"Size must be non-negative\");\n
        \   return false;\n  }\n\n  void* buffer = js_calloc(bytes);\n  if (!buffer)
        {\n    JS_ReportOutOfMemory(cx);\n    return false;\n  }\n\n  UniquePtr<void,
        JS::BufferContentsDeleter> ptr{buffer,\n                                                 {&freeExternalCallback}};\n
        \ RootedObject arrayBuffer(\n      cx, JS::NewExternalArrayBuffer(cx, bytes,
        std::move(ptr)));\n  if (!arrayBuffer) {\n    return false;\n  }\n\n  args.rval().setObject(*arrayBuffer);\n
        \ return true;\n}\n\nstatic bool CreateMappedArrayBuffer(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        < 1 || args.length() > 3) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage,
        nullptr,\n        args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"createMappedArrayBuffer\");\n    return false;\n  }\n\n  RootedString
        rawFilenameStr(cx, JS::ToString(cx, args[0]));\n  if (!rawFilenameStr) {\n
        \   return false;\n  }\n  // It's a little bizarre to resolve relative to
        the script, but for testing\n  // I need a file at a known location, and the
        only good way I know of to do\n  // that right now is to include it in the
        repo alongside the test script.\n  // Bug 944164 would introduce an alternative.\n
        \ Rooted<JSString*> filenameStr(\n      cx, ResolvePath(cx, rawFilenameStr,
        ScriptRelative));\n  if (!filenameStr) {\n    return false;\n  }\n  UniqueChars
        filename = JS_EncodeStringToUTF8(cx, filenameStr);\n  if (!filename) {\n    return
        false;\n  }\n\n  uint32_t offset = 0;\n  if (args.length() >= 2) {\n    if
        (!JS::ToUint32(cx, args[1], &offset)) {\n      return false;\n    }\n  }\n\n
        \ bool sizeGiven = false;\n  uint32_t size;\n  if (args.length() >= 3) {\n
        \   if (!JS::ToUint32(cx, args[2], &size)) {\n      return false;\n    }\n
        \   sizeGiven = true;\n    if (size == 0) {\n      JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr,\n                                JSMSG_BAD_ARRAY_LENGTH);\n
        \     return false;\n    }\n  }\n\n  FILE* file = OpenFile(cx, filename.get(),
        \"rb\");\n  if (!file) {\n    return false;\n  }\n  AutoCloseFile autoClose(file);\n\n
        \ struct stat st;\n  if (fstat(fileno(file), &st) < 0) {\n    JS_ReportErrorASCII(cx,
        \"Unable to stat file\");\n    return false;\n  }\n\n  if ((st.st_mode & S_IFMT)
        != S_IFREG) {\n    JS_ReportErrorASCII(cx, \"Path is not a regular file\");\n
        \   return false;\n  }\n\n  if (!sizeGiven) {\n    if (off_t(offset) >= st.st_size)
        {\n      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,\n                                JSMSG_OFFSET_LARGER_THAN_FILESIZE);\n
        \     return false;\n    }\n    size = st.st_size - offset;\n  }\n\n  void*
        contents =\n      JS::CreateMappedArrayBufferContents(GET_FD_FROM_FILE(file),
        offset, size);\n  if (!contents) {\n    JS_ReportErrorASCII(cx,\n                        \"failed
        to allocate mapped array buffer contents \"\n                        \"(possibly
        due to bad alignment)\");\n    return false;\n  }\n\n  RootedObject obj(cx,\n
        \                  JS::NewMappedArrayBufferWithContents(cx, size, contents));\n
        \ if (!obj) {\n    return false;\n  }\n\n  args.rval().setObject(*obj);\n
        \ return true;\n}\n\n#undef GET_FD_FROM_FILE\n\nclass UserBufferObject : public
        NativeObject {\n  static const uint32_t BUFFER_SLOT = 0;\n  static const uint32_t
        BYTE_LENGTH_SLOT = 1;\n  static const uint32_t RESERVED_SLOTS = 2;\n\n  static
        constexpr auto BufferMemoryUse = MemoryUse::Embedding1;\n\n  static void finalize(JS::GCContext*
        gcx, JSObject* obj);\n\n public:\n  static const JSClassOps classOps_;\n  static
        const JSClass class_;\n\n  [[nodiscard]] static UserBufferObject* create(JSContext*
        cx,\n                                                size_t byteLength);\n\n
        \ void* buffer() const {\n    auto& buffer = getReservedSlot(BUFFER_SLOT);\n
        \   if (buffer.isUndefined()) {\n      return nullptr;\n    }\n    return
        buffer.toPrivate();\n  }\n\n  size_t byteLength() const {\n    return size_t(getReservedSlot(BYTE_LENGTH_SLOT).toPrivate());\n
        \ }\n};\n\nconst JSClassOps UserBufferObject::classOps_ = {\n    nullptr,
        \                    // addProperty\n    nullptr,                     // delProperty\n
        \   nullptr,                     // enumerate\n    nullptr,                     //
        newEnumerate\n    nullptr,                     // resolve\n    nullptr,                     //
        mayResolve\n    UserBufferObject::finalize,  // finalize\n    nullptr,                     //
        call\n    nullptr,                     // construct\n    nullptr,                     //
        trace\n};\n\nconst JSClass UserBufferObject::class_ = {\n    \"UserBufferObject\",\n
        \   JSCLASS_HAS_RESERVED_SLOTS(UserBufferObject::RESERVED_SLOTS) |\n        JSCLASS_BACKGROUND_FINALIZE,\n
        \   &UserBufferObject::classOps_,\n};\n\nUserBufferObject* UserBufferObject::create(JSContext*
        cx, size_t byteLength) {\n  void* buffer = js_calloc(byteLength);\n  if (!buffer)
        {\n    JS_ReportOutOfMemory(cx);\n    return nullptr;\n  }\n  UniquePtr<void,
        JS::FreePolicy> ptr(buffer);\n\n  auto* userBuffer = NewObjectWithGivenProto<UserBufferObject>(cx,
        nullptr);\n  if (!userBuffer) {\n    return nullptr;\n  }\n\n  InitReservedSlot(userBuffer,
        BUFFER_SLOT, ptr.release(), byteLength,\n                   BufferMemoryUse);\n
        \ userBuffer->initReservedSlot(BYTE_LENGTH_SLOT, PrivateValue(byteLength));\n\n
        \ return userBuffer;\n}\n\nvoid UserBufferObject::finalize(JS::GCContext*
        gcx, JSObject* obj) {\n  auto* userBuffer = &obj->as<UserBufferObject>();\n
        \ if (auto* buffer = userBuffer->buffer()) {\n    gcx->free_(userBuffer, buffer,
        userBuffer->byteLength(), BufferMemoryUse);\n  }\n}\n\nstatic bool CreateUserArrayBuffer(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (args.length() != 1) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage,
        nullptr,\n        args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"createUserArrayBuffer\");\n    return false;\n  }\n\n  int32_t bytes
        = 0;\n  if (!ToInt32(cx, args[0], &bytes)) {\n    return false;\n  }\n  if
        (bytes < 0) {\n    JS_ReportErrorASCII(cx, \"Size must be non-negative\");\n
        \   return false;\n  }\n\n  Rooted<UserBufferObject*> userBuffer(cx, UserBufferObject::create(cx,
        bytes));\n  if (!userBuffer) {\n    return false;\n  }\n\n  Rooted<JSObject*>
        arrayBuffer(\n      cx, JS::NewArrayBufferWithUserOwnedContents(cx, userBuffer->byteLength(),\n
        \                                                 userBuffer->buffer()));\n
        \ if (!arrayBuffer) {\n    return false;\n  }\n\n  // Create a strong reference
        from |arrayBuffer| to |userBuffer|. This ensures\n  // |userBuffer| can't
        outlive |arrayBuffer|. That way we don't have to worry\n  // about detaching
        the ArrayBuffer object when |userBuffer| gets finalized.\n  // The reference
        is made through a private name, because we don't want to\n  // expose |userBuffer|
        to user-code.\n\n  auto* privateName = NewPrivateName(cx, cx->names().empty_.toHandle());\n
        \ if (!privateName) {\n    return false;\n  }\n\n  Rooted<PropertyKey> id(cx,
        PropertyKey::Symbol(privateName));\n  Rooted<JS::Value> userBufferVal(cx,
        ObjectValue(*userBuffer));\n  if (!js::DefineDataProperty(cx, arrayBuffer,
        id, userBufferVal, 0)) {\n    return false;\n  }\n\n  args.rval().setObject(*arrayBuffer);\n
        \ return true;\n}\n\nstatic bool AddPromiseReactions(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 3) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage, nullptr,\n
        \       args.length() < 3 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"addPromiseReactions\");\n    return false;\n  }\n\n  RootedObject
        promise(cx);\n  if (args[0].isObject()) {\n    promise = &args[0].toObject();\n
        \ }\n\n  if (!promise || !JS::IsPromiseObject(promise)) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"addPromiseReactions\");\n    return false;\n  }\n\n  RootedObject onResolve(cx);\n
        \ if (args[1].isObject()) {\n    onResolve = &args[1].toObject();\n  }\n\n
        \ RootedObject onReject(cx);\n  if (args[2].isObject()) {\n    onReject =
        &args[2].toObject();\n  }\n\n  if (!onResolve || !onResolve->is<JSFunction>()
        || !onReject ||\n      !onReject->is<JSFunction>()) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"addPromiseReactions\");\n    return false;\n  }\n\n  return JS::AddPromiseReactions(cx,
        promise, onResolve, onReject);\n}\n\nstatic bool IgnoreUnhandledRejections(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ ShellContext* sc = GetShellContext(cx);\n  sc->trackUnhandledRejections
        = false;\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic bool
        Options(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  JS::ContextOptions oldContextOptions = JS::ContextOptionsRef(cx);\n
        \ for (unsigned i = 0; i < args.length(); i++) {\n    RootedString str(cx,
        JS::ToString(cx, args[i]));\n    if (!str) {\n      return false;\n    }\n\n
        \   Rooted<JSLinearString*> opt(cx, str->ensureLinear(cx));\n    if (!opt)
        {\n      return false;\n    }\n\n    if (StringEqualsLiteral(opt, \"throw_on_asmjs_validation_failure\"))
        {\n      JS::ContextOptionsRef(cx).toggleThrowOnAsmJSValidationFailure();\n
        \   } else {\n      UniqueChars optChars = QuoteString(cx, opt, '\"');\n      if
        (!optChars) {\n        return false;\n      }\n\n      JS_ReportErrorASCII(cx,\n
        \                         \"unknown option name %s.\"\n                          \"
        The valid name is \"\n                          \"throw_on_asmjs_validation_failure.\",\n
        \                         optChars.get());\n      return false;\n    }\n  }\n\n
        \ UniqueChars names = DuplicateString(\"\");\n  bool found = false;\n  if
        (names && oldContextOptions.throwOnAsmJSValidationFailure()) {\n    names
        = JS_sprintf_append(std::move(names), \"%s%s\", found ? \",\" : \"\",\n                              \"throw_on_asmjs_validation_failure\");\n
        \   found = true;\n  }\n  if (!names) {\n    JS_ReportOutOfMemory(cx);\n    return
        false;\n  }\n\n  JSString* str = JS_NewStringCopyZ(cx, names.get());\n  if
        (!str) {\n    return false;\n  }\n  args.rval().setString(str);\n  return
        true;\n}\n\nstatic bool LoadScript(JSContext* cx, unsigned argc, Value* vp,\n
        \                      bool scriptRelative) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  RootedString str(cx);\n  for (unsigned i = 0; i < args.length();
        i++) {\n    str = JS::ToString(cx, args[i]);\n    if (!str) {\n      JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                                JSSMSG_INVALID_ARGS,
        \"load\");\n      return false;\n    }\n\n    str = ResolvePath(cx, str, scriptRelative
        ? ScriptRelative : RootRelative);\n    if (!str) {\n      JS_ReportErrorASCII(cx,
        \"unable to resolve path\");\n      return false;\n    }\n\n    UniqueChars
        filename = JS_EncodeStringToUTF8(cx, str);\n    if (!filename) {\n      return
        false;\n    }\n\n    errno = 0;\n\n    CompileOptions opts(cx);\n    opts.setIntroductionType(\"js
        shell load\")\n        .setIsRunOnce(true)\n        .setNoScriptRval(true)\n
        \       .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n    RootedValue
        unused(cx);\n    if (!(compileOnly\n              ? JS::CompileUtf8Path(cx,
        opts, filename.get()) != nullptr\n              : JS::EvaluateUtf8Path(cx,
        opts, filename.get(), &unused))) {\n      return false;\n    }\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool Load(JSContext* cx, unsigned argc, Value*
        vp) {\n  return LoadScript(cx, argc, vp, false);\n}\n\nstatic bool LoadScriptRelativeToScript(JSContext*
        cx, unsigned argc,\n                                       Value* vp) {\n
        \ return LoadScript(cx, argc, vp, true);\n}\n\nstatic void my_LargeAllocFailCallback()
        {\n  JSContext* cx = TlsContext.get();\n  if (!cx) {\n    return;\n  }\n\n
        \ MOZ_ASSERT(!JS::RuntimeHeapIsBusy());\n\n  JS::PrepareForFullGC(cx);\n  cx->runtime()->gc.gc(JS::GCOptions::Shrink,\n
        \                      JS::GCReason::SHARED_MEMORY_LIMIT);\n}\n\nstatic const
        uint32_t CacheEntry_SOURCE = 0;\nstatic const uint32_t CacheEntry_BYTECODE
        = 1;\nstatic const uint32_t CacheEntry_OPTIONS = 2;\n\n// Some compile options
        can't be combined differently between save and load.\n//\n// CacheEntries
        store a CacheOption set, and on load an exception is thrown\n// if the entries
        are incompatible.\n\nenum CacheOptions : uint32_t {\n  IsRunOnce,\n  NoScriptRval,\n
        \ Global,\n  NonSyntactic,\n  SourceIsLazy,\n  ForceFullParse,\n};\n\nstruct
        CacheOptionSet : public mozilla::EnumSet<CacheOptions> {\n  using mozilla::EnumSet<CacheOptions>::EnumSet;\n\n
        \ explicit CacheOptionSet(const CompileOptions& options) : EnumSet() {\n    initFromOptions(options);\n
        \ }\n\n  void initFromOptions(const CompileOptions& options) {\n    if (options.noScriptRval)
        {\n      *this += CacheOptions::NoScriptRval;\n    }\n    if (options.isRunOnce)
        {\n      *this += CacheOptions::IsRunOnce;\n    }\n    if (options.sourceIsLazy)
        {\n      *this += CacheOptions::SourceIsLazy;\n    }\n    if (options.forceFullParse())
        {\n      *this += CacheOptions::ForceFullParse;\n    }\n    if (options.nonSyntacticScope)
        {\n      *this += CacheOptions::NonSyntactic;\n    }\n  }\n};\n\nstatic bool
        CacheOptionsCompatible(const CacheOptionSet& a,\n                                   const
        CacheOptionSet& b) {\n  // If the options are identical, they are trivially
        compatible.\n  return a == b;\n}\n\nstatic const JSClass CacheEntry_class
        = {\"CacheEntryObject\",\n                                         JSCLASS_HAS_RESERVED_SLOTS(3)};\n\nstatic
        bool CacheEntry(JSContext* cx, unsigned argc, JS::Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 1 || !args[0].isString())
        {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"CacheEntry\");\n    return false;\n  }\n\n  RootedObject obj(cx, JS_NewObject(cx,
        &CacheEntry_class));\n  if (!obj) {\n    return false;\n  }\n\n  JS::SetReservedSlot(obj,
        CacheEntry_SOURCE, args[0]);\n  JS::SetReservedSlot(obj, CacheEntry_BYTECODE,
        UndefinedValue());\n\n  // Fill in empty option set.\n  CacheOptionSet defaultOptions;\n
        \ JS::SetReservedSlot(obj, CacheEntry_OPTIONS,\n                      Int32Value(defaultOptions.serialize()));\n\n
        \ args.rval().setObject(*obj);\n  return true;\n}\n\nstatic bool CacheEntry_isCacheEntry(JSObject*
        cache) {\n  return cache->hasClass(&CacheEntry_class);\n}\n\nstatic JSString*
        CacheEntry_getSource(JSContext* cx, HandleObject cache) {\n  MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n
        \ Value v = JS::GetReservedSlot(cache, CacheEntry_SOURCE);\n  if (!v.isString())
        {\n    JS_ReportErrorASCII(\n        cx, \"CacheEntry_getSource: Unexpected
        type of source reserved slot.\");\n    return nullptr;\n  }\n\n  return v.toString();\n}\n\nstatic
        bool CacheEntry_compatible(JSContext* cx, HandleObject cache,\n                                  const
        CacheOptionSet& currentOptionSet) {\n  CacheOptionSet cacheEntryOptions;\n
        \ MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n  Value v = JS::GetReservedSlot(cache,
        CacheEntry_OPTIONS);\n  cacheEntryOptions.deserialize(v.toInt32());\n  if
        (!CacheOptionsCompatible(cacheEntryOptions, currentOptionSet)) {\n    JS_ReportErrorASCII(cx,\n
        \                       \"CacheEntry_compatible: Incompatible cache contents\");\n
        \   return false;\n  }\n  return true;\n}\n\nstatic uint8_t* CacheEntry_getBytecode(JSContext*
        cx, HandleObject cache,\n                                       size_t* length)
        {\n  MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n  Value v = JS::GetReservedSlot(cache,
        CacheEntry_BYTECODE);\n  if (!v.isObject() || !v.toObject().is<ArrayBufferObject>())
        {\n    JS_ReportErrorASCII(\n        cx,\n        \"CacheEntry_getBytecode:
        Unexpected type of bytecode reserved slot.\");\n    return nullptr;\n  }\n\n
        \ ArrayBufferObject* arrayBuffer = &v.toObject().as<ArrayBufferObject>();\n
        \ *length = arrayBuffer->byteLength();\n  return arrayBuffer->dataPointer();\n}\n\nstatic
        bool CacheEntry_setBytecode(JSContext* cx, HandleObject cache,\n                                   const
        CacheOptionSet& cacheOptions,\n                                   uint8_t*
        buffer, uint32_t length) {\n  MOZ_ASSERT(CacheEntry_isCacheEntry(cache));\n\n
        \ using BufferContents = ArrayBufferObject::BufferContents;\n\n  BufferContents
        contents = BufferContents::createMallocedUnknownArena(buffer);\n  Rooted<ArrayBufferObject*>
        arrayBuffer(\n      cx, ArrayBufferObject::createForContents(cx, length, contents));\n
        \ if (!arrayBuffer) {\n    return false;\n  }\n\n  JS::SetReservedSlot(cache,
        CacheEntry_BYTECODE, ObjectValue(*arrayBuffer));\n  JS::SetReservedSlot(cache,
        CacheEntry_OPTIONS,\n                      Int32Value(cacheOptions.serialize()));\n
        \ return true;\n}\n\nstatic bool ConvertTranscodeResultToJSException(JSContext*
        cx,\n                                                JS::TranscodeResult rv)
        {\n  switch (rv) {\n    case JS::TranscodeResult::Ok:\n      return true;\n\n
        \   default:\n      [[fallthrough]];\n    case JS::TranscodeResult::Failure:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"generic warning\");\n      return false;\n    case JS::TranscodeResult::Failure_BadBuildId:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"the build-id does not match\");\n      return false;\n    case JS::TranscodeResult::Failure_AsmJSNotSupported:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"Asm.js is not supported by XDR\");\n      return false;\n    case JS::TranscodeResult::Failure_BadDecode:\n
        \     MOZ_ASSERT(!cx->isExceptionPending());\n      JS_ReportErrorASCII(cx,
        \"XDR data corruption\");\n      return false;\n\n    case JS::TranscodeResult::Throw:\n
        \     MOZ_ASSERT(cx->isExceptionPending());\n      return false;\n  }\n}\n\nstatic
        void SetQuitting(JSContext* cx, int32_t code) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ js::StopDrainingJobQueue(cx);\n  sc->exitCode = code;\n  sc->quitting =
        true;\n}\n\nstatic void UnsetQuitting(JSContext* cx) {\n  ShellContext* sc
        = GetShellContext(cx);\n  js::RestartDrainingJobQueue(cx);\n  sc->exitCode
        = 0;\n  sc->quitting = false;\n}\n\nstatic bool Evaluate(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        < 1 || args.length() > 2) {\n    JS_ReportErrorNumberASCII(\n        cx, my_GetErrorMessage,
        nullptr,\n        args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,\n
        \       \"evaluate\");\n    return false;\n  }\n\n  RootedString code(cx,
        nullptr);\n  RootedObject cacheEntry(cx, nullptr);\n  if (args[0].isString())
        {\n    code = args[0].toString();\n  } else if (args[0].isObject() &&\n             CacheEntry_isCacheEntry(&args[0].toObject()))
        {\n    cacheEntry = &args[0].toObject();\n    code = CacheEntry_getSource(cx,
        cacheEntry);\n    if (!code) {\n      return false;\n    }\n  }\n\n  if (!code
        || (args.length() == 2 && args[1].isPrimitive())) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"evaluate\");\n    return false;\n  }\n\n  RootedObject opts(cx);\n  if (args.length()
        == 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(cx, \"evaluate:
        The 2nd argument must be an object\");\n      return false;\n    }\n\n    opts
        = &args[1].toObject();\n  }\n\n  RootedObject global(cx, JS::CurrentGlobalOrNull(cx));\n
        \ MOZ_ASSERT(global);\n\n  // Check \"global\" property before everything
        to use the given global's\n  // option as the default value.\n  Maybe<CompileOptions>
        maybeOptions;\n  if (opts) {\n    RootedValue v(cx);\n    if (!JS_GetProperty(cx,
        opts, \"global\", &v)) {\n      return false;\n    }\n    if (!v.isUndefined())
        {\n      if (v.isObject()) {\n        global = js::CheckedUnwrapDynamic(&v.toObject(),
        cx,\n                                          /* stopAtWindowProxy = */ false);\n
        \       if (!global) {\n          return false;\n        }\n      }\n      if
        (!global || !(JS::GetClass(global)->flags & JSCLASS_IS_GLOBAL)) {\n        JS_ReportErrorNumberASCII(\n
        \           cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,\n            \"\\\"global\\\"
        passed to evaluate()\", \"not a global object\");\n        return false;\n
        \     }\n\n      JSAutoRealm ar(cx, global);\n      maybeOptions.emplace(cx);\n
        \   }\n  }\n  if (!maybeOptions) {\n    // If \"global\" property is not given,
        use the current global's option as\n    // the default value.\n    maybeOptions.emplace(cx);\n
        \ }\n\n  CompileOptions& options = maybeOptions.ref();\n  UniqueChars fileNameBytes;\n
        \ RootedString displayURL(cx);\n  RootedString sourceMapURL(cx);\n  bool catchTermination
        = false;\n  bool loadBytecode = false;\n  bool saveIncrementalBytecode = false;\n
        \ bool execute = true;\n  bool assertEqBytecode = false;\n  JS::RootedObjectVector
        envChain(cx);\n  RootedObject callerGlobal(cx, cx->global());\n\n  options.setIntroductionType(\"js
        shell evaluate\")\n      .setFileAndLine(\"@evaluate\", 1)\n      .setDeferDebugMetadata();\n\n
        \ RootedValue privateValue(cx);\n  RootedString elementAttributeName(cx);\n\n
        \ if (opts) {\n    if (!js::ParseCompileOptions(cx, options, opts, &fileNameBytes))
        {\n      return false;\n    }\n    if (!ParseDebugMetadata(cx, opts, &privateValue,
        &elementAttributeName)) {\n      return false;\n    }\n    if (!ParseSourceOptions(cx,
        opts, &displayURL, &sourceMapURL)) {\n      return false;\n    }\n\n    RootedValue
        v(cx);\n    if (!JS_GetProperty(cx, opts, \"catchTermination\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      catchTermination = ToBoolean(v);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"loadBytecode\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      loadBytecode = ToBoolean(v);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"saveIncrementalBytecode\", &v))
        {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      saveIncrementalBytecode
        = ToBoolean(v);\n    }\n\n    if (!JS_GetProperty(cx, opts, \"execute\", &v))
        {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      execute
        = ToBoolean(v);\n    }\n\n    if (!JS_GetProperty(cx, opts, \"assertEqBytecode\",
        &v)) {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      assertEqBytecode
        = ToBoolean(v);\n    }\n\n    if (!JS_GetProperty(cx, opts, \"envChainObject\",
        &v)) {\n      return false;\n    }\n    if (!v.isUndefined()) {\n      if
        (!v.isObject()) {\n        JS_ReportErrorNumberASCII(\n            cx, GetErrorMessage,
        nullptr, JSMSG_UNEXPECTED_TYPE,\n            \"\\\"envChainObject\\\" passed
        to evaluate()\", \"not an object\");\n        return false;\n      }\n\n      RootedObject
        obj(cx, &v.toObject());\n      {\n        // This may be a CCW, so try to
        unwrap before checking\n        // if it is an unqualified variables object.
        We still append\n        // the original object to the environment chain however.\n
        \       JSObject* unwrappedObj = js::UncheckedUnwrap(obj, cx);\n        if
        (unwrappedObj->isUnqualifiedVarObj()) {\n          JS_ReportErrorASCII(\n
        \             cx,\n              \"\\\"envChainObject\\\" passed to evaluate()
        should not be an \"\n              \"unqualified variables object\");\n          return
        false;\n        }\n      }\n\n      if (!envChain.append(obj)) {\n        return
        false;\n      }\n    }\n\n    // We cannot load or save the bytecode if we
        have no object where the\n    // bytecode cache is stored.\n    if (loadBytecode
        || saveIncrementalBytecode) {\n      if (!cacheEntry) {\n        JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                                  JSSMSG_INVALID_ARGS,
        \"evaluate\");\n        return false;\n      }\n    }\n  }\n\n  if (envChain.length()
        != 0) {\n    // Wrap the envChainObject list into target realm.\n    JSAutoRealm
        ar(cx, global);\n    for (size_t i = 0; i < envChain.length(); ++i) {\n      if
        (!JS_WrapObject(cx, envChain[i])) {\n        return false;\n      }\n    }\n\n
        \   options.setNonSyntacticScope(true);\n  }\n\n  // The `loadBuffer` we use
        below outlives the Stencil we generate so we can\n  // use its contents directly
        in the Stencil.\n  options.borrowBuffer = true;\n\n  // We need to track the
        options used to generate bytecode for a CacheEntry to\n  // avoid mismatches.
        This is primarily a concern when fuzzing the jsshell.\n  CacheOptionSet cacheOptions;\n
        \ cacheOptions.initFromOptions(options);\n\n  JS::TranscodeBuffer loadBuffer;\n
        \ JS::TranscodeBuffer saveBuffer;\n\n  if (loadBytecode) {\n    size_t loadLength
        = 0;\n    uint8_t* loadData = nullptr;\n\n    if (!CacheEntry_compatible(cx,
        cacheEntry, cacheOptions)) {\n      return false;\n    }\n\n    loadData =
        CacheEntry_getBytecode(cx, cacheEntry, &loadLength);\n    if (!loadData) {\n
        \     return false;\n    }\n    if (!loadBuffer.append(loadData, loadLength))
        {\n      JS_ReportOutOfMemory(cx);\n      return false;\n    }\n  }\n\n  {\n
        \   JSAutoRealm ar(cx, global);\n    RefPtr<JS::Stencil> stencil;\n\n    if
        (loadBytecode) {\n      JS::TranscodeRange range(loadBuffer.begin(), loadBuffer.length());\n
        \     JS::DecodeOptions decodeOptions(options);\n\n      JS::TranscodeResult
        rv =\n          JS::DecodeStencil(cx, decodeOptions, range, getter_AddRefs(stencil));\n
        \     if (JS::IsTranscodeFailureResult(rv)) {\n        JS_ReportErrorASCII(cx,
        \"failed to decode cache\");\n        return false;\n      }\n\n      if (!ConvertTranscodeResultToJSException(cx,
        rv)) {\n        return false;\n      }\n    } else {\n      AutoStableStringChars
        linearChars(cx);\n      if (!linearChars.initTwoByte(cx, code)) {\n        return
        false;\n      }\n\n      JS::SourceText<char16_t> srcBuf;\n      if (!srcBuf.initMaybeBorrowed(cx,
        linearChars)) {\n        return false;\n      }\n\n      stencil = JS::CompileGlobalScriptToStencil(cx,
        options, srcBuf);\n      if (!stencil) {\n        return false;\n      }\n
        \   }\n\n    if (!js::ValidateLazinessOfStencilAndGlobal(cx, *stencil)) {\n
        \     return false;\n    }\n\n    JS::InstantiateOptions instantiateOptions(options);\n
        \   RootedScript script(\n        cx, JS::InstantiateGlobalStencil(cx, instantiateOptions,
        stencil));\n    if (!script) {\n      return false;\n    }\n\n    AutoReportFrontendContext
        fc(cx);\n    if (!SetSourceOptions(cx, &fc, script->scriptSource(), displayURL,\n
        \                         sourceMapURL)) {\n      return false;\n    }\n\n
        \   if (!JS::UpdateDebugMetadata(cx, script, instantiateOptions, privateValue,\n
        \                                elementAttributeName, nullptr, nullptr))
        {\n      return false;\n    }\n\n    if (saveIncrementalBytecode) {\n      bool
        alreadyStarted;\n      if (!JS::StartIncrementalEncoding(cx, std::move(stencil),\n
        \                                       alreadyStarted)) {\n        return
        false;\n      }\n      MOZ_ASSERT(!alreadyStarted);\n    }\n\n    if (execute)
        {\n      if (!(envChain.empty()\n                ? JS_ExecuteScript(cx, script,
        args.rval())\n                : JS_ExecuteScript(cx, envChain, script, args.rval())))
        {\n        if (catchTermination && !JS_IsExceptionPending(cx)) {\n          ShellContext*
        sc = GetShellContext(cx);\n          if (sc->quitting) {\n            UnsetQuitting(cx);\n
        \         }\n\n          JSAutoRealm ar1(cx, callerGlobal);\n          JSString*
        str = JS_NewStringCopyZ(cx, \"terminated\");\n          if (!str) {\n            return
        false;\n          }\n          args.rval().setString(str);\n          return
        true;\n        }\n        return false;\n      }\n    }\n\n    // Serialize
        the encoded bytecode, recorded before the execution, into a\n    // buffer
        which can be deserialized linearly.\n    if (saveIncrementalBytecode) {\n
        \     if (!FinishIncrementalEncoding(cx, script, saveBuffer)) {\n        return
        false;\n      }\n    }\n  }\n\n  if (saveIncrementalBytecode) {\n    // If
        we are both loading and saving, we assert that we are going to\n    // replace
        the current bytecode by the same stream of bytes.\n    if (loadBytecode &&
        assertEqBytecode) {\n      if (saveBuffer.length() != loadBuffer.length())
        {\n        char loadLengthStr[16];\n        SprintfLiteral(loadLengthStr,
        \"%zu\", loadBuffer.length());\n        char saveLengthStr[16];\n        SprintfLiteral(saveLengthStr,
        \"%zu\", saveBuffer.length());\n\n        JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                                  JSSMSG_CACHE_EQ_SIZE_FAILED, loadLengthStr,\n
        \                                 saveLengthStr);\n        return false;\n
        \     }\n\n      if (!ArrayEqual(loadBuffer.begin(), saveBuffer.begin(),\n
        \                     loadBuffer.length())) {\n        JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                                  JSSMSG_CACHE_EQ_CONTENT_FAILED);\n
        \       return false;\n      }\n    }\n\n    size_t saveLength = saveBuffer.length();\n
        \   if (saveLength >= INT32_MAX) {\n      JS_ReportErrorASCII(cx, \"Cannot
        save large cache entry content\");\n      return false;\n    }\n    uint8_t*
        saveData = saveBuffer.extractOrCopyRawBuffer();\n    if (!CacheEntry_setBytecode(cx,
        cacheEntry, cacheOptions, saveData,\n                                saveLength))
        {\n      js_free(saveData);\n      return false;\n    }\n  }\n\n  return JS_WrapValue(cx,
        args.rval());\n}\n\nJSString* js::shell::FileAsString(JSContext* cx, JS::HandleString
        pathnameStr) {\n  UniqueChars pathname = JS_EncodeStringToUTF8(cx, pathnameStr);\n
        \ if (!pathname) {\n    return nullptr;\n  }\n\n  FILE* file = OpenFile(cx,
        pathname.get(), \"rb\");\n  if (!file) {\n    return nullptr;\n  }\n\n  AutoCloseFile
        autoClose(file);\n\n  struct stat st;\n  if (fstat(fileno(file), &st) != 0)
        {\n    JS_ReportErrorUTF8(cx, \"can't stat %s\", pathname.get());\n    return
        nullptr;\n  }\n\n  if ((st.st_mode & S_IFMT) != S_IFREG) {\n    JS_ReportErrorUTF8(cx,
        \"can't read non-regular file %s\", pathname.get());\n    return nullptr;\n
        \ }\n\n  size_t len;\n  if (!FileSize(cx, pathname.get(), file, &len)) {\n
        \   return nullptr;\n  }\n\n  UniqueChars buf(js_pod_malloc<char>(len + 1));\n
        \ if (!buf) {\n    JS_ReportErrorUTF8(cx, \"out of memory reading %s\", pathname.get());\n
        \   return nullptr;\n  }\n\n  if (!ReadFile(cx, pathname.get(), file, buf.get(),
        len)) {\n    return nullptr;\n  }\n\n  UniqueTwoByteChars ucbuf(\n      JS::LossyUTF8CharsToNewTwoByteCharsZ(cx,
        JS::UTF8Chars(buf.get(), len),\n                                           &len,
        js::MallocArena)\n          .get());\n  if (!ucbuf) {\n    JS_ReportErrorUTF8(cx,
        \"Invalid UTF-8 in file '%s'\", pathname.get());\n    return nullptr;\n  }\n\n
        \ return JS_NewUCStringCopyN(cx, ucbuf.get(), len);\n}\n\n/*\n * Function
        to run scripts and return compilation + execution time. Semantics\n * are
        closely modelled after the equivalent function in WebKit, as this is used\n
        * to produce benchmark timings by SunSpider.\n */\nstatic bool Run(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (args.length() != 1) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS, \"run\");\n    return
        false;\n  }\n\n  RootedString str(cx, JS::ToString(cx, args[0]));\n  if (!str)
        {\n    return false;\n  }\n  args[0].setString(str);\n\n  str = FileAsString(cx,
        str);\n  if (!str) {\n    return false;\n  }\n\n  AutoStableStringChars linearChars(cx);\n
        \ if (!linearChars.initTwoByte(cx, str)) {\n    return false;\n  }\n\n  JS::SourceText<char16_t>
        srcBuf;\n  if (!srcBuf.initMaybeBorrowed(cx, linearChars)) {\n    return false;\n
        \ }\n\n  RootedScript script(cx);\n  int64_t startClock = PRMJ_Now();\n  {\n
        \   UniqueChars filename = JS_EncodeStringToUTF8(cx, str);\n    if (!filename)
        {\n      return false;\n    }\n\n    JS::CompileOptions options(cx);\n    options.setIntroductionType(\"js
        shell run\")\n        .setFileAndLine(filename.get(), 1)\n        .setIsRunOnce(true)\n
        \       .setNoScriptRval(true)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   script = JS::Compile(cx, options, srcBuf);\n    if (!script) {\n      return
        false;\n    }\n  }\n\n  if (!JS_ExecuteScript(cx, script)) {\n    return false;\n
        \ }\n\n  int64_t endClock = PRMJ_Now();\n\n  args.rval().setDouble((endClock
        - startClock) / double(PRMJ_USEC_PER_MSEC));\n  return true;\n}\n\nstatic
        int js_fgets(char* buf, int size, FILE* file) {\n  int n, i, c;\n  bool crflag;\n\n
        \ n = size - 1;\n  if (n < 0) {\n    return -1;\n  }\n\n  // Use the fastest
        available getc.\n  auto fast_getc =\n#if defined(HAVE_GETC_UNLOCKED)\n      getc_unlocked\n#elif
        defined(HAVE__GETC_NOLOCK)\n      _getc_nolock\n#else\n      getc\n#endif\n
        \     ;\n\n  crflag = false;\n  for (i = 0; i < n && (c = fast_getc(file))
        != EOF; i++) {\n    buf[i] = c;\n    if (c == '\\n') {  // any \\n ends a
        line\n      i++;            // keep the \\n; we know there is room for \\0\n
        \     break;\n    }\n    if (crflag) {  // \\r not followed by \\n ends line
        at the \\r\n      ungetc(c, file);\n      break;  // and overwrite c in buf
        with \\0\n    }\n    crflag = (c == '\\r');\n  }\n\n  buf[i] = '\\0';\n  return
        i;\n}\n\n/*\n * function readline()\n * Provides a hook for scripts to read
        a line from stdin.\n */\nstatic bool ReadLine(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  static constexpr
        size_t BUFSIZE = 256;\n  FILE* from = stdin;\n  size_t buflength = 0;\n  size_t
        bufsize = BUFSIZE;\n  char* buf = (char*)JS_malloc(cx, bufsize);\n  if (!buf)
        {\n    return false;\n  }\n\n  bool sawNewline = false;\n  size_t gotlength;\n
        \ while ((gotlength = js_fgets(buf + buflength, bufsize - buflength, from))
        >\n         0) {\n    buflength += gotlength;\n\n    /* Are we done? */\n
        \   if (buf[buflength - 1] == '\\n') {\n      buf[buflength - 1] = '\\0';\n
        \     sawNewline = true;\n      break;\n    } else if (buflength < bufsize
        - 1) {\n      break;\n    }\n\n    /* Else, grow our buffer for another pass.
        */\n    char* tmp;\n    bufsize *= 2;\n    if (bufsize > buflength) {\n      tmp
        = static_cast<char*>(JS_realloc(cx, buf, bufsize / 2, bufsize));\n    } else
        {\n      JS_ReportOutOfMemory(cx);\n      tmp = nullptr;\n    }\n\n    if
        (!tmp) {\n      JS_free(cx, buf);\n      return false;\n    }\n\n    buf =
        tmp;\n  }\n\n  /* Treat the empty string specially. */\n  if (buflength ==
        0) {\n    args.rval().set(feof(from) ? NullValue() : JS_GetEmptyStringValue(cx));\n
        \   JS_free(cx, buf);\n    return true;\n  }\n\n  /* Shrink the buffer to
        the real size. */\n  char* tmp = static_cast<char*>(JS_realloc(cx, buf, bufsize,
        buflength));\n  if (!tmp) {\n    JS_free(cx, buf);\n    return false;\n  }\n\n
        \ buf = tmp;\n\n  /*\n   * Turn buf into a JSString. Note that buflength includes
        the trailing null\n   * character.\n   */\n  JSString* str =\n      JS_NewStringCopyN(cx,
        buf, sawNewline ? buflength - 1 : buflength);\n  JS_free(cx, buf);\n  if (!str)
        {\n    return false;\n  }\n\n  args.rval().setString(str);\n  return true;\n}\n\n/*\n
        * function readlineBuf()\n * Provides a hook for scripts to emulate readline()
        using a string object.\n */\nstatic bool ReadLineBuf(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  ShellContext*
        sc = GetShellContext(cx);\n\n  if (!args.length()) {\n    if (!sc->readLineBuf)
        {\n      JS_ReportErrorASCII(cx,\n                          \"No source buffer
        set. You must initially \"\n                          \"call readlineBuf with
        an argument.\");\n      return false;\n    }\n\n    char* currentBuf = sc->readLineBuf.get()
        + sc->readLineBufPos;\n    size_t buflen = strlen(currentBuf);\n\n    if (!buflen)
        {\n      args.rval().setNull();\n      return true;\n    }\n\n    size_t len
        = 0;\n    while (len < buflen) {\n      if (currentBuf[len] == '\\n') {\n
        \       break;\n      }\n      len++;\n    }\n\n    JSString* str = JS_NewStringCopyUTF8N(cx,
        JS::UTF8Chars(currentBuf, len));\n    if (!str) {\n      return false;\n    }\n\n
        \   if (currentBuf[len] == '\\0') {\n      sc->readLineBufPos += len;\n    }
        else {\n      sc->readLineBufPos += len + 1;\n    }\n\n    args.rval().setString(str);\n
        \   return true;\n  }\n\n  if (args.length() == 1) {\n    sc->readLineBuf
        = nullptr;\n    sc->readLineBufPos = 0;\n\n    RootedString str(cx, JS::ToString(cx,
        args[0]));\n    if (!str) {\n      return false;\n    }\n    sc->readLineBuf
        = JS_EncodeStringToUTF8(cx, str);\n    if (!sc->readLineBuf) {\n      return
        false;\n    }\n\n    args.rval().setUndefined();\n    return true;\n  }\n\n
        \ JS_ReportErrorASCII(cx, \"Must specify at most one argument\");\n  return
        false;\n}\n\nstatic bool PutStr(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 0) {\n
        \   if (!gOutFile->isOpen()) {\n      JS_ReportErrorASCII(cx, \"output file
        is closed\");\n      return false;\n    }\n\n    RootedString str(cx, JS::ToString(cx,
        args[0]));\n    if (!str) {\n      return false;\n    }\n    UniqueChars bytes
        = JS_EncodeStringToUTF8(cx, str);\n    if (!bytes) {\n      return false;\n
        \   }\n    fputs(bytes.get(), gOutFile->fp);\n    fflush(gOutFile->fp);\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic bool Now(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ double now = PRMJ_Now() / double(PRMJ_USEC_PER_MSEC);\n  args.rval().setDouble(now);\n
        \ return true;\n}\n\nstatic bool CpuNow(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  double now = double(std::clock())
        / double(CLOCKS_PER_SEC);\n  args.rval().setDouble(now);\n  return true;\n}\n\nstatic
        bool PrintInternal(JSContext* cx, const CallArgs& args, RCFile* file) {\n
        \ if (!file->isOpen()) {\n    JS_ReportErrorASCII(cx, \"output file is closed\");\n
        \   return false;\n  }\n\n  for (unsigned i = 0; i < args.length(); i++) {\n
        \   RootedString str(cx, JS::ToString(cx, args[i]));\n    if (!str) {\n      return
        false;\n    }\n    UniqueChars bytes = JS_EncodeStringToUTF8(cx, str);\n    if
        (!bytes) {\n      return false;\n    }\n    fprintf(file->fp, \"%s%s\", i
        ? \" \" : \"\", bytes.get());\n  }\n\n  fputc('\\n', file->fp);\n  fflush(file->fp);\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool Print(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n#ifdef
        FUZZING_INTERFACES\n  if (fuzzHaveModule && !fuzzDoDebug) {\n    // When fuzzing
        and not debugging, suppress any print() output,\n    // as it slows down fuzzing
        and makes libFuzzer's output hard\n    // to read.\n    args.rval().setUndefined();\n
        \   return true;\n  }\n#endif  // FUZZING_INTERFACES\n  return PrintInternal(cx,
        args, gOutFile);\n}\n\nstatic bool PrintErr(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  return PrintInternal(cx,
        args, gErrFile);\n}\n\nstatic bool Help(JSContext* cx, unsigned argc, Value*
        vp);\n\nstatic bool Quit(JSContext* cx, unsigned argc, Value* vp) {\n  //
        Print a message to stderr in differential testing to help jsfunfuzz\n  //
        find uncatchable-exception bugs.\n  if (js::SupportDifferentialTesting())
        {\n    fprintf(stderr, \"quit called\\n\");\n  }\n\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  int32_t code;\n  if (!ToInt32(cx, args.get(0), &code)) {\n    return
        false;\n  }\n\n  // The fuzzers check the shell's exit code and assume a value
        >= 128 means\n  // the process crashed (for instance, SIGSEGV will result
        in code 139). On\n  // POSIX platforms, the exit code is 8-bit and negative
        values can also\n  // result in an exit code >= 128. We restrict the value
        to range [0, 127] to\n  // avoid false positives.\n  if (code < 0 || code
        >= 128) {\n    JS_ReportErrorASCII(cx, \"quit exit code should be in range
        0-127\");\n    return false;\n  }\n\n  SetQuitting(cx, code);\n  return false;\n}\n\nstatic
        bool StartTimingMutator(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (args.length() > 0) {\n    JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                              JSSMSG_TOO_MANY_ARGS,
        \"startTimingMutator\");\n    return false;\n  }\n\n  if (!cx->runtime()->gc.stats().startTimingMutator())
        {\n    JS_ReportErrorASCII(\n        cx, \"StartTimingMutator should only
        be called from outside of GC\");\n    return false;\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool StopTimingMutator(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        > 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              JSSMSG_TOO_MANY_ARGS,
        \"stopTimingMutator\");\n    return false;\n  }\n\n  double mutator_ms, gc_ms;\n
        \ if (!cx->runtime()->gc.stats().stopTimingMutator(mutator_ms, gc_ms)) {\n
        \   JS_ReportErrorASCII(cx,\n                        \"stopTimingMutator called
        when not timing the mutator\");\n    return false;\n  }\n  double total_ms
        = mutator_ms + gc_ms;\n  if (total_ms > 0 && gOutFile->isOpen()) {\n    fprintf(gOutFile->fp,
        \"Mutator: %.3fms (%.1f%%), GC: %.3fms (%.1f%%)\\n\",\n            mutator_ms,
        mutator_ms / total_ms * 100.0, gc_ms,\n            gc_ms / total_ms * 100.0);\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic const char*
        ToSource(JSContext* cx, HandleValue vp, UniqueChars* bytes) {\n  RootedString
        str(cx, JS_ValueToSource(cx, vp));\n  if (str) {\n    *bytes = JS_EncodeStringToUTF8(cx,
        str);\n    if (*bytes) {\n      return bytes->get();\n    }\n  }\n  JS_ClearPendingException(cx);\n
        \ return \"<<error converting value to string>>\";\n}\n\nstatic bool AssertEq(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (!(args.length() == 2 || (args.length() == 3 && args[2].isString())))
        {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              (args.length()
        < 2)    ? JSSMSG_NOT_ENOUGH_ARGS\n                              : (args.length()
        == 3) ? JSSMSG_INVALID_ARGS\n                                                     :
        JSSMSG_TOO_MANY_ARGS,\n                              \"assertEq\");\n    return
        false;\n  }\n\n  bool same;\n  if (!JS::SameValue(cx, args[0], args[1], &same))
        {\n    return false;\n  }\n  if (!same) {\n    UniqueChars bytes0, bytes1;\n
        \   const char* actual = ToSource(cx, args[0], &bytes0);\n    const char*
        expected = ToSource(cx, args[1], &bytes1);\n    if (args.length() == 2) {\n
        \     JS_ReportErrorNumberUTF8(cx, my_GetErrorMessage, nullptr,\n                               JSSMSG_ASSERT_EQ_FAILED,
        actual, expected);\n    } else {\n      RootedString message(cx, args[2].toString());\n
        \     UniqueChars bytes2 = QuoteString(cx, message);\n      if (!bytes2) {\n
        \       return false;\n      }\n      JS_ReportErrorNumberUTF8(cx, my_GetErrorMessage,
        nullptr,\n                               JSSMSG_ASSERT_EQ_FAILED_MSG, actual,
        expected,\n                               bytes2.get());\n    }\n    return
        false;\n  }\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic JSScript*
        GetTopScript(JSContext* cx) {\n  NonBuiltinScriptFrameIter iter(cx);\n  return
        iter.done() ? nullptr : iter.script();\n}\n\nstatic bool GetScriptAndPCArgs(JSContext*
        cx, CallArgs& args,\n                               MutableHandleScript scriptp,
        int32_t* ip) {\n  RootedScript script(cx, GetTopScript(cx));\n  *ip = 0;\n
        \ if (!args.get(0).isUndefined()) {\n    HandleValue v = args[0];\n    unsigned
        intarg = 0;\n    if (v.isObject() && JS::GetClass(&v.toObject())->isJSFunction())
        {\n      script = TestingFunctionArgumentToScript(cx, v);\n      if (!script)
        {\n        return false;\n      }\n      intarg++;\n    }\n    if (!args.get(intarg).isUndefined())
        {\n      if (!JS::ToInt32(cx, args[intarg], ip)) {\n        return false;\n
        \     }\n      if ((uint32_t)*ip >= script->length()) {\n        JS_ReportErrorASCII(cx,
        \"Invalid PC\");\n        return false;\n      }\n    }\n  }\n\n  scriptp.set(script);\n\n
        \ return true;\n}\n\nstatic bool LineToPC(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        == 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n
        \                             JSSMSG_LINE2PC_USAGE);\n    return false;\n
        \ }\n\n  RootedScript script(cx, GetTopScript(cx));\n  int32_t lineArg = 0;\n
        \ if (args[0].isObject() && args[0].toObject().is<JSFunction>()) {\n    script
        = TestingFunctionArgumentToScript(cx, args[0]);\n    if (!script) {\n      return
        false;\n    }\n    lineArg++;\n  }\n\n  uint32_t lineno;\n  if (!ToUint32(cx,
        args.get(lineArg), &lineno)) {\n    return false;\n  }\n\n  jsbytecode* pc
        = LineNumberToPC(script, lineno);\n  if (!pc) {\n    return false;\n  }\n
        \ args.rval().setInt32(script->pcToOffset(pc));\n  return true;\n}\n\nstatic
        bool PCToLine(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  RootedScript script(cx);\n  int32_t i;\n  unsigned
        lineno;\n\n  if (!GetScriptAndPCArgs(cx, args, &script, &i)) {\n    return
        false;\n  }\n  lineno = PCToLineNumber(script, script->offsetToPC(i));\n  if
        (!lineno) {\n    return false;\n  }\n  args.rval().setInt32(lineno);\n  return
        true;\n}\n\n#if defined(DEBUG) || defined(JS_JITSPEW)\n\nstatic bool Notes(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ JSSprinter sprinter(cx);\n  if (!sprinter.init()) {\n    return false;\n
        \ }\n\n  for (unsigned i = 0; i < args.length(); i++) {\n    RootedScript
        script(cx, TestingFunctionArgumentToScript(cx, args[i]));\n    if (!script)
        {\n      return false;\n    }\n\n    if (!JSScript::dumpSrcNotes(cx, script,
        &sprinter)) {\n      return false;\n    }\n  }\n\n  JSString* str = sprinter.release(cx);\n
        \ if (!str) {\n    return false;\n  }\n  args.rval().setString(str);\n  return
        true;\n}\n\nnamespace {\n\nstruct DisassembleOptionParser {\n  unsigned argc;\n
        \ Value* argv;\n  JSScript::DumpOptions options;\n\n  DisassembleOptionParser(unsigned
        argc, Value* argv)\n      : argc(argc), argv(argv) {}\n\n  bool parse(JSContext*
        cx) {\n    options.recursive = false;\n\n    /* Read options off early arguments
        */\n    while (argc > 0 && argv[0].isString()) {\n      JSString* str = argv[0].toString();\n
        \     JSLinearString* linearStr = JS_EnsureLinearString(cx, str);\n      if
        (!linearStr) {\n        return false;\n      }\n      if (JS_LinearStringEqualsLiteral(linearStr,
        \"-r\")) {\n        options.recursive = true;\n      } else {\n        break;\n
        \     }\n      argv++;\n      argc--;\n    }\n    return true;\n  }\n};\n\n}
        /* anonymous namespace */\n\nstatic bool DisassembleToSprinter(JSContext*
        cx, unsigned argc, Value* vp,\n                                  StringPrinter*
        sp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  DisassembleOptionParser
        p(args.length(), args.array());\n  if (!p.parse(cx)) {\n    return false;\n
        \ }\n\n  if (p.argc == 0) {\n    /* Without arguments, disassemble the current
        script. */\n    RootedScript script(cx, GetTopScript(cx));\n    if (script)
        {\n      JSAutoRealm ar(cx, script);\n      if (!JSScript::dump(cx, script,
        p.options, sp)) {\n        return false;\n      }\n    }\n  } else {\n    for
        (unsigned i = 0; i < p.argc; i++) {\n      RootedFunction fun(cx);\n      RootedScript
        script(cx);\n      RootedValue value(cx, p.argv[i]);\n      if (value.isObject()
        && value.toObject().is<ShellModuleObjectWrapper>()) {\n        script = value.toObject()\n
        \                    .as<ShellModuleObjectWrapper>()\n                     .get()\n
        \                    ->maybeScript();\n      } else {\n        script = TestingFunctionArgumentToScript(cx,
        value, fun.address());\n      }\n      if (!script) {\n        return false;\n
        \     }\n\n      if (!JSScript::dump(cx, script, p.options, sp)) {\n        return
        false;\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool DisassembleToString(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ JSSprinter sprinter(cx);\n  if (!sprinter.init()) {\n    return false;\n
        \ }\n  if (!DisassembleToSprinter(cx, args.length(), vp, &sprinter)) {\n    return
        false;\n  }\n\n  JSString* str = sprinter.release(cx);\n  if (!str) {\n    return
        false;\n  }\n  args.rval().setString(str);\n  return true;\n}\n\nstatic bool
        Disassemble(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args =
        CallArgsFromVp(argc, vp);\n\n  if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx,
        \"output file is closed\");\n    return false;\n  }\n\n  Sprinter sprinter(cx);\n
        \ if (!sprinter.init()) {\n    return false;\n  }\n  if (!DisassembleToSprinter(cx,
        args.length(), vp, &sprinter)) {\n    return false;\n  }\n\n  JS::UniqueChars
        str = sprinter.release();\n  if (!str) {\n    return false;\n  }\n  fprintf(gOutFile->fp,
        \"%s\\n\", str.get());\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool DisassFile(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx,
        \"output file is closed\");\n    return false;\n  }\n\n  /* Support extra
        options at the start, just like Disassemble. */\n  DisassembleOptionParser
        p(args.length(), args.array());\n  if (!p.parse(cx)) {\n    return false;\n
        \ }\n\n  if (!p.argc) {\n    args.rval().setUndefined();\n    return true;\n
        \ }\n\n  // We should change DisassembleOptionParser to store CallArgs.\n
        \ Rooted<JSString*> str(\n      cx, JS::ToString(cx, HandleValue::fromMarkedLocation(&p.argv[0])));\n
        \ if (!str) {\n    return false;\n  }\n  UniqueChars filename = JS_EncodeStringToUTF8(cx,
        str);\n  if (!filename) {\n    return false;\n  }\n  RootedScript script(cx);\n\n
        \ {\n    CompileOptions options(cx);\n    options.setIntroductionType(\"js
        shell disFile\")\n        .setFileAndLine(filename.get(), 1)\n        .setIsRunOnce(true)\n
        \       .setNoScriptRval(true)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   script = JS::CompileUtf8Path(cx, options, filename.get());\n    if (!script)
        {\n      return false;\n    }\n  }\n\n  Sprinter sprinter(cx);\n  if (!sprinter.init())
        {\n    return false;\n  }\n  if (JSScript::dump(cx, script, p.options, &sprinter))
        {\n    return false;\n  }\n\n  JS::UniqueChars chars = sprinter.release();\n
        \ if (!chars) {\n    return false;\n  }\n  fprintf(gOutFile->fp, \"%s\\n\",
        chars.get());\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool DisassWithSrc(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx,
        \"output file is closed\");\n    return false;\n  }\n\n  const size_t lineBufLen
        = 512;\n  unsigned len, line1, line2, bupline;\n  char linebuf[lineBufLen];\n
        \ static const char sep[] = \";-------------------------\";\n\n  RootedScript
        script(cx);\n  for (unsigned i = 0; i < args.length(); i++) {\n    script
        = TestingFunctionArgumentToScript(cx, args[i]);\n    if (!script) {\n      return
        false;\n    }\n\n    if (!script->filename()) {\n      JS_ReportErrorNumberASCII(cx,
        my_GetErrorMessage, nullptr,\n                                JSSMSG_FILE_SCRIPTS_ONLY);\n
        \     return false;\n    }\n\n    FILE* file = OpenFile(cx, script->filename(),
        \"rb\");\n    if (!file) {\n      return false;\n    }\n    auto closeFile
        = MakeScopeExit([file] { fclose(file); });\n\n    jsbytecode* pc = script->code();\n
        \   jsbytecode* end = script->codeEnd();\n\n    Sprinter sprinter(cx);\n    if
        (!sprinter.init()) {\n      return false;\n    }\n\n    /* burn the leading
        lines */\n    line2 = PCToLineNumber(script, pc);\n    for (line1 = 0; line1
        < line2 - 1; line1++) {\n      char* tmp = fgets(linebuf, lineBufLen, file);\n
        \     if (!tmp) {\n        JS_ReportErrorUTF8(cx, \"failed to read %s fully\",
        script->filename());\n        return false;\n      }\n    }\n\n    bupline
        = 0;\n    while (pc < end) {\n      line2 = PCToLineNumber(script, pc);\n\n
        \     if (line2 < line1) {\n        if (bupline != line2) {\n          bupline
        = line2;\n          sprinter.printf(\"%s %3u: BACKUP\\n\", sep, line2);\n
        \       }\n      } else {\n        if (bupline && line1 == line2) {\n          sprinter.printf(\"%s
        %3u: RESTORE\\n\", sep, line2);\n        }\n        bupline = 0;\n        while
        (line1 < line2) {\n          if (!fgets(linebuf, lineBufLen, file)) {\n            JS_ReportErrorNumberUTF8(cx,
        my_GetErrorMessage, nullptr,\n                                     JSSMSG_UNEXPECTED_EOF,
        script->filename());\n            return false;\n          }\n          line1++;\n
        \         sprinter.printf(\"%s %3u: %s\", sep, line1, linebuf);\n        }\n
        \     }\n\n      len =\n          Disassemble1(cx, script, pc, script->pcToOffset(pc),
        true, &sprinter);\n      if (!len) {\n        return false;\n      }\n\n      pc
        += len;\n    }\n\n    JS::UniqueChars str = sprinter.release();\n    if (!str)
        {\n      return false;\n    }\n    fprintf(gOutFile->fp, \"%s\\n\", str.get());\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n\n#endif /* defined(DEBUG)
        || defined(JS_JITSPEW) */\n\n#ifdef JS_CACHEIR_SPEW\nstatic bool CacheIRHealthReport(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ js::jit::CacheIRHealth cih;\n  RootedScript script(cx);\n\n  // In the case
        that we are calling this function from the shell and\n  // the environment
        variable is not set, AutoSpewChannel automatically\n  // sets and unsets the
        proper channel for the duration of spewing\n  // a health report.\n  AutoSpewChannel
        channel(cx, SpewChannel::CacheIRHealthReport, script);\n  if (!argc) {\n    //
        Calling CacheIRHealthReport without any arguments will create health\n    //
        reports for all scripts in the zone.\n    if (jit::JitZone* jitZone = cx->zone()->jitZone())
        {\n      jitZone->forEachJitScript([&](jit::JitScript* jitScript) {\n        script
        = jitScript->owningScript();\n        if (!script->selfHosted()) {\n          cih.healthReportForScript(cx,
        script, js::jit::SpewContext::Shell);\n        }\n      });\n    }\n  } else
        {\n    RootedValue value(cx, args.get(0));\n\n    if (value.isObject() &&
        value.toObject().is<ShellModuleObjectWrapper>()) {\n      script =\n          value.toObject().as<ShellModuleObjectWrapper>().get()->maybeScript();\n
        \   } else {\n      script = TestingFunctionArgumentToScript(cx, args.get(0));\n
        \   }\n\n    if (!script) {\n      return false;\n    }\n\n    cih.healthReportForScript(cx,
        script, js::jit::SpewContext::Shell);\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n#endif /* JS_CACHEIR_SPEW */\n\n/* Pretend we can always
        preserve wrappers for dummy DOM objects. */\nstatic bool DummyPreserveWrapperCallback(JSContext*
        cx, HandleObject obj) {\n  return true;\n}\n\nstatic bool DummyHasReleasedWrapperCallback(HandleObject
        obj) { return true; }\n\n#ifdef FUZZING_JS_FUZZILLI\nstatic bool fuzzilli_hash(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ args.rval().setUndefined();\n\n  if (argc != 1) {\n    return true;\n  }\n
        \ uint32_t hash;\n  JS::Handle<JS::Value> v = args.get(0);\n  if (v.isInt32())
        {\n    int32_t i = v.toInt32();\n    hash = FuzzilliHashDouble((double)i);\n
        \ } else if (v.isDouble()) {\n    double d = v.toDouble();\n    d = JS::CanonicalizeNaN(d);\n
        \   hash = FuzzilliHashDouble(d);\n  } else if (v.isNull()) {\n    hash =
        FuzzilliHashDouble(1.0);\n  } else if (v.isUndefined()) {\n    hash = FuzzilliHashDouble(2.0);\n
        \ } else if (v.isBoolean()) {\n    hash = FuzzilliHashDouble(3.0 + v.toBoolean());\n
        \ } else if (v.isBigInt()) {\n    JS::BigInt* bigInt = v.toBigInt();\n    hash
        = FuzzilliHashBigInt(bigInt);\n  } else if (v.isObject()) {\n    JSObject&
        obj = v.toObject();\n    FuzzilliHashObject(cx, &obj);\n    return true;\n
        \ } else {\n    hash = 0;\n  }\n\n  cx->executionHashInputs += 1;\n  cx->executionHash
        = mozilla::RotateLeft(cx->executionHash + hash, 1);\n  return true;\n}\n\n//
        We have to assume that the fuzzer will be able to call this function e.g.
        by\n// enumerating the properties of the global object and eval'ing them.
        As such\n// this function is implemented in a way that requires passing some
        magic value\n// as first argument (with the idea being that the fuzzer won't
        be able to\n// generate this value) which then also acts as a selector for
        the operation\n// to perform.\nstatic bool Fuzzilli(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  RootedString
        arg(cx, JS::ToString(cx, args.get(0)));\n  if (!arg) {\n    return false;\n
        \ }\n  Rooted<JSLinearString*> operation(cx, StringToLinearString(cx, arg));\n
        \ if (!operation) {\n    return false;\n  }\n\n  if (StringEqualsAscii(operation,
        \"FUZZILLI_CRASH\")) {\n    int type;\n    if (!ToInt32(cx, args.get(1), &type))
        {\n      return false;\n    }\n\n    // With this, we can test the various
        ways the JS shell can crash and make\n    // sure that Fuzzilli is able to
        detect all of these failures properly.\n    switch (type) {\n      case 0:\n
        \       *((int*)0x41414141) = 0x1337;\n        break;\n      case 1:\n        MOZ_RELEASE_ASSERT(false);\n
        \       break;\n      case 2:\n        MOZ_ASSERT(false);\n        break;\n
        \     case 3:\n        __asm__(\"int3\");\n        break;\n      default:\n
        \       exit(1);\n    }\n  } else if (StringEqualsAscii(operation, \"FUZZILLI_PRINT\"))
        {\n    static FILE* fzliout = fdopen(REPRL_DWFD, \"w\");\n    if (!fzliout)
        {\n      fprintf(\n          stderr,\n          \"Fuzzer output channel not
        available, printing to stdout instead\\n\");\n      fzliout = stdout;\n    }\n\n
        \   RootedString str(cx, JS::ToString(cx, args.get(1)));\n    if (!str) {\n
        \     return false;\n    }\n    UniqueChars bytes = JS_EncodeStringToUTF8(cx,
        str);\n    if (!bytes) {\n      return false;\n    }\n    fprintf(fzliout,
        \"%s\\n\", bytes.get());\n    fflush(fzliout);\n  } else if (StringEqualsAscii(operation,
        \"FUZZILLI_RANDOM\")) {\n    // This is an entropy source which can be called
        during fuzzing.\n    // Its currently used to tests whether Fuzzilli detects
        non-deterministic\n    // behavior.\n    args.rval().setInt32(static_cast<uint32_t>(mozilla::RandomUint64OrDie()));\n
        \   return true;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool FuzzilliReprlGetAndRun(JSContext* cx) {\n  size_t scriptSize = 0;\n\n
        \ unsigned action;\n  MOZ_RELEASE_ASSERT(read(REPRL_CRFD, &action, 4) == 4);\n
        \ if (action == 'cexe') {\n    MOZ_RELEASE_ASSERT(read(REPRL_CRFD, &scriptSize,
        8) == 8);\n  } else {\n    fprintf(stderr, \"Unknown action: %u\\n\", action);\n
        \   _exit(-1);\n  }\n\n  CompileOptions options(cx);\n  options.setIntroductionType(\"reprl\")\n
        \     .setFileAndLine(\"reprl\", 1)\n      .setIsRunOnce(true)\n      .setNoScriptRval(true)\n
        \     .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n  char*
        scriptSrc = static_cast<char*>(js_malloc(scriptSize));\n\n  char* ptr = scriptSrc;\n
        \ size_t remaining = scriptSize;\n  while (remaining > 0) {\n    ssize_t rv
        = read(REPRL_DRFD, ptr, remaining);\n    if (rv <= 0) {\n      fprintf(stderr,
        \"Failed to load script\\n\");\n      _exit(-1);\n    }\n    remaining -=
        rv;\n    ptr += rv;\n  }\n\n  JS::SourceText<Utf8Unit> srcBuf;\n  if (!srcBuf.init(cx,
        scriptSrc, scriptSize,\n                   JS::SourceOwnership::TakeOwnership))
        {\n    return false;\n  }\n\n  RootedScript script(cx, JS::Compile(cx, options,
        srcBuf));\n  if (!script) {\n    return false;\n  }\n\n  if (!JS_ExecuteScript(cx,
        script)) {\n    return false;\n  }\n\n  return true;\n}\n\n#endif /* FUZZING_JS_FUZZILLI
        */\n\nstatic bool FuzzilliUseReprlMode(OptionParser* op) {\n#ifdef FUZZING_JS_FUZZILLI\n
        \ // Check if we should use REPRL mode\n  bool reprl_mode = op->getBoolOption(\"reprl\");\n
        \ if (reprl_mode) {\n    // Check in with parent\n    char helo[] = \"HELO\";\n
        \   if (write(REPRL_CWFD, helo, 4) != 4 || read(REPRL_CRFD, helo, 4) != 4)
        {\n      reprl_mode = false;\n    }\n\n    if (memcmp(helo, \"HELO\", 4) !=
        0) {\n      fprintf(stderr, \"Invalid response from parent\\n\");\n      _exit(-1);\n
        \   }\n  }\n  return reprl_mode;\n#else\n  return false;\n#endif /* FUZZING_JS_FUZZILLI
        */\n}\n\nstatic bool Crash(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (args.length() == 0) {\n    MOZ_CRASH(\"forced
        crash\");\n  }\n  RootedString message(cx, JS::ToString(cx, args[0]));\n  if
        (!message) {\n    return false;\n  }\n  UniqueChars utf8chars = JS_EncodeStringToUTF8(cx,
        message);\n  if (!utf8chars) {\n    return false;\n  }\n  if (args.get(1).isObject())
        {\n    RootedValue v(cx);\n    RootedObject opts(cx, &args[1].toObject());\n
        \   if (!JS_GetProperty(cx, opts, \"suppress_minidump\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean() && v.toBoolean()) {\n      js::NoteIntentionalCrash();\n
        \   }\n  }\n#ifndef DEBUG\n  MOZ_ReportCrash(utf8chars.get(), __FILE__, __LINE__);\n#endif\n
        \ MOZ_CRASH_UNSAFE(utf8chars.get());\n}\n\nstatic bool GetSLX(JSContext* cx,
        unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ RootedScript script(cx);\n\n  script = TestingFunctionArgumentToScript(cx,
        args.get(0));\n  if (!script) {\n    return false;\n  }\n  args.rval().setInt32(GetScriptLineExtent(script));\n
        \ return true;\n}\n\nstatic bool ThrowError(JSContext* cx, unsigned argc,
        Value* vp) {\n  JS_ReportErrorASCII(cx, \"This is an error\");\n  return false;\n}\n\nstatic
        bool CopyErrorReportToObject(JSContext* cx, JSErrorReport* report,\n                                    HandleObject
        obj) {\n  RootedString nameStr(cx);\n  if (report->exnType == JSEXN_WARN)
        {\n    nameStr = JS_NewStringCopyZ(cx, \"Warning\");\n    if (!nameStr) {\n
        \     return false;\n    }\n  } else {\n    nameStr = GetErrorTypeName(cx,
        report->exnType);\n    // GetErrorTypeName doesn't set an exception, but\n
        \   // can fail for InternalError or non-error objects.\n    if (!nameStr)
        {\n      nameStr = cx->runtime()->emptyString;\n    }\n  }\n  RootedValue
        nameVal(cx, StringValue(nameStr));\n  if (!DefineDataProperty(cx, obj, cx->names().name,
        nameVal)) {\n    return false;\n  }\n\n  RootedString messageStr(cx, report->newMessageString(cx));\n
        \ if (!messageStr) {\n    return false;\n  }\n  RootedValue messageVal(cx,
        StringValue(messageStr));\n  if (!DefineDataProperty(cx, obj, cx->names().message,
        messageVal)) {\n    return false;\n  }\n\n  RootedValue linenoVal(cx, Int32Value(report->lineno));\n
        \ if (!DefineDataProperty(cx, obj, cx->names().lineNumber, linenoVal)) {\n
        \   return false;\n  }\n\n  RootedValue columnVal(cx, Int32Value(report->column.oneOriginValue()));\n
        \ if (!DefineDataProperty(cx, obj, cx->names().columnNumber, columnVal)) {\n
        \   return false;\n  }\n\n  RootedObject notesArray(cx, CreateErrorNotesArray(cx,
        report));\n  if (!notesArray) {\n    return false;\n  }\n\n  RootedValue notesArrayVal(cx,
        ObjectValue(*notesArray));\n  return DefineDataProperty(cx, obj, cx->names().notes,
        notesArrayVal);\n}\n\nstatic bool CreateErrorReport(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  // We
        don't have a stack here, so just initialize with null.\n  JS::ExceptionStack
        exnStack(cx, args.get(0), nullptr);\n  JS::ErrorReportBuilder report(cx);\n
        \ if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects))
        {\n    return false;\n  }\n\n  MOZ_ASSERT(!report.report()->isWarning());\n\n
        \ RootedObject obj(cx, JS_NewPlainObject(cx));\n  if (!obj) {\n    return
        false;\n  }\n\n  RootedString toString(cx, NewStringCopyUTF8Z(cx, report.toStringResult()));\n
        \ if (!toString) {\n    return false;\n  }\n\n  if (!JS_DefineProperty(cx,
        obj, \"toStringResult\", toString,\n                         JSPROP_ENUMERATE))
        {\n    return false;\n  }\n\n  if (!CopyErrorReportToObject(cx, report.report(),
        obj)) {\n    return false;\n  }\n\n  args.rval().setObject(*obj);\n  return
        true;\n}\n\n#define LAZY_STANDARD_CLASSES\n\n/* A class for easily testing
        the inner/outer object callbacks. */\ntypedef struct ComplexObject {\n  bool
        isInner;\n  bool frozen;\n  JSObject* inner;\n  JSObject* outer;\n} ComplexObject;\n\nstatic
        bool sandbox_enumerate(JSContext* cx, JS::HandleObject obj,\n                              JS::MutableHandleIdVector
        properties,\n                              bool enumerableOnly) {\n  RootedValue
        v(cx);\n\n  if (!JS_GetProperty(cx, obj, \"lazy\", &v)) {\n    return false;\n
        \ }\n\n  if (!ToBoolean(v)) {\n    return true;\n  }\n\n  return JS_NewEnumerateStandardClasses(cx,
        obj, properties, enumerableOnly);\n}\n\nstatic bool sandbox_resolve(JSContext*
        cx, HandleObject obj, HandleId id,\n                            bool* resolvedp)
        {\n  RootedValue v(cx);\n  if (!JS_GetProperty(cx, obj, \"lazy\", &v)) {\n
        \   return false;\n  }\n\n  if (ToBoolean(v)) {\n    return JS_ResolveStandardClass(cx,
        obj, id, resolvedp);\n  }\n  return true;\n}\n\nstatic const JSClassOps sandbox_classOps
        = {\n    nullptr,                   // addProperty\n    nullptr,                   //
        delProperty\n    nullptr,                   // enumerate\n    sandbox_enumerate,
        \        // newEnumerate\n    sandbox_resolve,           // resolve\n    nullptr,
        \                  // mayResolve\n    nullptr,                   // finalize\n
        \   nullptr,                   // call\n    nullptr,                   //
        construct\n    JS_GlobalObjectTraceHook,  // trace\n};\n\nstatic const JSClass
        sandbox_class = {\"sandbox\", JSCLASS_GLOBAL_FLAGS,\n                                      &sandbox_classOps};\n\nstatic
        void SetStandardRealmOptions(JS::RealmOptions& options) {\n  options.creationOptions()\n
        \     .setSharedMemoryAndAtomicsEnabled(enableSharedMemory)\n      .setCoopAndCoepEnabled(false)\n
        \     .setToSourceEnabled(enableToSource);\n}\n\n[[nodiscard]] static bool
        CheckRealmOptions(JSContext* cx,\n                                            JS::RealmOptions&
        options,\n                                            JSPrincipals* principals)
        {\n  JS::RealmCreationOptions& creationOptions = options.creationOptions();\n
        \ if (creationOptions.compartmentSpecifier() !=\n      JS::CompartmentSpecifier::ExistingCompartment)
        {\n    return true;\n  }\n\n  JS::Compartment* comp = creationOptions.compartment();\n\n
        \ // All realms in a compartment must be either system or non-system.\n  bool
        isSystem =\n      principals && principals == cx->runtime()->trustedPrincipals();\n
        \ if (isSystem != IsSystemCompartment(comp)) {\n    JS_ReportErrorASCII(cx,\n
        \                       \"Cannot create system and non-system realms in the
        \"\n                        \"same compartment\");\n    return false;\n  }\n\n
        \ // Debugger visibility is per-compartment, not per-realm, so make sure the\n
        \ // requested visibility matches the existing compartment's.\n  if (creationOptions.invisibleToDebugger()
        != comp->invisibleToDebugger()) {\n    JS_ReportErrorASCII(cx,\n                        \"All
        the realms in a compartment must have \"\n                        \"the same
        debugger visibility\");\n    return false;\n  }\n\n  return true;\n}\n\nstatic
        JSObject* NewSandbox(JSContext* cx, bool lazy) {\n  JS::RealmOptions options;\n
        \ SetStandardRealmOptions(options);\n\n  if (defaultToSameCompartment) {\n
        \   options.creationOptions().setExistingCompartment(cx->global());\n  } else
        {\n    options.creationOptions().setNewCompartmentAndZone();\n  }\n\n  JSPrincipals*
        principals = nullptr;\n  if (!CheckRealmOptions(cx, options, principals))
        {\n    return nullptr;\n  }\n\n  RootedObject obj(cx,\n                   JS_NewGlobalObject(cx,
        &sandbox_class, principals,\n                                      JS::DontFireOnNewGlobalHook,
        options));\n  if (!obj) {\n    return nullptr;\n  }\n\n  {\n    JSAutoRealm
        ar(cx, obj);\n    if (!lazy && !JS::InitRealmStandardClasses(cx)) {\n      return
        nullptr;\n    }\n\n    RootedValue value(cx, BooleanValue(lazy));\n    if
        (!JS_DefineProperty(cx, obj, \"lazy\", value,\n                           JSPROP_PERMANENT
        | JSPROP_READONLY)) {\n      return nullptr;\n    }\n\n    JS_FireOnNewGlobalObject(cx,
        obj);\n  }\n\n  if (!cx->compartment()->wrap(cx, &obj)) {\n    return nullptr;\n
        \ }\n  return obj;\n}\n\nstatic bool EvalInContext(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"evalcx\", 1)) {\n    return false;\n  }\n\n  RootedString str(cx, ToString(cx,
        args[0]));\n  if (!str) {\n    return false;\n  }\n\n  RootedObject sobj(cx);\n
        \ if (args.hasDefined(1)) {\n    sobj = ToObject(cx, args[1]);\n    if (!sobj)
        {\n      return false;\n    }\n  }\n\n  AutoStableStringChars strChars(cx);\n
        \ if (!strChars.initTwoByte(cx, str)) {\n    return false;\n  }\n\n  mozilla::Range<const
        char16_t> chars = strChars.twoByteRange();\n  size_t srclen = chars.length();\n
        \ const char16_t* src = chars.begin().get();\n\n  bool lazy = false;\n  if
        (srclen == 4) {\n    if (src[0] == 'l' && src[1] == 'a' && src[2] == 'z' &&
        src[3] == 'y') {\n      lazy = true;\n      srclen = 0;\n    }\n  }\n\n  if
        (!sobj) {\n    sobj = NewSandbox(cx, lazy);\n    if (!sobj) {\n      return
        false;\n    }\n  }\n\n  if (srclen == 0) {\n    args.rval().setObject(*sobj);\n
        \   return true;\n  }\n\n  JS::AutoFilename filename;\n  uint32_t lineno;\n\n
        \ DescribeScriptedCaller(cx, &filename, &lineno);\n  {\n    sobj = UncheckedUnwrap(sobj,
        true);\n\n    JSAutoRealm ar(cx, sobj);\n\n    sobj = ToWindowIfWindowProxy(sobj);\n\n
        \   if (!JS_IsGlobalObject(sobj)) {\n      JS_ReportErrorASCII(cx, \"Invalid
        scope argument to evalcx\");\n      return false;\n    }\n\n    JS::CompileOptions
        opts(cx);\n    opts.setFileAndLine(filename.get(), lineno)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   JS::SourceText<char16_t> srcBuf;\n    if (!srcBuf.init(cx, src, srclen,
        JS::SourceOwnership::Borrowed) ||\n        !JS::Evaluate(cx, opts, srcBuf,
        args.rval())) {\n      return false;\n    }\n  }\n\n  if (!cx->compartment()->wrap(cx,
        args.rval())) {\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool
        EnsureGeckoProfilingStackInstalled(JSContext* cx,\n                                               ShellContext*
        sc) {\n  if (cx->geckoProfiler().infraInstalled()) {\n    MOZ_ASSERT(sc->geckoProfilingStack);\n
        \   return true;\n  }\n\n  MOZ_ASSERT(!sc->geckoProfilingStack);\n  sc->geckoProfilingStack
        = MakeUnique<ProfilingStack>();\n  if (!sc->geckoProfilingStack) {\n    JS_ReportOutOfMemory(cx);\n
        \   return false;\n  }\n\n  SetContextProfilingStack(cx, sc->geckoProfilingStack.get());\n
        \ return true;\n}\n\nstruct WorkerInput {\n  JSRuntime* parentRuntime;\n  UniqueTwoByteChars
        chars;\n  size_t length;\n\n  WorkerInput(JSRuntime* parentRuntime, UniqueTwoByteChars
        chars, size_t length)\n      : parentRuntime(parentRuntime), chars(std::move(chars)),
        length(length) {}\n};\n\nstatic void DestroyShellCompartmentPrivate(JS::GCContext*
        gcx,\n                                           JS::Compartment* compartment)
        {\n  auto priv = static_cast<ShellCompartmentPrivate*>(\n      JS_GetCompartmentPrivate(compartment));\n
        \ js_delete(priv);\n}\n\nstatic void SetWorkerContextOptions(JSContext* cx);\nstatic
        bool ShellBuildId(JS::BuildIdCharVector* buildId);\n\nstatic constexpr size_t
        gWorkerStackSize = 2 * 128 * sizeof(size_t) * 1024;\n\nstatic void WorkerMain(UniquePtr<WorkerInput>
        input) {\n  MOZ_ASSERT(input->parentRuntime);\n\n  JSContext* cx = JS_NewContext(8L
        * 1024L * 1024L, input->parentRuntime);\n  if (!cx) {\n    return;\n  }\n
        \ auto destroyContext = MakeScopeExit([cx] { JS_DestroyContext(cx); });\n\n
        \ UniquePtr<ShellContext> sc =\n      MakeUnique<ShellContext>(cx, ShellContext::Worker);\n
        \ if (!sc || !sc->registerWithCx(cx)) {\n    return;\n  }\n\n  if (!JS::InitSelfHostedCode(cx))
        {\n    return;\n  }\n\n  EnvironmentPreparer environmentPreparer(cx);\n\n
        \ do {\n    JS::RealmOptions realmOptions;\n    SetStandardRealmOptions(realmOptions);\n\n
        \   RootedObject global(cx, NewGlobalObject(cx, realmOptions, nullptr,\n                                            ShellGlobalKind::WindowProxy,\n
        \                                           /* immutablePrototype = */ true));\n
        \   if (!global) {\n      break;\n    }\n\n    JSAutoRealm ar(cx, global);\n\n
        \   JS::ConstUTF8CharsZ path(processWideModuleLoadPath.get(),\n                             strlen(processWideModuleLoadPath.get()));\n
        \   RootedString moduleLoadPath(cx, JS_NewStringCopyUTF8Z(cx, path));\n    if
        (!moduleLoadPath) {\n      return;\n    }\n    sc->moduleLoader = js::MakeUnique<ModuleLoader>();\n
        \   if (!sc->moduleLoader || !sc->moduleLoader->init(cx, moduleLoadPath))
        {\n      return;\n    }\n\n    JS::CompileOptions options(cx);\n    options.setFileAndLine(\"<string>\",
        1)\n        .setIsRunOnce(true)\n        .setEagerDelazificationStrategy(defaultDelazificationMode);\n\n
        \   AutoReportException are(cx);\n    JS::SourceText<char16_t> srcBuf;\n    if
        (!srcBuf.init(cx, input->chars.get(), input->length,\n                     JS::SourceOwnership::Borrowed))
        {\n      break;\n    }\n\n    RootedScript script(cx, JS::Compile(cx, options,
        srcBuf));\n    if (!script) {\n      break;\n    }\n    RootedValue result(cx);\n
        \   JS_ExecuteScript(cx, script, &result);\n  } while (0);\n\n  KillWatchdog(cx);\n}\n\n//
        Workers can spawn other workers, so we need a lock to access workerThreads.\nstatic
        Mutex* workerThreadsLock = nullptr;\nstatic Vector<UniquePtr<js::Thread>,
        0, SystemAllocPolicy> workerThreads;\n\nclass MOZ_RAII AutoLockWorkerThreads
        : public LockGuard<Mutex> {\n  using Base = LockGuard<Mutex>;\n\n public:\n
        \ AutoLockWorkerThreads() : Base(*workerThreadsLock) {\n    MOZ_ASSERT(workerThreadsLock);\n
        \ }\n};\n\nstatic bool EvalInWorker(JSContext* cx, unsigned argc, Value* vp)
        {\n  if (!CanUseExtraThreads()) {\n    JS_ReportErrorASCII(cx, \"Can't create
        threads with --no-threads\");\n    return false;\n  }\n\n  CallArgs args =
        CallArgsFromVp(argc, vp);\n  if (!args.get(0).isString()) {\n    JS_ReportErrorASCII(cx,
        \"Invalid arguments\");\n    return false;\n  }\n\n#if defined(DEBUG) || defined(JS_OOM_BREAKPOINT)\n
        \ if (cx->runningOOMTest) {\n    JS_ReportErrorASCII(\n        cx, \"Can't
        create threads while running simulated OOM test\");\n    return false;\n  }\n#endif\n\n
        \ if (!args[0].toString()->ensureLinear(cx)) {\n    return false;\n  }\n\n
        \ if (!workerThreadsLock) {\n    workerThreadsLock = js_new<Mutex>(mutexid::ShellWorkerThreads);\n
        \   if (!workerThreadsLock) {\n      ReportOutOfMemory(cx);\n      return
        false;\n    }\n  }\n\n  JSLinearString* str = &args[0].toString()->asLinear();\n\n
        \ UniqueTwoByteChars chars(js_pod_malloc<char16_t>(str->length()));\n  if
        (!chars) {\n    ReportOutOfMemory(cx);\n    return false;\n  }\n\n  CopyChars(chars.get(),
        *str);\n\n  auto input = js::MakeUnique<WorkerInput>(JS_GetParentRuntime(cx),\n
        \                                          std::move(chars), str->length());\n
        \ if (!input) {\n    ReportOutOfMemory(cx);\n    return false;\n  }\n\n  UniquePtr<Thread>
        thread;\n  {\n    AutoEnterOOMUnsafeRegion oomUnsafe;\n    thread = js::MakeUnique<Thread>(\n
        \       Thread::Options().setStackSize(gWorkerStackSize + 512 * 1024));\n
        \   if (!thread || !thread->init(WorkerMain, std::move(input))) {\n      oomUnsafe.crash(\"EvalInWorker\");\n
        \   }\n  }\n\n  AutoLockWorkerThreads alwt;\n  if (!workerThreads.append(std::move(thread)))
        {\n    ReportOutOfMemory(cx);\n    thread->join();\n    return false;\n  }\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool ShapeOf(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  if (!args.get(0).isObject()) {\n    JS_ReportErrorASCII(cx, \"shapeOf:
        object expected\");\n    return false;\n  }\n  JSObject* obj = &args[0].toObject();\n
        \ args.rval().set(JS_NumberValue(double(uintptr_t(obj->shape()) >> 3)));\n
        \ return true;\n}\n\nstatic bool Sleep_fn(JSContext* cx, unsigned argc, Value*
        vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  TimeDuration duration = TimeDuration::FromSeconds(0.0);\n  if (args.length()
        > 0) {\n    double t_secs;\n    if (!ToNumber(cx, args[0], &t_secs)) {\n      return
        false;\n    }\n    if (std::isnan(t_secs)) {\n      JS_ReportErrorASCII(cx,
        \"sleep interval is not a number\");\n      return false;\n    }\n\n    duration
        = TimeDuration::FromSeconds(std::max(0.0, t_secs));\n    const TimeDuration
        MAX_TIMEOUT_INTERVAL =\n        TimeDuration::FromSeconds(MAX_TIMEOUT_SECONDS);\n
        \   if (duration > MAX_TIMEOUT_INTERVAL) {\n      JS_ReportErrorASCII(cx,
        \"Excessive sleep interval\");\n      return false;\n    }\n  }\n  {\n    LockGuard<Mutex>
        guard(sc->watchdogLock);\n    TimeStamp toWakeup = TimeStamp::Now() + duration;\n
        \   for (;;) {\n      sc->sleepWakeup.wait_for(guard, duration);\n      if
        (sc->serviceInterrupt) {\n        break;\n      }\n      auto now = TimeStamp::Now();\n
        \     if (now >= toWakeup) {\n        break;\n      }\n      duration = toWakeup
        - now;\n    }\n  }\n  args.rval().setUndefined();\n  return !sc->serviceInterrupt;\n}\n\nstatic
        void KillWatchdog(JSContext* cx) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ Maybe<Thread> thread;\n\n  {\n    LockGuard<Mutex> guard(sc->watchdogLock);\n
        \   std::swap(sc->watchdogThread, thread);\n    if (thread) {\n      // The
        watchdog thread becoming Nothing is its signal to exit.\n      sc->watchdogWakeup.notify_one();\n
        \   }\n  }\n  if (thread) {\n    thread->join();\n  }\n\n  MOZ_ASSERT(!sc->watchdogThread);\n}\n\nstatic
        void WatchdogMain(JSContext* cx) {\n  ThisThread::SetName(\"JS Watchdog\");\n\n
        \ ShellContext* sc = GetShellContext(cx);\n\n  {\n    LockGuard<Mutex> guard(sc->watchdogLock);\n
        \   while (sc->watchdogThread) {\n      auto now = TimeStamp::Now();\n      if
        (sc->watchdogTimeout && now >= sc->watchdogTimeout.value()) {\n        /*\n
        \        * The timeout has just expired. Request an interrupt callback\n         *
        outside the lock.\n         */\n        sc->watchdogTimeout = Nothing();\n
        \       {\n          UnlockGuard unlock(guard);\n          CancelExecution(cx);\n
        \       }\n\n        /* Wake up any threads doing sleep. */\n        sc->sleepWakeup.notify_all();\n
        \     } else {\n        if (sc->watchdogTimeout) {\n          /*\n           *
        Time hasn't expired yet. Simulate an interrupt callback\n           * which
        doesn't abort execution.\n           */\n          JS_RequestInterruptCallback(cx);\n
        \       }\n\n        TimeDuration sleepDuration = sc->watchdogTimeout\n                                         ?
        TimeDuration::FromSeconds(0.1)\n                                         :
        TimeDuration::Forever();\n        sc->watchdogWakeup.wait_for(guard, sleepDuration);\n
        \     }\n    }\n  }\n}\n\nstatic bool ScheduleWatchdog(JSContext* cx, double
        t) {\n  ShellContext* sc = GetShellContext(cx);\n\n  if (t <= 0) {\n    LockGuard<Mutex>
        guard(sc->watchdogLock);\n    sc->watchdogTimeout = Nothing();\n    return
        true;\n  }\n\n#ifdef __wasi__\n  return false;\n#endif\n\n  auto interval
        = TimeDuration::FromSeconds(t);\n  auto timeout = TimeStamp::Now() + interval;\n
        \ LockGuard<Mutex> guard(sc->watchdogLock);\n  if (!sc->watchdogThread) {\n
        \   MOZ_ASSERT(!sc->watchdogTimeout);\n    sc->watchdogThread.emplace();\n
        \   AutoEnterOOMUnsafeRegion oomUnsafe;\n    if (!sc->watchdogThread->init(WatchdogMain,
        cx)) {\n      oomUnsafe.crash(\"watchdogThread.init\");\n    }\n  } else if
        (!sc->watchdogTimeout || timeout < sc->watchdogTimeout.value()) {\n    sc->watchdogWakeup.notify_one();\n
        \ }\n  sc->watchdogTimeout = Some(timeout);\n  return true;\n}\n\nstatic void
        KillWorkerThreads(JSContext* cx) {\n  MOZ_ASSERT_IF(!CanUseExtraThreads(),
        workerThreads.empty());\n\n  if (!workerThreadsLock) {\n    MOZ_ASSERT(workerThreads.empty());\n
        \   return;\n  }\n\n  while (true) {\n    // We need to leave the AutoLockWorkerThreads
        scope before we call\n    // js::Thread::join, to avoid deadlocks when AutoLockWorkerThreads
        is\n    // used by the worker thread.\n    UniquePtr<Thread> thread;\n    {\n
        \     AutoLockWorkerThreads alwt;\n      if (workerThreads.empty()) {\n        break;\n
        \     }\n      thread = std::move(workerThreads.back());\n      workerThreads.popBack();\n
        \   }\n    thread->join();\n  }\n\n  workerThreads.clearAndFree();\n\n  js_delete(workerThreadsLock);\n
        \ workerThreadsLock = nullptr;\n}\n\nstatic void CancelExecution(JSContext*
        cx) {\n  ShellContext* sc = GetShellContext(cx);\n  sc->serviceInterrupt =
        true;\n  JS_RequestInterruptCallback(cx);\n}\n\nstatic bool SetTimeoutValue(JSContext*
        cx, double t) {\n  if (std::isnan(t)) {\n    JS_ReportErrorASCII(cx, \"timeout
        is not a number\");\n    return false;\n  }\n  const TimeDuration MAX_TIMEOUT_INTERVAL
        =\n      TimeDuration::FromSeconds(MAX_TIMEOUT_SECONDS);\n  if (TimeDuration::FromSeconds(t)
        > MAX_TIMEOUT_INTERVAL) {\n    JS_ReportErrorASCII(cx, \"Excessive timeout
        value\");\n    return false;\n  }\n  GetShellContext(cx)->timeoutInterval
        = t;\n  if (!ScheduleWatchdog(cx, t)) {\n    JS_ReportErrorASCII(cx, \"Failed
        to create the watchdog\");\n    return false;\n  }\n  return true;\n}\n\nstatic
        bool Timeout(JSContext* cx, unsigned argc, Value* vp) {\n  ShellContext* sc
        = GetShellContext(cx);\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if
        (args.length() == 0) {\n    args.rval().setNumber(sc->timeoutInterval);\n
        \   return true;\n  }\n\n  if (args.length() > 2) {\n    JS_ReportErrorASCII(cx,
        \"Wrong number of arguments\");\n    return false;\n  }\n\n  double t;\n  if
        (!ToNumber(cx, args[0], &t)) {\n    return false;\n  }\n\n  if (args.length()
        > 1) {\n    RootedValue value(cx, args[1]);\n    if (!value.isObject() ||
        !value.toObject().is<JSFunction>()) {\n      JS_ReportErrorASCII(cx, \"Second
        argument must be a timeout function\");\n      return false;\n    }\n    sc->interruptFunc
        = value;\n    sc->haveInterruptFunc = true;\n  }\n\n  args.rval().setUndefined();\n
        \ return SetTimeoutValue(cx, t);\n}\n\nstatic bool InterruptIf(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 1) {\n    JS_ReportErrorASCII(cx, \"Wrong number of
        arguments\");\n    return false;\n  }\n\n  if (ToBoolean(args[0])) {\n    GetShellContext(cx)->serviceInterrupt
        = true;\n    JS_RequestInterruptCallback(cx);\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool InvokeInterruptCallbackWrapper(JSContext*
        cx, unsigned argc,\n                                           Value* vp)
        {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length() != 1)
        {\n    JS_ReportErrorASCII(cx, \"Wrong number of arguments\");\n    return
        false;\n  }\n\n  GetShellContext(cx)->serviceInterrupt = true;\n  JS_RequestInterruptCallback(cx);\n
        \ bool interruptRv = CheckForInterrupt(cx);\n\n  // The interrupt handler
        could have set a pending exception. Since we call\n  // back into JS, don't
        have it see the pending exception. If we have an\n  // uncatchable exception
        that's not propagating a debug mode forced\n  // return, return.\n  if (!interruptRv
        && !cx->isExceptionPending() &&\n      !cx->isPropagatingForcedReturn()) {\n
        \   return false;\n  }\n\n  JS::AutoSaveExceptionState savedExc(cx);\n\n  FixedInvokeArgs<1>
        iargs(cx);\n\n  iargs[0].setBoolean(interruptRv);\n\n  RootedValue rv(cx);\n
        \ if (!js::Call(cx, args[0], UndefinedHandleValue, iargs, &rv)) {\n    return
        false;\n  }\n\n  args.rval().setUndefined();\n  return interruptRv;\n}\n\nstatic
        bool SetInterruptCallback(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (args.length() != 1) {\n    JS_ReportErrorASCII(cx,
        \"Wrong number of arguments\");\n    return false;\n  }\n\n  RootedValue value(cx,
        args[0]);\n  if (!value.isObject() || !value.toObject().is<JSFunction>())
        {\n    JS_ReportErrorASCII(cx, \"Argument must be a function\");\n    return
        false;\n  }\n  GetShellContext(cx)->interruptFunc = value;\n  GetShellContext(cx)->haveInterruptFunc
        = true;\n\n  args.rval().setUndefined();\n  return true;\n}\n\n#ifdef DEBUG\n//
        var s0 = \"A\".repeat(10*1024);\n// interruptRegexp(/a(bc|bd)/, s0);\n// first
        arg is regexp\n// second arg is string\nstatic bool InterruptRegexp(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ ShellContext* sc = GetShellContext(cx);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() != 2) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments.\");\n    return false;\n  }\n  if (!(args[0].isObject()
        && args[0].toObject().is<RegExpObject>())) {\n    ReportUsageErrorASCII(cx,
        callee,\n                          \"First argument must be a regular expression.\");\n
        \   return false;\n  }\n  if (!args[1].isString()) {\n    ReportUsageErrorASCII(cx,
        callee, \"Second argument must be a String.\");\n    return false;\n  }\n
        \ // Set interrupt flags\n  sc->serviceInterrupt = true;\n  js::irregexp::IsolateSetShouldSimulateInterrupt(cx->isolate);\n\n
        \ RootedObject regexp(cx, &args[0].toObject());\n  RootedString string(cx,
        args[1].toString());\n  int32_t lastIndex = 0;\n\n  return js::RegExpMatcherRaw(cx,
        regexp, string, lastIndex, nullptr,\n                              args.rval());\n}\n#endif\n\nstatic
        bool CheckRegExpSyntax(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() != 1) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments.\");\n    return false;\n  }\n  if (!args[0].isString())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be a string.\");\n
        \   return false;\n  }\n\n  RootedString string(cx, args[0].toString());\n
        \ AutoStableStringChars stableChars(cx);\n  if (!stableChars.initTwoByte(cx,
        string)) {\n    return false;\n  }\n\n  const char16_t* chars = stableChars.twoByteRange().begin().get();\n
        \ size_t length = string->length();\n\n  Rooted<JS::Value> error(cx);\n  if
        (!JS::CheckRegExpSyntax(cx, chars, length, JS::RegExpFlag::NoFlags,\n                             &error))
        {\n    return false;\n  }\n\n  args.rval().set(error);\n  return true;\n}\n\nstatic
        bool SetJitCompilerOption(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() != 2) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments.\");\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be a String.\");\n
        \   return false;\n  }\n\n  if (!args[1].isInt32()) {\n    ReportUsageErrorASCII(cx,
        callee, \"Second argument must be an Int32.\");\n    return false;\n  }\n\n
        \ // Disallow setting JIT options when there are worker threads, to avoid\n
        \ // races.\n  if (workerThreadsLock) {\n    ReportUsageErrorASCII(\n        cx,
        callee, \"Can't set JIT options when there are worker threads.\");\n    return
        false;\n  }\n\n  JSLinearString* strArg = JS_EnsureLinearString(cx, args[0].toString());\n
        \ if (!strArg) {\n    return false;\n  }\n\n#define JIT_COMPILER_MATCH(key,
        string)                        \\\n  else if (JS_LinearStringEqualsLiteral(strArg,
        string)) opt = \\\n      JSJITCOMPILER_##key;\n\n  JSJitCompilerOption opt
        = JSJITCOMPILER_NOT_AN_OPTION;\n  if (false) {\n  }\n  JIT_COMPILER_OPTIONS(JIT_COMPILER_MATCH);\n#undef
        JIT_COMPILER_MATCH\n\n  if (opt == JSJITCOMPILER_NOT_AN_OPTION) {\n    ReportUsageErrorASCII(\n
        \       cx, callee,\n        \"First argument does not name a valid option
        (see jsapi.h).\");\n    return false;\n  }\n\n  int32_t number = args[1].toInt32();\n
        \ if (number < 0) {\n    number = -1;\n  }\n\n  // Disallow enabling or disabling
        the Baseline Interpreter at runtime.\n  // Enabling is a problem because the
        Baseline Interpreter code is only\n  // present if the interpreter was enabled
        when the JitRuntime was created.\n  // To support disabling we would have
        to discard all JitScripts. Furthermore,\n  // we really want JitOptions to
        be immutable after startup so it's better to\n  // use shell flags.\n  if
        (opt == JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE &&\n      bool(number) !=
        jit::IsBaselineInterpreterEnabled()) {\n    JS_ReportErrorASCII(cx,\n                        \"Enabling
        or disabling the Baseline Interpreter at \"\n                        \"runtime
        is not supported.\");\n    return false;\n  }\n\n  // Throw if disabling the
        JITs and there's JIT code on the stack, to avoid\n  // assertion failures.\n
        \ if ((opt == JSJITCOMPILER_BASELINE_ENABLE ||\n       opt == JSJITCOMPILER_ION_ENABLE)
        &&\n      number == 0) {\n    js::jit::JitActivationIterator iter(cx);\n    if
        (!iter.done()) {\n      JS_ReportErrorASCII(cx,\n                          \"Can't
        turn off JITs with JIT code on the stack.\");\n      return false;\n    }\n
        \ }\n\n  // Changing code memory protection settings at runtime is not supported.
        Don't\n  // throw if not changing the setting because some jit-tests depend
        on that.\n  if (opt == JSJITCOMPILER_WRITE_PROTECT_CODE) {\n    uint32_t writeProtect;\n
        \   MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(\n        cx, JSJITCOMPILER_WRITE_PROTECT_CODE,
        &writeProtect));\n    if (bool(number) != writeProtect) {\n      JS_ReportErrorASCII(cx,
        \"Can't change code write protection at runtime\");\n      return false;\n
        \   }\n    return true;\n  }\n\n  // Throw if trying to disable all the Wasm
        compilers.  The logic here is that\n  // if we're trying to disable a compiler
        that is currently enabled and that is\n  // the last compiler enabled then
        we must throw.\n  //\n  // Note that this check does not prevent an error
        from being thrown later.\n  // Actual compiler availability is dynamic and
        depends on other conditions,\n  // such as other options set and whether a
        debugger is present.\n  if ((opt == JSJITCOMPILER_WASM_JIT_BASELINE ||\n       opt
        == JSJITCOMPILER_WASM_JIT_OPTIMIZING) &&\n      number == 0) {\n    uint32_t
        baseline, optimizing;\n    MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(\n
        \       cx, JSJITCOMPILER_WASM_JIT_BASELINE, &baseline));\n    MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(\n
        \       cx, JSJITCOMPILER_WASM_JIT_OPTIMIZING, &optimizing));\n    if (baseline
        + optimizing == 1) {\n      if ((opt == JSJITCOMPILER_WASM_JIT_BASELINE &&
        baseline) ||\n          (opt == JSJITCOMPILER_WASM_JIT_OPTIMIZING && optimizing))
        {\n        JS_ReportErrorASCII(\n            cx,\n            \"Disabling
        all the Wasm compilers at runtime is not supported.\");\n        return false;\n
        \     }\n    }\n  }\n\n  // JIT compiler options are process-wide, so we have
        to stop off-thread\n  // compilations for all runtimes to avoid races.\n  WaitForAllHelperThreads();\n\n
        \ // Only release JIT code for the current runtime because there's no good\n
        \ // way to discard code for other runtimes.\n  ReleaseAllJITCode(cx->gcContext());\n\n
        \ JS_SetGlobalJitCompilerOption(cx, opt, uint32_t(number));\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool EnableLastWarning(JSContext* cx, unsigned
        argc, Value* vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  sc->lastWarningEnabled = true;\n  sc->lastWarning.setNull();\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool DisableLastWarning(JSContext*
        cx, unsigned argc, Value* vp) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  sc->lastWarningEnabled =
        false;\n  sc->lastWarning.setNull();\n\n  args.rval().setUndefined();\n  return
        true;\n}\n\nstatic bool GetLastWarning(JSContext* cx, unsigned argc, Value*
        vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (!sc->lastWarningEnabled) {\n    JS_ReportErrorASCII(cx, \"Call
        enableLastWarning first.\");\n    return false;\n  }\n\n  if (!JS_WrapValue(cx,
        &sc->lastWarning)) {\n    return false;\n  }\n\n  args.rval().set(sc->lastWarning);\n
        \ return true;\n}\n\nstatic bool ClearLastWarning(JSContext* cx, unsigned
        argc, Value* vp) {\n  ShellContext* sc = GetShellContext(cx);\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (!sc->lastWarningEnabled) {\n    JS_ReportErrorASCII(cx,
        \"Call enableLastWarning first.\");\n    return false;\n  }\n\n  sc->lastWarning.setNull();\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\n#if defined(DEBUG) ||
        defined(JS_JITSPEW)\nstatic bool StackDump(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!gOutFile->isOpen())
        {\n    JS_ReportErrorASCII(cx, \"output file is closed\");\n    return false;\n
        \ }\n\n  bool showArgs = ToBoolean(args.get(0));\n  bool showLocals = ToBoolean(args.get(1));\n
        \ bool showThisProps = ToBoolean(args.get(2));\n\n  JS::UniqueChars buf =\n
        \     JS::FormatStackDump(cx, showArgs, showLocals, showThisProps);\n  if
        (!buf) {\n    fputs(\"Failed to format JavaScript stack for dump\\n\", gOutFile->fp);\n
        \   JS_ClearPendingException(cx);\n  } else {\n    fputs(buf.get(), gOutFile->fp);\n
        \ }\n\n  args.rval().setUndefined();\n  return true;\n}\n#endif\n\nstatic
        bool StackPointerInfo(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  // Copy the truncated stack pointer
        to the result.  This value is not used\n  // as a pointer but as a way to
        measure frame-size from JS.\n  args.rval().setInt32(int32_t(reinterpret_cast<size_t>(&args)
        & 0xfffffff));\n  return true;\n}\n\nstatic bool Elapsed(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        == 0) {\n    double d = PRMJ_Now() - GetShellContext(cx)->startTime;\n    args.rval().setDouble(d);\n
        \   return true;\n  }\n  JS_ReportErrorASCII(cx, \"Wrong number of arguments\");\n
        \ return false;\n}\n\nstatic ShellCompartmentPrivate* EnsureShellCompartmentPrivate(JSContext*
        cx) {\n  Compartment* comp = cx->compartment();\n  auto priv =\n      static_cast<ShellCompartmentPrivate*>(JS_GetCompartmentPrivate(comp));\n
        \ if (!priv) {\n    priv = cx->new_<ShellCompartmentPrivate>();\n    JS_SetCompartmentPrivate(cx->compartment(),
        priv);\n  }\n  return priv;\n}\n\nstatic bool ParseModule(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"parseModule\", 1)) {\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"expected string to compile, got %s\", typeName);\n    return false;\n  }\n\n
        \ JSString* scriptContents = args[0].toString();\n\n  UniqueChars filename;\n
        \ CompileOptions options(cx);\n  if (args.length() > 1) {\n    if (!args[1].isString())
        {\n      const char* typeName = InformalValueTypeName(args[1]);\n      JS_ReportErrorASCII(cx,
        \"expected filename string, got %s\", typeName);\n      return false;\n    }\n\n
        \   RootedString str(cx, args[1].toString());\n    filename = JS_EncodeStringToUTF8(cx,
        str);\n    if (!filename) {\n      return false;\n    }\n\n    options.setFileAndLine(filename.get(),
        1);\n  } else {\n    options.setFileAndLine(\"<string>\", 1);\n  }\n  options.setModule();\n\n
        \ AutoStableStringChars linearChars(cx);\n  if (!linearChars.initTwoByte(cx,
        scriptContents)) {\n    return false;\n  }\n\n  JS::SourceText<char16_t> srcBuf;\n
        \ if (!srcBuf.initMaybeBorrowed(cx, linearChars)) {\n    return false;\n  }\n\n
        \ AutoReportFrontendContext fc(cx);\n  RootedObject module(cx, frontend::CompileModule(cx,
        &fc, options, srcBuf));\n  if (!module) {\n    return false;\n  }\n\n  Rooted<ShellModuleObjectWrapper*>
        wrapper(\n      cx, ShellModuleObjectWrapper::create(cx, module.as<ModuleObject>()));\n
        \ if (!wrapper) {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n
        \ return true;\n}\n\n// A JSObject that holds XDRBuffer.\nclass XDRBufferObject
        : public NativeObject {\n  static const size_t VECTOR_SLOT = 0;\n  static
        const unsigned RESERVED_SLOTS = 1;\n\n public:\n  static const JSClassOps
        classOps_;\n  static const JSClass class_;\n\n  [[nodiscard]] inline static
        XDRBufferObject* create(\n      JSContext* cx, JS::TranscodeBuffer&& buf);\n\n
        \ JS::TranscodeBuffer* data() const {\n    Value value = getReservedSlot(VECTOR_SLOT);\n
        \   auto buf = static_cast<JS::TranscodeBuffer*>(value.toPrivate());\n    MOZ_ASSERT(buf);\n
        \   return buf;\n  }\n\n  bool hasData() const {\n    // Data may not be present
        if we hit OOM in initialization.\n    return !getReservedSlot(VECTOR_SLOT).isUndefined();\n
        \ }\n\n  static void finalize(JS::GCContext* gcx, JSObject* obj);\n};\n\n/*static
        */ const JSClassOps XDRBufferObject::classOps_ = {\n    nullptr,                    //
        addProperty\n    nullptr,                    // delProperty\n    nullptr,
        \                   // enumerate\n    nullptr,                    // newEnumerate\n
        \   nullptr,                    // resolve\n    nullptr,                    //
        mayResolve\n    XDRBufferObject::finalize,  // finalize\n    nullptr,                    //
        call\n    nullptr,                    // construct\n    nullptr,                    //
        trace\n};\n\n/*static */ const JSClass XDRBufferObject::class_ = {\n    \"XDRBufferObject\",\n
        \   JSCLASS_HAS_RESERVED_SLOTS(XDRBufferObject::RESERVED_SLOTS) |\n        JSCLASS_BACKGROUND_FINALIZE,\n
        \   &XDRBufferObject::classOps_};\n\nXDRBufferObject* XDRBufferObject::create(JSContext*
        cx,\n                                         JS::TranscodeBuffer&& buf) {\n
        \ XDRBufferObject* bufObj =\n      NewObjectWithGivenProto<XDRBufferObject>(cx,
        nullptr);\n  if (!bufObj) {\n    return nullptr;\n  }\n\n  auto heapBuf =
        cx->make_unique<JS::TranscodeBuffer>(std::move(buf));\n  if (!heapBuf) {\n
        \   return nullptr;\n  }\n\n  size_t len = heapBuf->length();\n  InitReservedSlot(bufObj,
        VECTOR_SLOT, heapBuf.release(), len,\n                   MemoryUse::XDRBufferElements);\n\n
        \ return bufObj;\n}\n\nvoid XDRBufferObject::finalize(JS::GCContext* gcx,
        JSObject* obj) {\n  XDRBufferObject* buf = &obj->as<XDRBufferObject>();\n
        \ if (buf->hasData()) {\n    gcx->delete_(buf, buf->data(), buf->data()->length(),\n
        \                MemoryUse::XDRBufferElements);\n  }\n}\n\nstatic bool InstantiateModuleStencil(JSContext*
        cx, uint32_t argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (!args.requireAtLeast(cx, \"instantiateModuleStencil\", 1)) {\n    return
        false;\n  }\n\n  /* Prepare the input byte array. */\n  if (!args[0].isObject())
        {\n    JS_ReportErrorASCII(cx,\n                        \"instantiateModuleStencil:
        Stencil object expected\");\n    return false;\n  }\n  Rooted<js::StencilObject*>
        stencilObj(\n      cx, args[0].toObject().maybeUnwrapIf<js::StencilObject>());\n
        \ if (!stencilObj) {\n    JS_ReportErrorASCII(cx,\n                        \"instantiateModuleStencil:
        Stencil object expected\");\n    return false;\n  }\n\n  if (!stencilObj->stencil()->isModule())
        {\n    JS_ReportErrorASCII(cx,\n                        \"instantiateModuleStencil:
        Module stencil expected\");\n    return false;\n  }\n\n  CompileOptions options(cx);\n
        \ UniqueChars fileNameBytes;\n  if (args.length() == 2) {\n    if (!args[1].isObject())
        {\n      JS_ReportErrorASCII(\n          cx, \"instantiateModuleStencil: The
        2nd argument must be an object\");\n      return false;\n    }\n\n    RootedObject
        opts(cx, &args[1].toObject());\n    if (!js::ParseCompileOptions(cx, options,
        opts, &fileNameBytes)) {\n      return false;\n    }\n  }\n\n  /* Prepare
        the CompilationStencil for decoding. */\n  AutoReportFrontendContext fc(cx);\n
        \ Rooted<frontend::CompilationInput> input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (!input.get().initForModule(&fc)) {\n    return false;\n  }\n\n  if (!js::ValidateLazinessOfStencilAndGlobal(cx,
        *stencilObj->stencil())) {\n    return false;\n  }\n\n  /* Instantiate the
        stencil. */\n  Rooted<frontend::CompilationGCOutput> output(cx);\n  if (!frontend::CompilationStencil::instantiateStencils(\n
        \         cx, input.get(), *stencilObj->stencil(), output.get())) {\n    return
        false;\n  }\n\n  Rooted<ModuleObject*> modObject(cx, output.get().module);\n
        \ Rooted<ShellModuleObjectWrapper*> wrapper(\n      cx, ShellModuleObjectWrapper::create(cx,
        modObject));\n  if (!wrapper) {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n
        \ return true;\n}\n\nstatic bool InstantiateModuleStencilXDR(JSContext* cx,
        uint32_t argc,\n                                        Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx, \"instantiateModuleStencilXDR\",
        1)) {\n    return false;\n  }\n\n  /* Prepare the input byte array. */\n  if
        (!args[0].isObject()) {\n    JS_ReportErrorASCII(\n        cx, \"instantiateModuleStencilXDR:
        Stencil XDR object expected\");\n    return false;\n  }\n  Rooted<StencilXDRBufferObject*>
        xdrObj(\n      cx, args[0].toObject().maybeUnwrapIf<StencilXDRBufferObject>());\n
        \ if (!xdrObj) {\n    JS_ReportErrorASCII(\n        cx, \"instantiateModuleStencilXDR:
        Stencil XDR object expected\");\n    return false;\n  }\n  MOZ_ASSERT(xdrObj->hasBuffer());\n\n
        \ CompileOptions options(cx);\n  UniqueChars fileNameBytes;\n  if (args.length()
        == 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(\n          cx,\n
        \         \"instantiateModuleStencilXDR: The 2nd argument must be an object\");\n
        \     return false;\n    }\n\n    RootedObject opts(cx, &args[1].toObject());\n
        \   if (!js::ParseCompileOptions(cx, options, opts, &fileNameBytes)) {\n      return
        false;\n    }\n  }\n\n  /* Prepare the CompilationStencil for decoding. */\n
        \ AutoReportFrontendContext fc(cx);\n  Rooted<frontend::CompilationInput>
        input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (!input.get().initForModule(&fc)) {\n    return false;\n  }\n  frontend::CompilationStencil
        stencil(nullptr);\n\n  /* Deserialize the stencil from XDR. */\n  JS::TranscodeRange
        xdrRange(xdrObj->buffer(), xdrObj->bufferLength());\n  bool succeeded = false;\n
        \ if (!stencil.deserializeStencils(&fc, options, xdrRange, &succeeded)) {\n
        \   return false;\n  }\n  if (!succeeded) {\n    fc.clearAutoReport();\n    JS_ReportErrorASCII(cx,
        \"Decoding failure\");\n    return false;\n  }\n\n  if (!stencil.isModule())
        {\n    fc.clearAutoReport();\n    JS_ReportErrorASCII(cx,\n                        \"instantiateModuleStencilXDR:
        Module stencil expected\");\n    return false;\n  }\n\n  if (!js::ValidateLazinessOfStencilAndGlobal(cx,
        stencil)) {\n    return false;\n  }\n\n  /* Instantiate the stencil. */\n
        \ Rooted<frontend::CompilationGCOutput> output(cx);\n  if (!frontend::CompilationStencil::instantiateStencils(\n
        \         cx, input.get(), stencil, output.get())) {\n    return false;\n
        \ }\n\n  Rooted<ModuleObject*> modObject(cx, output.get().module);\n  Rooted<ShellModuleObjectWrapper*>
        wrapper(\n      cx, ShellModuleObjectWrapper::create(cx, modObject));\n  if
        (!wrapper) {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n
        \ return true;\n}\n\nstatic bool RegisterModule(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"registerModule\", 2)) {\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"Expected string, got %s\", typeName);\n    return false;\n  }\n\n  if (!args[1].isObject()
        ||\n      !args[1].toObject().is<ShellModuleObjectWrapper>()) {\n    const
        char* typeName = InformalValueTypeName(args[1]);\n    JS_ReportErrorASCII(cx,
        \"Expected module, got %s\", typeName);\n    return false;\n  }\n\n  ShellContext*
        sc = GetShellContext(cx);\n  Rooted<ModuleObject*> module(\n      cx, args[1].toObject().as<ShellModuleObjectWrapper>().get());\n
        \ if (module->realm() != cx->realm()) {\n    JS_ReportErrorASCII(cx, \"Module
        is in a different realm\");\n    return false;\n  }\n\n  Rooted<JSAtom*> specifier(cx,
        AtomizeString(cx, args[0].toString()));\n  if (!specifier) {\n    return false;\n
        \ }\n\n  Rooted<UniquePtr<ImportAttributeVector>> attributes(cx);\n  RootedObject
        moduleRequest(\n      cx, ModuleRequestObject::create(cx, specifier, &attributes));\n
        \ if (!moduleRequest) {\n    return false;\n  }\n\n  if (!sc->moduleLoader->registerTestModule(cx,
        moduleRequest, module)) {\n    return false;\n  }\n\n  Rooted<ShellModuleObjectWrapper*>
        wrapper(\n      cx, ShellModuleObjectWrapper::create(cx, module));\n  if (!wrapper)
        {\n    return false;\n  }\n  args.rval().setObject(*wrapper);\n  return true;\n}\n\nstatic
        bool ClearModules(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  ShellContext* sc = GetShellContext(cx);\n  sc->moduleLoader->clearModules(cx);\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool ModuleLink(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 1 || !args[0].isObject()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleLink\");\n
        \   return false;\n  }\n\n  RootedObject object(cx, UncheckedUnwrap(&args[0].toObject()));\n
        \ if (!object->is<ShellModuleObjectWrapper>()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleLink\");\n
        \   return false;\n  }\n\n  AutoRealm ar(cx, object);\n\n  Rooted<ModuleObject*>
        module(cx,\n                               object->as<ShellModuleObjectWrapper>().get());\n
        \ if (!JS::ModuleLink(cx, module)) {\n    return false;\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool ModuleEvaluate(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 1 || !args[0].isObject()) {\n    JS_ReportErrorNumberASCII(cx, GetErrorMessage,
        nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleEvaluate\");\n
        \   return false;\n  }\n\n  RootedObject object(cx, UncheckedUnwrap(&args[0].toObject()));\n
        \ if (!object->is<ShellModuleObjectWrapper>()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_INVALID_ARGS,\n                              \"moduleEvaluate\");\n
        \   return false;\n  }\n\n  {\n    AutoRealm ar(cx, object);\n\n    Rooted<ModuleObject*>
        module(cx,\n                                 object->as<ShellModuleObjectWrapper>().get());\n
        \   if (!JS::ModuleEvaluate(cx, module, args.rval())) {\n      return false;\n
        \   }\n  }\n\n  return JS_WrapValue(cx, args.rval());\n}\n\nstatic ModuleEnvironmentObject*
        GetModuleInitialEnvironment(\n    JSContext* cx, Handle<ModuleObject*> module)
        {\n  // Use the initial environment so that tests can check bindings exists\n
        \ // before they have been instantiated.\n  Rooted<ModuleEnvironmentObject*>
        env(cx, &module->initialEnvironment());\n  MOZ_ASSERT(env);\n  return env;\n}\n\nstatic
        bool GetModuleEnvironmentNames(JSContext* cx, unsigned argc, Value* vp) {\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length() != 1) {\n
        \   JS_ReportErrorASCII(cx, \"Wrong number of arguments\");\n    return false;\n
        \ }\n\n  if (!args[0].isObject() ||\n      !args[0].toObject().is<ShellModuleObjectWrapper>())
        {\n    JS_ReportErrorASCII(cx,\n                        \"First argument should
        be a ShellModuleObjectWrapper\");\n    return false;\n  }\n\n  Rooted<ModuleObject*>
        module(\n      cx, args[0].toObject().as<ShellModuleObjectWrapper>().get());\n
        \ if (module->hadEvaluationError()) {\n    JS_ReportErrorASCII(cx, \"Module
        environment unavailable\");\n    return false;\n  }\n\n  Rooted<ModuleEnvironmentObject*>
        env(cx,\n                                       GetModuleInitialEnvironment(cx,
        module));\n  Rooted<IdVector> ids(cx, IdVector(cx));\n  if (!JS_Enumerate(cx,
        env, &ids)) {\n    return false;\n  }\n\n  // The \"*namespace*\" binding
        is a detail of current implementation so hide\n  // it to give stable results
        in tests.\n  ids.eraseIfEqual(NameToId(cx->names().star_namespace_star_));\n\n
        \ uint32_t length = ids.length();\n  Rooted<ArrayObject*> array(cx, NewDenseFullyAllocatedArray(cx,
        length));\n  if (!array) {\n    return false;\n  }\n\n  array->setDenseInitializedLength(length);\n
        \ for (uint32_t i = 0; i < length; i++) {\n    array->initDenseElement(i,
        StringValue(ids[i].toString()));\n  }\n\n  args.rval().setObject(*array);\n
        \ return true;\n}\n\nstatic bool GetModuleEnvironmentValue(JSContext* cx,
        unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ if (args.length() != 2) {\n    JS_ReportErrorASCII(cx, \"Wrong number of
        arguments\");\n    return false;\n  }\n\n  if (!args[0].isObject() ||\n      !args[0].toObject().is<ShellModuleObjectWrapper>())
        {\n    JS_ReportErrorASCII(cx,\n                        \"First argument should
        be a ShellModuleObjectWrapper\");\n    return false;\n  }\n\n  if (!args[1].isString())
        {\n    JS_ReportErrorASCII(cx, \"Second argument should be a string\");\n
        \   return false;\n  }\n\n  Rooted<ModuleObject*> module(\n      cx, args[0].toObject().as<ShellModuleObjectWrapper>().get());\n
        \ if (module->hadEvaluationError()) {\n    JS_ReportErrorASCII(cx, \"Module
        environment unavailable\");\n    return false;\n  }\n\n  Rooted<ModuleEnvironmentObject*>
        env(cx,\n                                       GetModuleInitialEnvironment(cx,
        module));\n  RootedString name(cx, args[1].toString());\n  RootedId id(cx);\n
        \ if (!JS_StringToId(cx, name, &id)) {\n    return false;\n  }\n\n  if (!GetProperty(cx,
        env, env, id, args.rval())) {\n    return false;\n  }\n\n  if (args.rval().isMagic(JS_UNINITIALIZED_LEXICAL))
        {\n    ReportRuntimeLexicalError(cx, JSMSG_UNINITIALIZED_LEXICAL, id);\n    return
        false;\n  }\n\n  return true;\n}\n\nenum class DumpType {\n  ParseNode,\n
        \ Stencil,\n};\n\ntemplate <typename Unit>\nstatic bool DumpAST(JSContext*
        cx, const JS::ReadOnlyCompileOptions& options,\n                    const
        Unit* units, size_t length,\n                    js::frontend::CompilationState&
        compilationState,\n                    js::frontend::ParseGoal goal) {\n  using
        namespace js::frontend;\n\n  AutoReportFrontendContext fc(cx);\n  Parser<FullParseHandler,
        Unit> parser(&fc, options, units, length,\n                                        /*
        foldConstants = */ false,\n                                        compilationState,\n
        \                                       /* syntaxParser = */ nullptr);\n  if
        (!parser.checkOptions()) {\n    return false;\n  }\n\n  // Emplace the top-level
        stencil.\n  MOZ_ASSERT(compilationState.scriptData.length() ==\n             CompilationStencil::TopLevelIndex);\n
        \ if (!compilationState.appendScriptStencilAndData(&fc)) {\n    return false;\n
        \ }\n\n  js::frontend::ParseNode* pn;\n  if (goal == frontend::ParseGoal::Script)
        {\n    pn = parser.parse().unwrapOr(nullptr);\n  } else {\n    ModuleBuilder
        builder(&fc, &parser);\n\n    SourceExtent extent = SourceExtent::makeGlobalExtent(length);\n
        \   ModuleSharedContext modulesc(&fc, options, builder, extent);\n    pn =
        parser.moduleBody(&modulesc).unwrapOr(nullptr);\n  }\n\n  if (!pn) {\n    return
        false;\n  }\n\n#if defined(DEBUG)\n  js::Fprinter out(stderr);\n  DumpParseTree(&parser,
        pn, out);\n#endif\n\n  return true;\n}\n\ntemplate <typename Unit>\n[[nodiscard]]
        static bool DumpStencil(JSContext* cx,\n                                      const
        JS::ReadOnlyCompileOptions& options,\n                                      const
        Unit* units, size_t length,\n                                      js::frontend::ParseGoal
        goal) {\n  Rooted<frontend::CompilationInput> input(cx,\n                                           frontend::CompilationInput(options));\n\n
        \ JS::SourceText<Unit> srcBuf;\n  if (!srcBuf.init(cx, units, length, JS::SourceOwnership::Borrowed))
        {\n    return false;\n  }\n\n  AutoReportFrontendContext fc(cx);\n  js::frontend::NoScopeBindingCache
        scopeCache;\n  UniquePtr<frontend::ExtensibleCompilationStencil> stencil;\n
        \ if (goal == frontend::ParseGoal::Script) {\n    stencil = frontend::CompileGlobalScriptToExtensibleStencil(\n
        \       cx, &fc, input.get(), &scopeCache, srcBuf, ScopeKind::Global);\n  }
        else {\n    stencil = frontend::ParseModuleToExtensibleStencil(\n        cx,
        &fc, cx->tempLifoAlloc(), input.get(), &scopeCache, srcBuf);\n  }\n\n  if
        (!stencil) {\n    return false;\n  }\n\n#if defined(DEBUG) || defined(JS_JITSPEW)\n
        \ stencil->dump();\n#endif\n\n  return true;\n}\n\nstatic bool FrontendTest(JSContext*
        cx, unsigned argc, Value* vp,\n                         const char* funcName,
        DumpType dumpType) {\n  using namespace js::frontend;\n\n  CallArgs args =
        CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx, funcName, 1))
        {\n    return false;\n  }\n  if (!args[0].isString()) {\n    const char* typeName
        = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx, \"expected
        string to parse, got %s\", typeName);\n    return false;\n  }\n\n  frontend::ParseGoal
        goal = frontend::ParseGoal::Script;\n#ifdef JS_ENABLE_SMOOSH\n  bool smoosh
        = false;\n#endif\n\n  CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell parse\")\n      .setFileAndLine(\"<string>\", 1)\n      .setIsRunOnce(true)\n
        \     .setNoScriptRval(true);\n\n  if (args.length() >= 2) {\n    if (!args[1].isObject())
        {\n      JS_ReportErrorASCII(cx, \"The 2nd argument must be an object\");\n
        \     return false;\n    }\n\n    RootedObject objOptions(cx, &args[1].toObject());\n\n
        \   RootedValue optionModule(cx);\n    if (!JS_GetProperty(cx, objOptions,
        \"module\", &optionModule)) {\n      return false;\n    }\n\n    if (optionModule.isBoolean())
        {\n      if (optionModule.toBoolean()) {\n        goal = frontend::ParseGoal::Module;\n
        \     }\n    } else if (!optionModule.isUndefined()) {\n      const char*
        typeName = InformalValueTypeName(optionModule);\n      JS_ReportErrorASCII(cx,
        \"option `module` should be a boolean, got %s\",\n                          typeName);\n
        \     return false;\n    }\n    if (!js::ParseCompileOptions(cx, options,
        objOptions, nullptr)) {\n      return false;\n    }\n\n    if (goal == frontend::ParseGoal::Module
        && options.lineno == 0) {\n      JS_ReportErrorASCII(cx, \"Module cannot be
        compiled with lineNumber == 0\");\n      return false;\n    }\n\n#ifdef JS_ENABLE_SMOOSH\n
        \   bool found = false;\n    if (!JS_HasProperty(cx, objOptions, \"rustFrontend\",
        &found)) {\n      return false;\n    }\n    if (found) {\n      JS_ReportErrorASCII(cx,
        \"'rustFrontend' option is renamed to 'smoosh'\");\n      return false;\n
        \   }\n\n    RootedValue optionSmoosh(cx);\n    if (!JS_GetProperty(cx, objOptions,
        \"smoosh\", &optionSmoosh)) {\n      return false;\n    }\n\n    if (optionSmoosh.isBoolean())
        {\n      smoosh = optionSmoosh.toBoolean();\n    } else if (!optionSmoosh.isUndefined())
        {\n      const char* typeName = InformalValueTypeName(optionSmoosh);\n      JS_ReportErrorASCII(cx,
        \"option `smoosh` should be a boolean, got %s\",\n                          typeName);\n
        \     return false;\n    }\n#endif  // JS_ENABLE_SMOOSH\n  }\n\n  JSString*
        scriptContents = args[0].toString();\n  Rooted<JSLinearString*> linearString(cx,
        scriptContents->ensureLinear(cx));\n  if (!linearString) {\n    return false;\n
        \ }\n\n  bool isAscii = false;\n  if (linearString->hasLatin1Chars()) {\n
        \   JS::AutoCheckCannotGC nogc;\n    isAscii = JS::StringIsASCII(mozilla::Span(\n
        \       reinterpret_cast<const char*>(linearString->latin1Chars(nogc)),\n
        \       linearString->length()));\n  }\n\n  AutoStableStringChars stableChars(cx);\n
        \ if (isAscii) {\n    if (!stableChars.init(cx, scriptContents)) {\n      return
        false;\n    }\n    MOZ_ASSERT(stableChars.isLatin1());\n  } else {\n    if
        (!stableChars.initTwoByte(cx, scriptContents)) {\n      return false;\n    }\n
        \ }\n\n  size_t length = scriptContents->length();\n#ifdef JS_ENABLE_SMOOSH\n
        \ if (dumpType == DumpType::ParseNode) {\n    if (smoosh) {\n      if (isAscii)
        {\n        const Latin1Char* chars = stableChars.latin1Range().begin().get();\n\n
        \       if (goal == frontend::ParseGoal::Script) {\n          if (!SmooshParseScript(cx,
        chars, length)) {\n            return false;\n          }\n        } else
        {\n          if (!SmooshParseModule(cx, chars, length)) {\n            return
        false;\n          }\n        }\n        args.rval().setUndefined();\n        return
        true;\n      }\n      JS_ReportErrorASCII(cx,\n                          \"SmooshMonkey
        does not support non-ASCII chars yet\");\n      return false;\n    }\n  }\n#endif
        \ // JS_ENABLE_SMOOSH\n\n  if (goal == frontend::ParseGoal::Module) {\n    //
        See frontend::CompileModule.\n    options.setForceStrictMode();\n    options.allowHTMLComments
        = false;\n  }\n\n  if (dumpType == DumpType::Stencil) {\n#ifdef JS_ENABLE_SMOOSH\n
        \   if (smoosh) {\n      if (isAscii) {\n        if (goal == frontend::ParseGoal::Script)
        {\n          const Latin1Char* latin1 = stableChars.latin1Range().begin().get();\n
        \         auto utf8 = reinterpret_cast<const mozilla::Utf8Unit*>(latin1);\n
        \         JS::SourceText<Utf8Unit> srcBuf;\n          if (!srcBuf.init(cx,
        utf8, length, JS::SourceOwnership::Borrowed)) {\n            return false;\n
        \         }\n\n          AutoReportFrontendContext fc(cx);\n          Rooted<frontend::CompilationInput>
        input(\n              cx, frontend::CompilationInput(options));\n          UniquePtr<frontend::ExtensibleCompilationStencil>
        stencil;\n          if (!Smoosh::tryCompileGlobalScriptToExtensibleStencil(\n
        \                 cx, &fc, input.get(), srcBuf, stencil)) {\n            return
        false;\n          }\n          if (!stencil) {\n            fc.clearAutoReport();\n
        \           JS_ReportErrorASCII(cx, \"SmooshMonkey failed to parse\");\n            return
        false;\n          }\n\n#  ifdef DEBUG\n          {\n            frontend::BorrowingCompilationStencil
        borrowingStencil(*stencil);\n            borrowingStencil.dump();\n          }\n#
        \ endif\n        } else {\n          JS_ReportErrorASCII(cx,\n                              \"SmooshMonkey
        does not support module stencil\");\n          return false;\n        }\n
        \       args.rval().setUndefined();\n        return true;\n      }\n      JS_ReportErrorASCII(cx,\n
        \                         \"SmooshMonkey does not support non-ASCII chars
        yet\");\n      return false;\n    }\n#endif  // JS_ENABLE_SMOOSH\n\n    if
        (isAscii) {\n      const Latin1Char* latin1 = stableChars.latin1Range().begin().get();\n
        \     auto utf8 = reinterpret_cast<const mozilla::Utf8Unit*>(latin1);\n      if
        (!DumpStencil<mozilla::Utf8Unit>(cx, options, utf8, length, goal)) {\n        return
        false;\n      }\n    } else {\n      MOZ_ASSERT(stableChars.isTwoByte());\n
        \     const char16_t* chars = stableChars.twoByteRange().begin().get();\n
        \     if (!DumpStencil<char16_t>(cx, options, chars, length, goal)) {\n        return
        false;\n      }\n    }\n\n    args.rval().setUndefined();\n    return true;\n
        \ }\n\n  AutoReportFrontendContext fc(cx);\n  Rooted<frontend::CompilationInput>
        input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (goal == frontend::ParseGoal::Script) {\n    if (!input.get().initForGlobal(&fc))
        {\n      return false;\n    }\n  } else {\n    if (!input.get().initForModule(&fc))
        {\n      return false;\n    }\n  }\n\n  LifoAllocScope allocScope(&cx->tempLifoAlloc());\n
        \ frontend::NoScopeBindingCache scopeCache;\n  frontend::CompilationState
        compilationState(&fc, allocScope, input.get());\n  if (!compilationState.init(&fc,
        &scopeCache)) {\n    return false;\n  }\n\n  if (isAscii) {\n    const Latin1Char*
        latin1 = stableChars.latin1Range().begin().get();\n    auto utf8 = reinterpret_cast<const
        mozilla::Utf8Unit*>(latin1);\n    if (!DumpAST<mozilla::Utf8Unit>(cx, options,
        utf8, length, compilationState,\n                                    goal))
        {\n      return false;\n    }\n  } else {\n    MOZ_ASSERT(stableChars.isTwoByte());\n
        \   const char16_t* chars = stableChars.twoByteRange().begin().get();\n    if
        (!DumpAST<char16_t>(cx, options, chars, length, compilationState,\n                           goal))
        {\n      return false;\n    }\n  }\n  args.rval().setUndefined();\n  return
        true;\n}\n\nstatic bool DumpStencil(JSContext* cx, unsigned argc, Value* vp)
        {\n  return FrontendTest(cx, argc, vp, \"dumpStencil\", DumpType::Stencil);\n}\n\nstatic
        bool Parse(JSContext* cx, unsigned argc, Value* vp) {\n  // Parse returns
        local scope information with variables ordered\n  // differently, depending
        on the underlying JIT implementation.\n  if (js::SupportDifferentialTesting())
        {\n    JS_ReportErrorASCII(cx,\n                        \"Function not available
        in differential testing mode.\");\n    return false;\n  }\n\n  return FrontendTest(cx,
        argc, vp, \"parse\", DumpType::ParseNode);\n}\n\nstatic bool SyntaxParse(JSContext*
        cx, unsigned argc, Value* vp) {\n  using namespace js::frontend;\n\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx, \"syntaxParse\",
        1)) {\n    return false;\n  }\n  if (!args[0].isString()) {\n    const char*
        typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx, \"expected
        string to parse, got %s\", typeName);\n    return false;\n  }\n\n  JSString*
        scriptContents = args[0].toString();\n\n  CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell syntaxParse\")\n      .setFileAndLine(\"<string>\", 1);\n\n  AutoStableStringChars
        stableChars(cx);\n  if (!stableChars.initTwoByte(cx, scriptContents)) {\n
        \   return false;\n  }\n\n  const char16_t* chars = stableChars.twoByteRange().begin().get();\n
        \ size_t length = scriptContents->length();\n\n  AutoReportFrontendContext
        fc(cx);\n  Rooted<frontend::CompilationInput> input(cx,\n                                           frontend::CompilationInput(options));\n
        \ if (!input.get().initForGlobal(&fc)) {\n    return false;\n  }\n\n  LifoAllocScope
        allocScope(&cx->tempLifoAlloc());\n  frontend::NoScopeBindingCache scopeCache;\n
        \ frontend::CompilationState compilationState(&fc, allocScope, input.get());\n
        \ if (!compilationState.init(&fc, &scopeCache)) {\n    return false;\n  }\n\n
        \ Parser<frontend::SyntaxParseHandler, char16_t> parser(\n      &fc, options,
        chars, length,\n      /* foldConstants = */ false, compilationState,\n      /*
        syntaxParser = */ nullptr);\n  if (!parser.checkOptions()) {\n    return false;\n
        \ }\n\n  bool succeeded = parser.parse().isOk();\n  if (fc.hadErrors()) {\n
        \   return false;\n  }\n\n  if (!succeeded && !parser.hadAbortedSyntaxParse())
        {\n    // If no exception is posted, either there was an OOM or a language\n
        \   // feature unhandled by the syntax parser was encountered.\n    MOZ_ASSERT(fc.hadOutOfMemory());\n
        \   return false;\n  }\n\n  args.rval().setBoolean(succeeded);\n  return true;\n}\n\nstatic
        bool OffThreadCompileToStencil(JSContext* cx, unsigned argc, Value* vp) {\n
        \ if (!CanUseExtraThreads()) {\n    JS_ReportErrorASCII(\n        cx, \"Can't
        use offThreadCompileToStencil with --no-threads\");\n    return false;\n  }\n\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx,
        \"offThreadCompileToStencil\", 1)) {\n    return false;\n  }\n  if (!args[0].isString())
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"expected string to parse, got %s\", typeName);\n    return false;\n  }\n\n
        \ UniqueChars fileNameBytes;\n  CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell offThreadCompileToStencil\")\n      .setFileAndLine(\"<string>\", 1);\n\n
        \ if (args.length() >= 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(\n
        \         cx, \"offThreadCompileToStencil: The 2nd argument must be an object\");\n
        \     return false;\n    }\n\n    // Offthread compilation requires that the
        debug metadata be set when the\n    // script is collected from offthread,
        rather than when compiled.\n    RootedObject opts(cx, &args[1].toObject());\n
        \   if (!js::ParseCompileOptions(cx, options, opts, &fileNameBytes)) {\n      return
        false;\n    }\n  }\n\n  // This option setting must override whatever the
        caller requested.\n  options.setIsRunOnce(true);\n\n  JSString* scriptContents
        = args[0].toString();\n  AutoStableStringChars stableChars(cx);\n  if (!stableChars.initTwoByte(cx,
        scriptContents)) {\n    return false;\n  }\n\n  size_t length = scriptContents->length();\n
        \ const char16_t* chars = stableChars.twoByteChars();\n\n  // Make sure we
        own the string's chars, so that they are not freed before\n  // the compilation
        is finished.\n  UniqueTwoByteChars ownedChars;\n  if (stableChars.maybeGiveOwnershipToCaller())
        {\n    ownedChars.reset(const_cast<char16_t*>(chars));\n  } else {\n    ownedChars.reset(cx->pod_malloc<char16_t>(length));\n
        \   if (!ownedChars) {\n      return false;\n    }\n\n    mozilla::PodCopy(ownedChars.get(),
        chars, length);\n  }\n\n  if (!cx->runtime()->canUseParallelParsing() || !js::CanUseExtraThreads())
        {\n    JS_ReportErrorASCII(cx, \"cannot compile code on helper thread\");\n
        \   return false;\n  }\n\n  JS::SourceText<char16_t> srcBuf;\n  if (!srcBuf.init(cx,
        std::move(ownedChars), length)) {\n    return false;\n  }\n\n  OffThreadJob*
        job = NewOffThreadJob(cx, OffThreadJob::Kind::CompileScript,\n                                      options,
        std::move(srcBuf));\n  if (!job) {\n    return false;\n  }\n\n  if (!job->dispatch())
        {\n    ReportOutOfMemory(cx);\n    DeleteOffThreadJob(cx, job);\n    return
        false;\n  }\n\n  args.rval().setInt32(job->id);\n  return true;\n}\n\nstatic
        bool FinishOffThreadStencil(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  OffThreadJob* job = LookupOffThreadJobForArgs(cx,
        args, 0);\n  if (!job) {\n    return false;\n  }\n\n  job->waitUntilDone();\n\n
        \ RefPtr<JS::Stencil> stencil = job->stealStencil(cx);\n  DeleteOffThreadJob(cx,
        job);\n  if (!stencil) {\n    return false;\n  }\n  RootedObject stencilObj(cx,\n
        \                         js::StencilObject::create(cx, std::move(stencil)));\n
        \ if (!stencilObj) {\n    return false;\n  }\n\n  args.rval().setObject(*stencilObj);\n
        \ return true;\n}\n\nstatic bool OffThreadCompileModuleToStencil(JSContext*
        cx, unsigned argc,\n                                            Value* vp)
        {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx,
        \"offThreadCompileModuleToStencil\", 1)) {\n    return false;\n  }\n  if (!args[0].isString())
        {\n    const char* typeName = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx,
        \"expected string to parse, got %s\", typeName);\n    return false;\n  }\n\n
        \ UniqueChars fileNameBytes;\n  CompileOptions options(cx);\n  options.setIntroductionType(\"js
        shell offThreadCompileModuleToStencil\")\n      .setFileAndLine(\"<string>\",
        1);\n\n  if (args.length() >= 2) {\n    if (!args[1].isObject()) {\n      JS_ReportErrorASCII(cx,\n
        \                         \"offThreadCompileModuleToStencil: The 2nd argument
        \"\n                          \"must be an object\");\n      return false;\n
        \   }\n\n    // Offthread compilation requires that the debug metadata be
        set when the\n    // script is collected from offthread, rather than when
        compiled.\n    RootedObject opts(cx, &args[1].toObject());\n    if (!js::ParseCompileOptions(cx,
        options, opts, &fileNameBytes)) {\n      return false;\n    }\n\n    if (!ValidateModuleCompileOptions(cx,
        options)) {\n      return false;\n    }\n  }\n\n  options.setIsRunOnce(true).setSourceIsLazy(false);\n\n
        \ JSString* scriptContents = args[0].toString();\n  AutoStableStringChars
        stableChars(cx);\n  if (!stableChars.initTwoByte(cx, scriptContents)) {\n
        \   return false;\n  }\n\n  size_t length = scriptContents->length();\n  const
        char16_t* chars = stableChars.twoByteChars();\n\n  // Make sure we own the
        string's chars, so that they are not freed before\n  // the compilation is
        finished.\n  UniqueTwoByteChars ownedChars;\n  if (stableChars.maybeGiveOwnershipToCaller())
        {\n    ownedChars.reset(const_cast<char16_t*>(chars));\n  } else {\n    ownedChars.reset(cx->pod_malloc<char16_t>(length));\n
        \   if (!ownedChars) {\n      return false;\n    }\n\n    mozilla::PodCopy(ownedChars.get(),
        chars, length);\n  }\n\n  if (!cx->runtime()->canUseParallelParsing() || !js::CanUseExtraThreads())
        {\n    JS_ReportErrorASCII(cx, \"cannot compile code on worker thread\");\n
        \   return false;\n  }\n\n  JS::SourceText<char16_t> srcBuf;\n  if (!srcBuf.init(cx,
        std::move(ownedChars), length)) {\n    return false;\n  }\n\n  OffThreadJob*
        job = NewOffThreadJob(cx, OffThreadJob::Kind::CompileModule,\n                                      options,
        std::move(srcBuf));\n  if (!job) {\n    return false;\n  }\n\n  if (!job->dispatch())
        {\n    ReportOutOfMemory(cx);\n    DeleteOffThreadJob(cx, job);\n    return
        false;\n  }\n\n  args.rval().setInt32(job->id);\n  return true;\n}\n\nstatic
        bool OffThreadDecodeStencil(JSContext* cx, unsigned argc, Value* vp) {\n  if
        (!CanUseExtraThreads()) {\n    JS_ReportErrorASCII(cx,\n                        \"Can't
        use offThreadDecodeStencil with --no-threads\");\n    return false;\n  }\n\n
        \ CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!args.requireAtLeast(cx,
        \"offThreadDecodeStencil\", 1)) {\n    return false;\n  }\n  if (!args[0].isObject()
        || !CacheEntry_isCacheEntry(&args[0].toObject())) {\n    const char* typeName
        = InformalValueTypeName(args[0]);\n    JS_ReportErrorASCII(cx, \"expected
        cache entry, got %s\", typeName);\n    return false;\n  }\n  RootedObject
        cacheEntry(cx, &args[0].toObject());\n\n  UniqueChars fileNameBytes;\n  CompileOptions
        options(cx);\n  options.setIntroductionType(\"js shell offThreadDecodeStencil\")\n
        \     .setFileAndLine(\"<string>\", 1);\n\n  if (args.length() >= 2) {\n    if
        (!args[1].isObject()) {\n      JS_ReportErrorASCII(\n          cx, \"offThreadDecodeStencil:
        The 2nd argument must be an object\");\n      return false;\n    }\n\n    RootedObject
        opts(cx, &args[1].toObject());\n    if (!js::ParseCompileOptions(cx, options,
        opts, &fileNameBytes)) {\n      return false;\n    }\n  }\n\n  // This option
        setting must override whatever the caller requested, and\n  // this should
        match `Evaluate` that encodes the script.\n  options.setIsRunOnce(false);\n\n
        \ JS::TranscodeBuffer loadBuffer;\n  size_t loadLength = 0;\n  uint8_t* loadData
        = nullptr;\n  loadData = CacheEntry_getBytecode(cx, cacheEntry, &loadLength);\n
        \ if (!loadData) {\n    return false;\n  }\n  if (!loadBuffer.append(loadData,
        loadLength)) {\n    JS_ReportOutOfMemory(cx);\n    return false;\n  }\n\n
        \ if (!cx->runtime()->canUseParallelParsing() || !js::CanUseExtraThreads())
        {\n    JS_ReportErrorASCII(cx, \"cannot compile code on worker thread\");\n
        \   return false;\n  }\n\n  OffThreadJob* job = NewOffThreadJob(cx, OffThreadJob::Kind::Decode,
        options,\n                                      std::move(loadBuffer));\n
        \ if (!job) {\n    return false;\n  }\n\n  if (!job->dispatch()) {\n    ReportOutOfMemory(cx);\n
        \   DeleteOffThreadJob(cx, job);\n    return false;\n  }\n\n  args.rval().setInt32(job->id);\n
        \ return true;\n}\n\nclass AutoCStringVector {\n  Vector<char*> argv_;\n\n
        public:\n  explicit AutoCStringVector(JSContext* cx) : argv_(cx) {}\n  ~AutoCStringVector()
        {\n    for (size_t i = 0; i < argv_.length(); i++) {\n      js_free(argv_[i]);\n
        \   }\n  }\n  bool append(UniqueChars&& arg) {\n    if (!argv_.append(arg.get()))
        {\n      return false;\n    }\n\n    // Now owned by this vector.\n    (void)arg.release();\n
        \   return true;\n  }\n  char* const* get() const { return argv_.begin();
        }\n  size_t length() const { return argv_.length(); }\n  char* operator[](size_t
        i) const { return argv_[i]; }\n  void replace(size_t i, UniqueChars arg) {\n
        \   js_free(argv_[i]);\n    argv_[i] = arg.release();\n  }\n};\n\n#if defined(XP_WIN)\nstatic
        bool EscapeForShell(JSContext* cx, AutoCStringVector& argv) {\n  // Windows
        will break arguments in argv by various spaces, so we wrap each\n  // argument
        in quotes and escape quotes within. Even with quotes, \\ will be\n  // treated
        like an escape character, so inflate each \\ to \\\\.\n\n  for (size_t i =
        0; i < argv.length(); i++) {\n    if (!argv[i]) {\n      continue;\n    }\n\n
        \   size_t newLen = 3;  // quotes before and after and null-terminator\n    for
        (char* p = argv[i]; *p; p++) {\n      newLen++;\n      if (*p == '\\\"' ||
        *p == '\\\\') {\n        newLen++;\n      }\n    }\n\n    auto escaped = cx->make_pod_array<char>(newLen);\n
        \   if (!escaped) {\n      return false;\n    }\n\n    char* src = argv[i];\n
        \   char* dst = escaped.get();\n    *dst++ = '\\\"';\n    while (*src) {\n
        \     if (*src == '\\\"' || *src == '\\\\') {\n        *dst++ = '\\\\';\n
        \     }\n      *dst++ = *src++;\n    }\n    *dst++ = '\\\"';\n    *dst++ =
        '\\0';\n    MOZ_ASSERT(escaped.get() + newLen == dst);\n\n    argv.replace(i,
        std::move(escaped));\n  }\n  return true;\n}\n#endif\n\n#ifndef __wasi__\nstatic
        bool ReadAll(int fd, wasm::Bytes* bytes) {\n  size_t lastLength = bytes->length();\n
        \ while (true) {\n    static const int ChunkSize = 64 * 1024;\n    if (!bytes->growBy(ChunkSize))
        {\n      return false;\n    }\n\n    intptr_t readCount;\n    while (true)
        {\n      readCount = read(fd, bytes->begin() + lastLength, ChunkSize);\n      if
        (readCount >= 0) {\n        break;\n      }\n      if (errno != EINTR) {\n
        \       return false;\n      }\n    }\n\n    if (readCount < ChunkSize) {\n
        \     bytes->shrinkTo(lastLength + readCount);\n      if (readCount == 0)
        {\n        return true;\n      }\n    }\n\n    lastLength = bytes->length();\n
        \ }\n}\n\nstatic bool WriteAll(int fd, const uint8_t* bytes, size_t length)
        {\n  while (length > 0) {\n    int written = write(fd, bytes, length);\n    if
        (written < 0) {\n      if (errno == EINTR) {\n        continue;\n      }\n
        \     return false;\n    }\n    MOZ_ASSERT(unsigned(written) <= length);\n
        \   length -= written;\n    bytes += written;\n  }\n\n  return true;\n}\n\nclass
        AutoPipe {\n  int fds_[2];\n\n public:\n  AutoPipe() {\n    fds_[0] = -1;\n
        \   fds_[1] = -1;\n  }\n\n  ~AutoPipe() {\n    if (fds_[0] != -1) {\n      close(fds_[0]);\n
        \   }\n    if (fds_[1] != -1) {\n      close(fds_[1]);\n    }\n  }\n\n  bool
        init() {\n#  ifdef XP_WIN\n    return !_pipe(fds_, 4096, O_BINARY);\n#  else\n
        \   return !pipe(fds_);\n#  endif\n  }\n\n  int reader() const {\n    MOZ_ASSERT(fds_[0]
        != -1);\n    return fds_[0];\n  }\n\n  int writer() const {\n    MOZ_ASSERT(fds_[1]
        != -1);\n    return fds_[1];\n  }\n\n  void closeReader() {\n    MOZ_ASSERT(fds_[0]
        != -1);\n    close(fds_[0]);\n    fds_[0] = -1;\n  }\n\n  void closeWriter()
        {\n    MOZ_ASSERT(fds_[1] != -1);\n    close(fds_[1]);\n    fds_[1] = -1;\n
        \ }\n};\n#endif  // __wasi__\n\nint shell::sArgc;\nchar** shell::sArgv;\n\n#ifndef
        __wasi__\nstatic const char sWasmCompileAndSerializeFlag[] =\n    \"--wasm-compile-and-serialize\";\nstatic
        Vector<const char*, 5, js::SystemAllocPolicy> sCompilerProcessFlags;\n\nstatic
        bool CompileAndSerializeInSeparateProcess(JSContext* cx,\n                                                 const
        uint8_t* bytecode,\n                                                 size_t
        bytecodeLength,\n                                                 wasm::Bytes*
        serialized) {\n  AutoPipe stdIn, stdOut;\n  if (!stdIn.init() || !stdOut.init())
        {\n    return false;\n  }\n\n  AutoCStringVector argv(cx);\n\n  UniqueChars
        argv0 = DuplicateString(cx, sArgv[0]);\n  if (!argv0 || !argv.append(std::move(argv0)))
        {\n    return false;\n  }\n\n  // Put compiler flags first since they must
        precede the non-option\n  // file-descriptor args (passed on Windows, below).\n
        \ for (unsigned i = 0; i < sCompilerProcessFlags.length(); i++) {\n    UniqueChars
        flags = DuplicateString(cx, sCompilerProcessFlags[i]);\n    if (!flags ||
        !argv.append(std::move(flags))) {\n      return false;\n    }\n  }\n\n  UniqueChars
        arg;\n\n  arg = DuplicateString(sWasmCompileAndSerializeFlag);\n  if (!arg
        || !argv.append(std::move(arg))) {\n    return false;\n  }\n\n#  ifdef XP_WIN\n
        \ // The spawned process will have all the stdIn/stdOut file handles open,
        but\n  // without the power of fork, we need some other way to communicate
        the\n  // integer fd values so we encode them in argv and WasmCompileAndSerialize()\n
        \ // has a matching #ifdef XP_WIN to parse them out. Communicate both ends
        of\n  // both pipes so the child process can closed the unused ends.\n\n  arg
        = JS_smprintf(\"%d\", stdIn.reader());\n  if (!arg || !argv.append(std::move(arg)))
        {\n    return false;\n  }\n\n  arg = JS_smprintf(\"%d\", stdIn.writer());\n
        \ if (!arg || !argv.append(std::move(arg))) {\n    return false;\n  }\n\n
        \ arg = JS_smprintf(\"%d\", stdOut.reader());\n  if (!arg || !argv.append(std::move(arg)))
        {\n    return false;\n  }\n\n  arg = JS_smprintf(\"%d\", stdOut.writer());\n
        \ if (!arg || !argv.append(std::move(arg))) {\n    return false;\n  }\n#  endif\n\n
        \ // Required by both _spawnv and exec.\n  if (!argv.append(nullptr)) {\n
        \   return false;\n  }\n\n#  ifdef XP_WIN\n  if (!EscapeForShell(cx, argv))
        {\n    return false;\n  }\n\n  int childPid = _spawnv(P_NOWAIT, sArgv[0],
        argv.get());\n  if (childPid == -1) {\n    return false;\n  }\n#  else\n  pid_t
        childPid = fork();\n  switch (childPid) {\n    case -1:\n      return false;\n
        \   case 0:\n      // In the child process. Redirect stdin/stdout to the respective
        ends of\n      // the pipes. Closing stdIn.writer() is necessary for stdin
        to hit EOF.\n      // This case statement must not return before exec() takes
        over. Rather,\n      // exit(-1) is used to return failure to the parent process.\n
        \     if (dup2(stdIn.reader(), STDIN_FILENO) == -1) {\n        exit(-1);\n
        \     }\n      if (dup2(stdOut.writer(), STDOUT_FILENO) == -1) {\n        exit(-1);\n
        \     }\n      close(stdIn.reader());\n      close(stdIn.writer());\n      close(stdOut.reader());\n
        \     close(stdOut.writer());\n      execv(sArgv[0], argv.get());\n      exit(-1);\n
        \ }\n#  endif\n\n  // In the parent process. Closing stdOut.writer() is necessary
        for\n  // stdOut.reader() below to hit EOF.\n  stdIn.closeReader();\n  stdOut.closeWriter();\n\n
        \ if (!WriteAll(stdIn.writer(), bytecode, bytecodeLength)) {\n    return false;\n
        \ }\n\n  stdIn.closeWriter();\n\n  if (!ReadAll(stdOut.reader(), serialized))
        {\n    return false;\n  }\n\n  stdOut.closeReader();\n\n  int status;\n#  ifdef
        XP_WIN\n  if (_cwait(&status, childPid, WAIT_CHILD) == -1) {\n    return false;\n
        \ }\n#  else\n  while (true) {\n    if (waitpid(childPid, &status, 0) >= 0)
        {\n      break;\n    }\n    if (errno != EINTR) {\n      return false;\n    }\n
        \ }\n#  endif\n\n  return status == 0;\n}\n\nstatic bool WasmCompileAndSerialize(JSContext*
        cx) {\n  MOZ_ASSERT(wasm::CodeCachingAvailable(cx));\n\n#  ifdef XP_WIN\n
        \ // See CompileAndSerializeInSeparateProcess for why we've had to smuggle\n
        \ // these fd values through argv. Closing the writing ends is necessary for\n
        \ // the reading ends to hit EOF.\n  int flagIndex = 0;\n  for (; flagIndex
        < sArgc; flagIndex++) {\n    if (!strcmp(sArgv[flagIndex], sWasmCompileAndSerializeFlag))
        {\n      break;\n    }\n  }\n  MOZ_RELEASE_ASSERT(flagIndex < sArgc);\n\n
        \ int fdsIndex = flagIndex + 1;\n  MOZ_RELEASE_ASSERT(fdsIndex + 4 == sArgc);\n\n
        \ int stdInReader = atoi(sArgv[fdsIndex + 0]);\n  int stdInWriter = atoi(sArgv[fdsIndex
        + 1]);\n  int stdOutReader = atoi(sArgv[fdsIndex + 2]);\n  int stdOutWriter
        = atoi(sArgv[fdsIndex + 3]);\n\n  int stdIn = stdInReader;\n  close(stdInWriter);\n
        \ close(stdOutReader);\n  int stdOut = stdOutWriter;\n#  else\n  int stdIn
        = STDIN_FILENO;\n  int stdOut = STDOUT_FILENO;\n#  endif\n\n  wasm::MutableBytes
        bytecode = js_new<wasm::ShareableBytes>();\n  if (!ReadAll(stdIn, &bytecode->bytes))
        {\n    return false;\n  }\n\n  wasm::Bytes serialized;\n  if (!wasm::CompileAndSerialize(cx,
        *bytecode, &serialized)) {\n    return false;\n  }\n\n  if (!WriteAll(stdOut,
        serialized.begin(), serialized.length())) {\n    return false;\n  }\n\n  return
        true;\n}\n\nstatic bool WasmCompileInSeparateProcess(JSContext* cx, unsigned
        argc,\n                                         Value* vp) {\n  if (!wasm::CodeCachingAvailable(cx))
        {\n    JS_ReportErrorASCII(cx, \"WebAssembly caching not supported\");\n    return
        false;\n  }\n\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx,
        \"wasmCompileInSeparateProcess\", 1)) {\n    return false;\n  }\n\n  SharedMem<uint8_t*>
        bytecode;\n  size_t numBytes;\n  if (!args[0].isObject() ||\n      !IsBufferSource(&args[0].toObject(),
        &bytecode, &numBytes)) {\n    RootedObject callee(cx, &args.callee());\n    ReportUsageErrorASCII(cx,
        callee, \"Argument must be a buffer source\");\n    return false;\n  }\n\n
        \ wasm::Bytes serialized;\n  if (!CompileAndSerializeInSeparateProcess(cx,
        bytecode.unwrap(), numBytes,\n                                            &serialized))
        {\n    if (!cx->isExceptionPending()) {\n      JS_ReportErrorASCII(cx, \"creating
        and executing child process\");\n    }\n    return false;\n  }\n\n  RootedObject
        module(cx);\n  if (!wasm::DeserializeModule(cx, serialized, &module)) {\n
        \   return false;\n  }\n\n  args.rval().setObject(*module);\n  return true;\n}\n#endif
        \ // __wasi__\n\nstatic bool DecompileFunction(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  if (args.length()
        < 1 || !args[0].isObject() ||\n      !args[0].toObject().is<JSFunction>())
        {\n    args.rval().setUndefined();\n    return true;\n  }\n  RootedFunction
        fun(cx, &args[0].toObject().as<JSFunction>());\n  JSString* result = JS_DecompileFunction(cx,
        fun);\n  if (!result) {\n    return false;\n  }\n  args.rval().setString(result);\n
        \ return true;\n}\n\nstatic bool DecompileThisScript(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  NonBuiltinScriptFrameIter
        iter(cx);\n  if (iter.done()) {\n    args.rval().setString(cx->runtime()->emptyString);\n
        \   return true;\n  }\n\n  {\n    JSAutoRealm ar(cx, iter.script());\n\n    RootedScript
        script(cx, iter.script());\n    JSString* result = JS_DecompileScript(cx,
        script);\n    if (!result) {\n      return false;\n    }\n\n    args.rval().setString(result);\n
        \ }\n\n  return JS_WrapValue(cx, args.rval());\n}\n\nstatic bool ValueToSource(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ JSString* str = ValueToSource(cx, args.get(0));\n  if (!str) {\n    return
        false;\n  }\n\n  args.rval().setString(str);\n  return true;\n}\n\nstatic
        bool ThisFilename(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  JS::AutoFilename filename;\n  if (!DescribeScriptedCaller(cx,
        &filename) || !filename.get()) {\n    args.rval().setString(cx->runtime()->emptyString);\n
        \   return true;\n  }\n\n  JSString* str = NewStringCopyUTF8(cx, filename.get());\n
        \ if (!str) {\n    return false;\n  }\n\n  args.rval().setString(str);\n  return
        true;\n}\n\nstatic bool WrapWithProto(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  Value obj = args.get(0);\n
        \ Value proto = args.get(1);\n  if (!obj.isObject() || !proto.isObjectOrNull())
        {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n                              JSSMSG_INVALID_ARGS,
        \"wrapWithProto\");\n    return false;\n  }\n\n  // Disallow constructing
        (deeply) nested wrapper chains, to avoid running\n  // out of stack space
        in isCallable/isConstructor. See bug 1126105.\n  if (IsWrapper(&obj.toObject()))
        {\n    JS_ReportErrorASCII(cx, \"wrapWithProto cannot wrap a wrapper\");\n
        \   return false;\n  }\n\n  WrapperOptions options(cx);\n  options.setProto(proto.toObjectOrNull());\n
        \ JSObject* wrapped = Wrapper::New(cx, &obj.toObject(),\n                                   &Wrapper::singletonWithPrototype,
        options);\n  if (!wrapped) {\n    return false;\n  }\n\n  args.rval().setObject(*wrapped);\n
        \ return true;\n}\n\nstatic bool NewGlobal(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx,
        &args.callee());\n\n  JS::RealmOptions options;\n  JS::RealmCreationOptions&
        creationOptions = options.creationOptions();\n  JS::RealmBehaviors& behaviors
        = options.behaviors();\n  ShellGlobalKind kind = ShellGlobalKind::WindowProxy;\n
        \ bool immutablePrototype = true;\n\n  SetStandardRealmOptions(options);\n\n
        \ // Default to creating the global in the current compartment unless\n  //
        --more-compartments is used.\n  if (defaultToSameCompartment) {\n    creationOptions.setExistingCompartment(cx->global());\n
        \ } else {\n    creationOptions.setNewCompartmentAndZone();\n  }\n\n  // Ensure
        the target compartment/zone is kept alive when sameCompartmentAs or\n  //
        sameZoneAs is used.\n  Rooted<JSObject*> compartmentRoot(cx);\n\n  JS::AutoHoldPrincipals
        principals(cx);\n\n  if (args.length() == 1 && args[0].isObject()) {\n    RootedObject
        opts(cx, &args[0].toObject());\n    RootedValue v(cx);\n\n    if (!JS_GetProperty(cx,
        opts, \"invisibleToDebugger\", &v)) {\n      return false;\n    }\n    if
        (v.isBoolean()) {\n      creationOptions.setInvisibleToDebugger(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"sameZoneAs\", &v)) {\n      return
        false;\n    }\n    if (v.isObject()) {\n      compartmentRoot = UncheckedUnwrap(&v.toObject());\n
        \     creationOptions.setNewCompartmentInExistingZone(compartmentRoot);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"sameCompartmentAs\", &v)) {\n
        \     return false;\n    }\n    if (v.isObject()) {\n      compartmentRoot
        = UncheckedUnwrap(&v.toObject());\n      creationOptions.setExistingCompartment(compartmentRoot);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"newCompartment\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      if (v.toBoolean()) {\n        creationOptions.setNewCompartmentAndZone();\n
        \     } else {\n        creationOptions.setExistingCompartment(cx->global());\n
        \     }\n    }\n\n    if (!JS_GetProperty(cx, opts, \"discardSource\", &v))
        {\n      return false;\n    }\n    if (v.isBoolean()) {\n      behaviors.setDiscardSource(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"useWindowProxy\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      kind = v.toBoolean() ? ShellGlobalKind::WindowProxy\n
        \                          : ShellGlobalKind::GlobalObject;\n    }\n\n    if
        (!JS_GetProperty(cx, opts, \"immutablePrototype\", &v)) {\n      return false;\n
        \   }\n    if (v.isBoolean()) {\n      immutablePrototype = v.toBoolean();\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"systemPrincipal\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      principals.reset(&ShellPrincipals::fullyTrusted);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"principal\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      uint32_t bits;\n      if
        (!ToUint32(cx, v, &bits)) {\n        return false;\n      }\n      JSPrincipals*
        newPrincipals = cx->new_<ShellPrincipals>(bits);\n      if (!newPrincipals)
        {\n        return false;\n      }\n      principals.reset(newPrincipals);\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"enableCoopAndCoep\", &v)) {\n
        \     return false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setCoopAndCoepEnabled(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"freezeBuiltins\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setFreezeBuiltins(v.toBoolean());\n
        \   }\n\n    // On the web, the SharedArrayBuffer constructor is not installed
        as a\n    // global property in pages that aren't isolated in a separate process
        (and\n    // thus can't allow the structured cloning of shared memory).  Specify
        false\n    // for this option to reproduce this behavior.\n    if (!JS_GetProperty(cx,
        opts, \"defineSharedArrayBufferConstructor\", &v)) {\n      return false;\n
        \   }\n    if (v.isBoolean()) {\n      creationOptions.setDefineSharedArrayBufferConstructor(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"forceUTC\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setForceUTC(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"alwaysUseFdlibm\", &v)) {\n      return
        false;\n    }\n    if (v.isBoolean()) {\n      creationOptions.setAlwaysUseFdlibm(v.toBoolean());\n
        \   }\n\n    if (!JS_GetProperty(cx, opts, \"locale\", &v)) {\n      return
        false;\n    }\n    if (v.isString()) {\n      RootedString str(cx, v.toString());\n
        \     UniqueChars locale = StringToLocale(cx, callee, str);\n      if (!locale)
        {\n        return false;\n      }\n      creationOptions.setLocaleCopyZ(locale.get());\n
        \   }\n  }\n\n  if (!CheckRealmOptions(cx, options, principals.get())) {\n
        \   return false;\n  }\n\n  RootedObject global(cx, NewGlobalObject(cx, options,
        principals.get(), kind,\n                                          immutablePrototype));\n
        \ if (!global) {\n    return false;\n  }\n\n  RootedObject wrapped(cx, ToWindowProxyIfWindow(global));\n
        \ if (!JS_WrapObject(cx, &wrapped)) {\n    return false;\n  }\n\n  args.rval().setObject(*wrapped);\n
        \ return true;\n}\n\nstatic bool NukeAllCCWs(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 0) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,\n
        \                             JSSMSG_INVALID_ARGS, \"nukeAllCCWs\");\n    return
        false;\n  }\n\n  NukeCrossCompartmentWrappers(cx, AllCompartments(), cx->realm(),\n
        \                              NukeWindowReferences, NukeAllReferences);\n
        \ args.rval().setUndefined();\n  return true;\n}\n\nstatic bool RecomputeWrappers(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() > 2) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS, \"recomputeWrappers\");\n
        \   return false;\n  }\n\n  JS::Compartment* sourceComp = nullptr;\n  if (args.get(0).isObject())
        {\n    sourceComp = JS::GetCompartment(UncheckedUnwrap(&args[0].toObject()));\n
        \ }\n\n  JS::Compartment* targetComp = nullptr;\n  if (args.get(1).isObject())
        {\n    targetComp = JS::GetCompartment(UncheckedUnwrap(&args[1].toObject()));\n
        \ }\n\n  struct SingleOrAllCompartments final : public CompartmentFilter {\n
        \   JS::Compartment* comp;\n    explicit SingleOrAllCompartments(JS::Compartment*
        c) : comp(c) {}\n    virtual bool match(JS::Compartment* c) const override
        {\n      return !comp || comp == c;\n    }\n  };\n\n  if (!js::RecomputeWrappers(cx,
        SingleOrAllCompartments(sourceComp),\n                             SingleOrAllCompartments(targetComp)))
        {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool DumpObjectWrappers(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  bool printedHeader = false;\n  for (ZonesIter
        zone(cx->runtime(), WithAtoms); !zone.done(); zone.next()) {\n    bool printedZoneInfo
        = false;\n    for (CompartmentsInZoneIter comp(zone); !comp.done(); comp.next())
        {\n      bool printedCompartmentInfo = false;\n      for (Compartment::ObjectWrapperEnum
        e(comp); !e.empty(); e.popFront()) {\n        JSObject* wrapper = e.front().value().unbarrieredGet();\n
        \       JSObject* wrapped = e.front().key();\n        if (!printedHeader)
        {\n          fprintf(stderr, \"Cross-compartment object wrappers:\\n\");\n
        \         printedHeader = true;\n        }\n        if (!printedZoneInfo)
        {\n          fprintf(stderr, \"  Zone %p:\\n\", zone.get());\n          printedZoneInfo
        = true;\n        }\n        if (!printedCompartmentInfo) {\n          fprintf(stderr,
        \"    Compartment %p:\\n\", comp.get());\n          printedCompartmentInfo
        = true;\n        }\n        fprintf(stderr,\n                \"      Object
        wrapper %p -> %p in zone %p compartment %p\\n\",\n                wrapper,
        wrapped, wrapped->zone(), wrapped->compartment());\n      }\n    }\n  }\n\n
        \ if (!printedHeader) {\n    fprintf(stderr, \"No cross-compartment object
        wrappers.\\n\");\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool GetMaxArgs(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  args.rval().setInt32(ARGS_LENGTH_MAX);\n  return
        true;\n}\n\nstatic bool IsHTMLDDA_Call(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  // These are the required
        conditions under which this object may be called\n  // by test262 tests, and
        the required behavior under those conditions.\n  if (args.length() == 0 ||\n
        \     (args[0].isString() && args[0].toString()->length() == 0)) {\n    args.rval().setNull();\n
        \   return true;\n  }\n\n  JS_ReportErrorASCII(\n      cx, \"IsHTMLDDA object
        is being called in an impermissible manner\");\n  return false;\n}\n\nstatic
        bool CreateIsHTMLDDA(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  static const JSClassOps classOps = {\n
        \     nullptr,         // addProperty\n      nullptr,         // delProperty\n
        \     nullptr,         // enumerate\n      nullptr,         // newEnumerate\n
        \     nullptr,         // resolve\n      nullptr,         // mayResolve\n
        \     nullptr,         // finalize\n      IsHTMLDDA_Call,  // call\n      nullptr,
        \        // construct\n      nullptr,         // trace\n  };\n\n  static const
        JSClass cls = {\n      \"IsHTMLDDA\",\n      JSCLASS_EMULATES_UNDEFINED,\n
        \     &classOps,\n  };\n\n  JSObject* obj = JS_NewObject(cx, &cls);\n  if
        (!obj) {\n    return false;\n  }\n  args.rval().setObject(*obj);\n  return
        true;\n}\n\nstatic bool GetSelfHostedValue(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (args.length()
        != 1 || !args[0].isString()) {\n    JS_ReportErrorNumberASCII(cx, my_GetErrorMessage,
        nullptr,\n                              JSSMSG_INVALID_ARGS, \"getSelfHostedValue\");\n
        \   return false;\n  }\n  Rooted<JSAtom*> srcAtom(cx, ToAtom<CanGC>(cx, args[0]));\n
        \ if (!srcAtom) {\n    return false;\n  }\n  Rooted<PropertyName*> srcName(cx,
        srcAtom->asPropertyName());\n  return GlobalObject::getIntrinsicValue(cx,
        cx->global(), srcName,\n                                         args.rval());\n}\n\nclass
        ShellSourceHook : public SourceHook {\n  // The function we should call to
        lazily retrieve source code.\n  PersistentRootedFunction fun;\n\n public:\n
        \ ShellSourceHook(JSContext* cx, JSFunction& fun) : fun(cx, &fun) {}\n\n  bool
        load(JSContext* cx, const char* filename, char16_t** twoByteSource,\n            char**
        utf8Source, size_t* length) override {\n    MOZ_ASSERT((twoByteSource != nullptr)
        != (utf8Source != nullptr),\n               \"must be called requesting only
        one of UTF-8 or UTF-16 source\");\n\n    RootedString str(cx);\n    if (filename)
        {\n      str = NewStringCopyUTF8(cx, filename);\n      if (!str) {\n        return
        false;\n      }\n    } else {\n      str = JS_GetEmptyString(cx);\n    }\n
        \   RootedValue filenameValue(cx, StringValue(str));\n\n    RootedValue result(cx);\n
        \   if (!Call(cx, UndefinedHandleValue, fun, HandleValueArray(filenameValue),\n
        \             &result)) {\n      return false;\n    }\n\n    str = JS::ToString(cx,
        result);\n    if (!str) {\n      return false;\n    }\n\n    Rooted<JSLinearString*>
        linear(cx, str->ensureLinear(cx));\n    if (!linear) {\n      return false;\n
        \   }\n\n    if (twoByteSource) {\n      *length = JS_GetStringLength(linear);\n\n
        \     *twoByteSource = cx->pod_malloc<char16_t>(*length);\n      if (!*twoByteSource)
        {\n        return false;\n      }\n\n      CopyChars(*twoByteSource, *linear);\n
        \   } else {\n      MOZ_ASSERT(utf8Source != nullptr);\n\n      *length =
        JS::GetDeflatedUTF8StringLength(linear);\n\n      *utf8Source = cx->pod_malloc<char>(*length);\n
        \     if (!*utf8Source) {\n        return false;\n      }\n\n      mozilla::DebugOnly<size_t>
        dstLen = JS::DeflateStringToUTF8Buffer(\n          linear, mozilla::Span(*utf8Source,
        *length));\n      MOZ_ASSERT(dstLen == *length);\n    }\n\n    return true;\n
        \ }\n};\n\nstatic bool WithSourceHook(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx,
        &args.callee());\n\n  if (args.length() != 2) {\n    ReportUsageErrorASCII(cx,
        callee, \"Wrong number of arguments.\");\n    return false;\n  }\n\n  if (!args[0].isObject()
        || !args[0].toObject().is<JSFunction>() ||\n      !args[1].isObject() || !args[1].toObject().is<JSFunction>())
        {\n    ReportUsageErrorASCII(cx, callee,\n                          \"First
        and second arguments must be functions.\");\n    return false;\n  }\n\n  mozilla::UniquePtr<ShellSourceHook>
        hook =\n      mozilla::MakeUnique<ShellSourceHook>(cx,\n                                           args[0].toObject().as<JSFunction>());\n
        \ if (!hook) {\n    return false;\n  }\n\n  mozilla::UniquePtr<SourceHook>
        savedHook = js::ForgetSourceHook(cx);\n  js::SetSourceHook(cx, std::move(hook));\n\n
        \ RootedObject fun(cx, &args[1].toObject());\n  bool result = Call(cx, UndefinedHandleValue,
        fun,\n                     JS::HandleValueArray::empty(), args.rval());\n
        \ js::SetSourceHook(cx, std::move(savedHook));\n  return result;\n}\n\nstatic
        void PrintProfilerEvents_Callback(const char* msg, const char* details) {\n
        \ fprintf(stderr, \"PROFILER EVENT: %s %s\\n\", msg, details);\n}\n\nstatic
        bool PrintProfilerEvents(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (cx->runtime()->geckoProfiler().enabled())
        {\n    js::RegisterContextProfilingEventMarker(cx, &PrintProfilerEvents_Callback);\n
        \ }\n  args.rval().setUndefined();\n  return true;\n}\n\n#ifdef SINGLESTEP_PROFILING\nstatic
        void SingleStepCallback(void* arg, jit::Simulator* sim, void* pc) {\n  JSContext*
        cx = reinterpret_cast<JSContext*>(arg);\n\n  // If profiling is not enabled,
        don't do anything.\n  if (!cx->runtime()->geckoProfiler().enabled()) {\n    return;\n
        \ }\n\n  JS::ProfilingFrameIterator::RegisterState state;\n  state.pc = pc;\n#
        \ if defined(JS_SIMULATOR_ARM)\n  state.sp = (void*)sim->get_register(jit::Simulator::sp);\n
        \ state.lr = (void*)sim->get_register(jit::Simulator::lr);\n  state.fp = (void*)sim->get_register(jit::Simulator::fp);\n
        \ state.tempFP = (void*)sim->get_register(jit::Simulator::r7);\n#  elif defined(JS_SIMULATOR_ARM64)\n
        \ state.sp = (void*)sim->get_sp();\n  state.lr = (void*)sim->get_lr();\n  state.fp
        = (void*)sim->get_fp();\n  state.tempFP = (void*)sim->xreg(11);\n#  elif defined(JS_SIMULATOR_MIPS64)
        || defined(JS_SIMULATOR_MIPS32)\n  state.sp = (void*)sim->getRegister(jit::Simulator::sp);\n
        \ state.lr = (void*)sim->getRegister(jit::Simulator::ra);\n  state.fp = (void*)sim->getRegister(jit::Simulator::fp);\n#
        \ elif defined(JS_SIMULATOR_LOONG64)\n  state.sp = (void*)sim->getRegister(jit::Simulator::sp);\n
        \ state.lr = (void*)sim->getRegister(jit::Simulator::ra);\n  state.fp = (void*)sim->getRegister(jit::Simulator::fp);\n#
        \ else\n#    error \"NYI: Single-step profiling support\"\n#  endif\n\n  mozilla::DebugOnly<void*>
        lastStackAddress = nullptr;\n  StackChars stack;\n  uint32_t frameNo = 0;\n
        \ AutoEnterOOMUnsafeRegion oomUnsafe;\n  for (JS::ProfilingFrameIterator i(cx,
        state); !i.done(); ++i) {\n    MOZ_ASSERT(i.stackAddress() != nullptr);\n#
        \ ifndef ENABLE_WASM_JSPI\n    // The stack addresses are monotonically increasing,
        except when\n    // suspendable stacks are present (e.g. when JS PI is enabled).\n
        \   MOZ_ASSERT(lastStackAddress <= i.stackAddress());\n#  endif\n    lastStackAddress
        = i.stackAddress();\n    JS::ProfilingFrameIterator::Frame frames[16];\n    uint32_t
        nframes = i.extractStack(frames, 0, 16);\n    for (uint32_t i = 0; i < nframes;
        i++) {\n#  ifndef ENABLE_WASM_JSPI\n      // Assert endStackAddress never
        exceeds sp (bug 1782188).\n      MOZ_ASSERT(frames[i].endStackAddress >= state.sp);\n#
        \ endif\n      if (frameNo > 0) {\n        if (!stack.append(\",\", 1)) {\n
        \         oomUnsafe.crash(\"stack.append\");\n        }\n      }\n      if
        (!stack.append(frames[i].label, strlen(frames[i].label))) {\n        oomUnsafe.crash(\"stack.append\");\n
        \     }\n      frameNo++;\n    }\n  }\n\n  ShellContext* sc = GetShellContext(cx);\n\n
        \ // Only append the stack if it differs from the last stack.\n  if (sc->stacks.empty()
        || sc->stacks.back().length() != stack.length() ||\n      !ArrayEqual(sc->stacks.back().begin(),
        stack.begin(), stack.length())) {\n    if (!sc->stacks.append(std::move(stack)))
        {\n      oomUnsafe.crash(\"stacks.append\");\n    }\n  }\n}\n#endif\n\nstatic
        bool EnableSingleStepProfiling(JSContext* cx, unsigned argc, Value* vp) {\n#ifdef
        SINGLESTEP_PROFILING\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  jit::Simulator*
        sim = cx->simulator();\n  sim->enable_single_stepping(SingleStepCallback,
        cx);\n\n  args.rval().setUndefined();\n  return true;\n#else\n  JS_ReportErrorASCII(cx,
        \"single-step profiling not enabled on this platform\");\n  return false;\n#endif\n}\n\nstatic
        bool DisableSingleStepProfiling(JSContext* cx, unsigned argc,\n                                       Value*
        vp) {\n#ifdef SINGLESTEP_PROFILING\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  jit::Simulator* sim = cx->simulator();\n  sim->disable_single_stepping();\n\n
        \ ShellContext* sc = GetShellContext(cx);\n\n  RootedValueVector elems(cx);\n
        \ for (size_t i = 0; i < sc->stacks.length(); i++) {\n    JSString* stack
        =\n        JS_NewUCStringCopyN(cx, sc->stacks[i].begin(), sc->stacks[i].length());\n
        \   if (!stack) {\n      return false;\n    }\n    if (!elems.append(StringValue(stack)))
        {\n      return false;\n    }\n  }\n\n  JSObject* array = JS::NewArrayObject(cx,
        elems);\n  if (!array) {\n    return false;\n  }\n\n  sc->stacks.clear();\n
        \ args.rval().setObject(*array);\n  return true;\n#else\n  JS_ReportErrorASCII(cx,
        \"single-step profiling not enabled on this platform\");\n  return false;\n#endif\n}\n\nstatic
        bool IsLatin1(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  bool isLatin1 =\n      args.get(0).isString()
        && args[0].toString()->hasLatin1Chars();\n  args.rval().setBoolean(isLatin1);\n
        \ return true;\n}\n\nstatic bool EnableGeckoProfiling(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  if (!EnsureGeckoProfilingStackInstalled(cx,
        GetShellContext(cx))) {\n    return false;\n  }\n\n  cx->runtime()->geckoProfiler().enableSlowAssertions(false);\n
        \ cx->runtime()->geckoProfiler().enable(true);\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool EnableGeckoProfilingWithSlowAssertions(JSContext*
        cx, unsigned argc,\n                                                   Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  args.rval().setUndefined();\n\n
        \ if (cx->runtime()->geckoProfiler().enabled()) {\n    // If profiling already
        enabled with slow assertions disabled,\n    // this is a no-op.\n    if (cx->runtime()->geckoProfiler().slowAssertionsEnabled())
        {\n      return true;\n    }\n\n    // Slow assertions are off.  Disable profiling
        before re-enabling\n    // with slow assertions on.\n    cx->runtime()->geckoProfiler().enable(false);\n
        \ }\n\n  if (!EnsureGeckoProfilingStackInstalled(cx, GetShellContext(cx)))
        {\n    return false;\n  }\n\n  cx->runtime()->geckoProfiler().enableSlowAssertions(true);\n
        \ cx->runtime()->geckoProfiler().enable(true);\n\n  return true;\n}\n\nstatic
        bool DisableGeckoProfiling(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  args.rval().setUndefined();\n\n  if (!cx->runtime()->geckoProfiler().enabled())
        {\n    return true;\n  }\n\n  cx->runtime()->geckoProfiler().enable(false);\n
        \ return true;\n}\n\n// Global mailbox that is used to communicate a shareable
        object value from one\n// worker to another.\n//\n// These object types are
        shareable:\n//\n//   - SharedArrayBuffer\n//   - WasmMemoryObject (when constructed
        with shared:true)\n//   - WasmModuleObject\n//\n// For the SharedArrayBuffer
        and WasmMemoryObject we transmit the underlying\n// SharedArrayRawBuffer (\"SARB\").
        For the WasmModuleObject we transmit the\n// underlying JS::WasmModule.  The
        transmitted types are refcounted.  When they\n// are in the mailbox their
        reference counts are at least 1, accounting for the\n// reference from the
        mailbox.\n//\n// The lock guards the mailbox variable and prevents a race
        where two workers\n// try to set the mailbox at the same time to replace an
        object that is only\n// referenced from the mailbox: the workers will both
        decrement the reference\n// count on the old object, and one of those decrements
        will be on a garbage\n// object.  We could implement this with atomics and
        a CAS loop but it's not\n// worth the bother.\n//\n// Note that if a thread
        reads the mailbox repeatedly it will get distinct\n// objects on each read.
        \ The alternatives are to cache created objects locally,\n// but this retains
        storage we don't need to retain, or to somehow clear the\n// mailbox locally,
        but this creates a coordination headache.  Buyer beware.\n\nenum class MailboxTag
        {\n  Empty,\n  SharedArrayBuffer,\n  WasmMemory,\n  WasmModule,\n  Number,\n};\n\nstruct
        SharedObjectMailbox {\n  union Value {\n    struct {\n      SharedArrayRawBuffer*
        buffer;\n      size_t length;\n      bool isHugeMemory;  // For a WasmMemory
        tag, otherwise false\n      bool isGrowable;    // For GrowableSharedArrayBuffer,
        otherwise false\n    } sarb;\n    JS::WasmModule* module;\n    double number;\n\n
        \   Value() : number(0.0) {}\n  };\n\n  MailboxTag tag = MailboxTag::Empty;\n
        \ Value val;\n};\n\ntypedef ExclusiveData<SharedObjectMailbox> SOMailbox;\n\n//
        Never null after successful initialization.\nstatic SOMailbox* sharedObjectMailbox;\n\nstatic
        bool InitSharedObjectMailbox() {\n  sharedObjectMailbox = js_new<SOMailbox>(mutexid::ShellObjectMailbox);\n
        \ return sharedObjectMailbox != nullptr;\n}\n\nstatic void DestructSharedObjectMailbox()
        {\n  // All workers need to have terminated at this point.\n\n  {\n    auto
        mbx = sharedObjectMailbox->lock();\n    switch (mbx->tag) {\n      case MailboxTag::Empty:\n
        \     case MailboxTag::Number:\n        break;\n      case MailboxTag::SharedArrayBuffer:\n
        \     case MailboxTag::WasmMemory:\n        mbx->val.sarb.buffer->dropReference();\n
        \       break;\n      case MailboxTag::WasmModule:\n        mbx->val.module->Release();\n
        \       break;\n      default:\n        MOZ_CRASH();\n    }\n  }\n\n  js_delete(sharedObjectMailbox);\n
        \ sharedObjectMailbox = nullptr;\n}\n\nstatic bool GetSharedObject(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ RootedObject newObj(cx);\n\n  {\n    auto mbx = sharedObjectMailbox->lock();\n
        \   switch (mbx->tag) {\n      case MailboxTag::Empty: {\n        break;\n
        \     }\n      case MailboxTag::Number: {\n        args.rval().setNumber(mbx->val.number);\n
        \       return true;\n      }\n      case MailboxTag::SharedArrayBuffer:\n
        \     case MailboxTag::WasmMemory: {\n        // Flag was set in the sender;
        ensure it is set in the receiver.\n        MOZ_ASSERT(\n            cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled());\n\n
        \       // The protocol for creating a SAB requires the refcount to be\n        //
        incremented prior to the SAB creation.\n\n        SharedArrayRawBuffer* buf
        = mbx->val.sarb.buffer;\n        size_t length = mbx->val.sarb.length;\n        if
        (!buf->addReference()) {\n          JS_ReportErrorNumberASCII(cx, GetErrorMessage,
        nullptr,\n                                    JSMSG_SC_SAB_REFCNT_OFLO);\n
        \         return false;\n        }\n\n        // If the allocation fails we
        must decrement the refcount before\n        // returning.\n\n        Rooted<ArrayBufferObjectMaybeShared*>
        maybesab(cx);\n        if (!mbx->val.sarb.isGrowable) {\n          maybesab
        = SharedArrayBufferObject::New(cx, buf, length);\n        } else {\n          maybesab
        = SharedArrayBufferObject::NewGrowable(cx, buf, length);\n        }\n        if
        (!maybesab) {\n          buf->dropReference();\n          return false;\n
        \       }\n\n        // At this point the SAB was created successfully and
        it owns the\n        // refcount-increase on the buffer that we performed
        above.  So even\n        // if we fail to allocate along any path below we
        must not decrement\n        // the refcount; the garbage collector must be
        allowed to handle\n        // that via finalization of the orphaned SAB object.\n\n
        \       if (mbx->tag == MailboxTag::SharedArrayBuffer) {\n          newObj
        = maybesab;\n        } else {\n          if (!GlobalObject::ensureConstructor(cx,
        cx->global(),\n                                               JSProto_WebAssembly))
        {\n            return false;\n          }\n          RootedObject proto(cx,\n
        \                            &cx->global()->getPrototype(JSProto_WasmMemory));\n
        \         newObj = WasmMemoryObject::create(cx, maybesab,\n                                            mbx->val.sarb.isHugeMemory,
        proto);\n          MOZ_ASSERT_IF(newObj, newObj->as<WasmMemoryObject>().isShared());\n
        \         if (!newObj) {\n            return false;\n          }\n        }\n\n
        \       break;\n      }\n      case MailboxTag::WasmModule: {\n        //
        Flag was set in the sender; ensure it is set in the receiver.\n        MOZ_ASSERT(\n
        \           cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled());\n\n
        \       if (!GlobalObject::ensureConstructor(cx, cx->global(),\n                                             JSProto_WebAssembly))
        {\n          return false;\n        }\n\n        // WasmModuleObject::create()
        increments the refcount on the module\n        // and signals an error and
        returns null if that fails.\n        newObj = mbx->val.module->createObject(cx);\n
        \       if (!newObj) {\n          return false;\n        }\n        break;\n
        \     }\n      default: {\n        MOZ_CRASH();\n      }\n    }\n  }\n\n  args.rval().setObjectOrNull(newObj);\n
        \ return true;\n}\n\nstatic bool SetSharedObject(JSContext* cx, unsigned argc,
        Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  MailboxTag
        tag = MailboxTag::Empty;\n  SharedObjectMailbox::Value value;\n\n  // Increase
        refcounts when we obtain the value to avoid operating on dead\n  // storage
        during self-assignment.\n\n  if (args.get(0).isObject()) {\n    RootedObject
        obj(cx, &args[0].toObject());\n    if (obj->is<SharedArrayBufferObject>())
        {\n      Rooted<SharedArrayBufferObject*> sab(cx,\n                                           &obj->as<SharedArrayBufferObject>());\n
        \     tag = MailboxTag::SharedArrayBuffer;\n      value.sarb.buffer = sab->rawBufferObject();\n
        \     value.sarb.length = sab->byteLengthOrMaxByteLength();\n      value.sarb.isHugeMemory
        = false;\n      value.sarb.isGrowable = sab->isGrowable();\n      if (!value.sarb.buffer->addReference())
        {\n        JS_ReportErrorASCII(cx,\n                            \"Reference
        count overflow on SharedArrayBuffer\");\n        return false;\n      }\n
        \   } else if (obj->is<WasmMemoryObject>()) {\n      // Here we must transmit
        sab.byteLength() as the length; the SARB has its\n      // own notion of the
        length which may be greater, and that's fine.\n      if (obj->as<WasmMemoryObject>().isShared())
        {\n        Rooted<SharedArrayBufferObject*> sab(\n            cx, &obj->as<WasmMemoryObject>()\n
        \                    .buffer()\n                     .as<SharedArrayBufferObject>());\n
        \       MOZ_ASSERT(!sab->isGrowable(), \"unexpected growable shared buffer\");\n
        \       tag = MailboxTag::WasmMemory;\n        value.sarb.buffer = sab->rawBufferObject();\n
        \       value.sarb.length = sab->byteLength();\n        value.sarb.isHugeMemory
        = obj->as<WasmMemoryObject>().isHuge();\n        value.sarb.isGrowable = false;\n
        \       if (!value.sarb.buffer->addReference()) {\n          JS_ReportErrorASCII(cx,\n
        \                             \"Reference count overflow on SharedArrayBuffer\");\n
        \         return false;\n        }\n      } else {\n        JS_ReportErrorASCII(cx,
        \"Invalid argument to SetSharedObject\");\n        return false;\n      }\n
        \   } else if (JS::IsWasmModuleObject(obj)) {\n      tag = MailboxTag::WasmModule;\n
        \     value.module = JS::GetWasmModule(obj).forget().take();\n    } else {\n
        \     JS_ReportErrorASCII(cx, \"Invalid argument to SetSharedObject\");\n
        \     return false;\n    }\n  } else if (args.get(0).isNumber()) {\n    tag
        = MailboxTag::Number;\n    value.number = args.get(0).toNumber();\n    //
        Nothing\n  } else if (args.get(0).isNullOrUndefined()) {\n    // Nothing\n
        \ } else {\n    JS_ReportErrorASCII(cx, \"Invalid argument to SetSharedObject\");\n
        \   return false;\n  }\n\n  {\n    auto mbx = sharedObjectMailbox->lock();\n\n
        \   switch (mbx->tag) {\n      case MailboxTag::Empty:\n      case MailboxTag::Number:\n
        \       break;\n      case MailboxTag::SharedArrayBuffer:\n      case MailboxTag::WasmMemory:\n
        \       mbx->val.sarb.buffer->dropReference();\n        break;\n      case
        MailboxTag::WasmModule:\n        mbx->val.module->Release();\n        break;\n
        \     default:\n        MOZ_CRASH();\n    }\n\n    mbx->tag = tag;\n    mbx->val
        = value;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\ntypedef
        Vector<uint8_t, 0, SystemAllocPolicy> Uint8Vector;\n\nclass StreamCacheEntry
        : public AtomicRefCounted<StreamCacheEntry>,\n                         public
        JS::OptimizedEncodingListener {\n  typedef AtomicRefCounted<StreamCacheEntry>
        AtomicBase;\n\n  Uint8Vector bytes_;\n  ExclusiveData<Uint8Vector> optimized_;\n\n
        public:\n  explicit StreamCacheEntry(Uint8Vector&& original)\n      : bytes_(std::move(original)),\n
        \       optimized_(mutexid::ShellStreamCacheEntryState) {}\n\n  // Implement
        JS::OptimizedEncodingListener:\n\n  MozExternalRefCountType MOZ_XPCOM_ABI
        AddRef() override {\n    AtomicBase::AddRef();\n    return 1;  // unused\n
        \ }\n  MozExternalRefCountType MOZ_XPCOM_ABI Release() override {\n    AtomicBase::Release();\n
        \   return 0;  // unused\n  }\n\n  const Uint8Vector& bytes() const { return
        bytes_; }\n\n  void storeOptimizedEncoding(const uint8_t* srcBytes,\n                              size_t
        srcLength) override {\n    MOZ_ASSERT(srcLength > 0);\n\n    // Tolerate races
        since a single StreamCacheEntry object can be used as\n    // the source of
        multiple streaming compilations.\n    auto dstBytes = optimized_.lock();\n
        \   if (dstBytes->length() > 0) {\n      return;\n    }\n\n    if (!dstBytes->resize(srcLength))
        {\n      return;\n    }\n    memcpy(dstBytes->begin(), srcBytes, srcLength);\n
        \ }\n\n  bool hasOptimizedEncoding() const { return !optimized_.lock()->empty();
        }\n  const Uint8Vector& optimizedEncoding() const {\n    return optimized_.lock().get();\n
        \ }\n};\n\ntypedef RefPtr<StreamCacheEntry> StreamCacheEntryPtr;\n\nclass
        StreamCacheEntryObject : public NativeObject {\n  static const unsigned CACHE_ENTRY_SLOT
        = 0;\n  static const JSClassOps classOps_;\n  static const JSPropertySpec
        properties_;\n\n  static void finalize(JS::GCContext* gcx, JSObject* obj)
        {\n    obj->as<StreamCacheEntryObject>().cache().Release();\n  }\n\n  static
        bool cachedGetter(JSContext* cx, unsigned argc, Value* vp) {\n    CallArgs
        args = CallArgsFromVp(argc, vp);\n    if (!args.thisv().isObject() ||\n        !args.thisv().toObject().is<StreamCacheEntryObject>())
        {\n      return false;\n    }\n\n    StreamCacheEntryObject& obj =\n        args.thisv().toObject().as<StreamCacheEntryObject>();\n
        \   args.rval().setBoolean(obj.cache().hasOptimizedEncoding());\n    return
        true;\n  }\n  static bool getBuffer(JSContext* cx, unsigned argc, Value* vp)
        {\n    CallArgs args = CallArgsFromVp(argc, vp);\n    if (!args.thisv().isObject()
        ||\n        !args.thisv().toObject().is<StreamCacheEntryObject>()) {\n      return
        false;\n    }\n\n    auto& bytes =\n        args.thisv().toObject().as<StreamCacheEntryObject>().cache().bytes();\n
        \   auto* buffer = ArrayBufferObject::createZeroed(cx, bytes.length());\n
        \   if (!buffer) {\n      return false;\n    }\n\n    memcpy(buffer->dataPointer(),
        bytes.begin(), bytes.length());\n\n    args.rval().setObject(*buffer);\n    return
        true;\n  }\n\n public:\n  static const unsigned RESERVED_SLOTS = 1;\n  static
        const JSClass class_;\n  static const JSPropertySpec properties[];\n\n  static
        bool construct(JSContext* cx, unsigned argc, Value* vp) {\n    CallArgs args
        = CallArgsFromVp(argc, vp);\n    if (!args.requireAtLeast(cx, \"streamCacheEntry\",
        1)) {\n      return false;\n    }\n\n    SharedMem<uint8_t*> ptr;\n    size_t
        numBytes;\n    if (!args[0].isObject() ||\n        !IsBufferSource(&args[0].toObject(),
        &ptr, &numBytes)) {\n      RootedObject callee(cx, &args.callee());\n      ReportUsageErrorASCII(cx,
        callee, \"Argument must be an ArrayBuffer\");\n      return false;\n    }\n\n
        \   Uint8Vector bytes;\n    if (!bytes.resize(numBytes)) {\n      return false;\n
        \   }\n\n    memcpy(bytes.begin(), ptr.unwrap(), numBytes);\n\n    RefPtr<StreamCacheEntry>
        cache =\n        cx->new_<StreamCacheEntry>(std::move(bytes));\n    if (!cache)
        {\n      return false;\n    }\n\n    Rooted<NativeObject*> obj(\n        cx,
        NewObjectWithGivenProto<StreamCacheEntryObject>(cx, nullptr));\n    if (!obj)
        {\n      return false;\n    }\n    obj->initReservedSlot(CACHE_ENTRY_SLOT,\n
        \                         PrivateValue(cache.forget().take()));\n\n    if
        (!JS_DefineProperty(cx, obj, \"cached\", cachedGetter, nullptr, 0)) {\n      return
        false;\n    }\n    if (!JS_DefineFunction(cx, obj, \"getBuffer\", getBuffer,
        0, 0)) {\n      return false;\n    }\n\n    args.rval().setObject(*obj);\n
        \   return true;\n  }\n\n  StreamCacheEntry& cache() const {\n    return *(StreamCacheEntry*)getReservedSlot(CACHE_ENTRY_SLOT).toPrivate();\n
        \ }\n};\n\nconst JSClassOps StreamCacheEntryObject::classOps_ = {\n    nullptr,
        \                          // addProperty\n    nullptr,                           //
        delProperty\n    nullptr,                           // enumerate\n    nullptr,
        \                          // newEnumerate\n    nullptr,                           //
        resolve\n    nullptr,                           // mayResolve\n    StreamCacheEntryObject::finalize,
        \ // finalize\n    nullptr,                           // call\n    nullptr,
        \                          // construct\n    nullptr,                           //
        trace\n};\n\nconst JSClass StreamCacheEntryObject::class_ = {\n    \"StreamCacheEntryObject\",\n
        \   JSCLASS_HAS_RESERVED_SLOTS(StreamCacheEntryObject::RESERVED_SLOTS) |\n
        \       JSCLASS_BACKGROUND_FINALIZE,\n    &StreamCacheEntryObject::classOps_};\n\nstruct
        BufferStreamJob {\n  Variant<Uint8Vector, StreamCacheEntryPtr> source;\n  Thread
        thread;\n  JS::StreamConsumer* consumer;\n\n  BufferStreamJob(Uint8Vector&&
        source, JS::StreamConsumer* consumer)\n      : source(AsVariant<Uint8Vector>(std::move(source))),
        consumer(consumer) {}\n  BufferStreamJob(StreamCacheEntry& source, JS::StreamConsumer*
        consumer)\n      : source(AsVariant<StreamCacheEntryPtr>(&source)), consumer(consumer)
        {}\n};\n\nstruct BufferStreamState {\n  Vector<UniquePtr<BufferStreamJob>,
        0, SystemAllocPolicy> jobs;\n  size_t delayMillis;\n  size_t chunkSize;\n
        \ bool shutdown;\n\n  BufferStreamState() : delayMillis(1), chunkSize(10),
        shutdown(false) {}\n\n  ~BufferStreamState() { MOZ_ASSERT(jobs.empty()); }\n};\n\nstatic
        ExclusiveWaitableData<BufferStreamState>* bufferStreamState;\n\nstatic void
        BufferStreamMain(BufferStreamJob* job) {\n  const uint8_t* bytes;\n  size_t
        byteLength;\n  JS::OptimizedEncodingListener* listener;\n  if (job->source.is<StreamCacheEntryPtr>())
        {\n    StreamCacheEntry& cache = *job->source.as<StreamCacheEntryPtr>();\n
        \   if (cache.hasOptimizedEncoding()) {\n      const Uint8Vector& optimized
        = cache.optimizedEncoding();\n      job->consumer->consumeOptimizedEncoding(optimized.begin(),\n
        \                                             optimized.length());\n      goto
        done;\n    }\n\n    bytes = cache.bytes().begin();\n    byteLength = cache.bytes().length();\n
        \   listener = &cache;\n  } else {\n    bytes = job->source.as<Uint8Vector>().begin();\n
        \   byteLength = job->source.as<Uint8Vector>().length();\n    listener = nullptr;\n
        \ }\n\n  size_t byteOffset;\n  byteOffset = 0;\n  while (true) {\n    if (byteOffset
        == byteLength) {\n      job->consumer->streamEnd(listener);\n      break;\n
        \   }\n\n    bool shutdown;\n    size_t delayMillis;\n    size_t chunkSize;\n
        \   {\n      auto state = bufferStreamState->lock();\n      shutdown = state->shutdown;\n
        \     delayMillis = state->delayMillis;\n      chunkSize = state->chunkSize;\n
        \   }\n\n    if (shutdown) {\n      job->consumer->streamError(JSMSG_STREAM_CONSUME_ERROR);\n
        \     break;\n    }\n\n    ThisThread::SleepMilliseconds(delayMillis);\n\n
        \   chunkSize = std::min(chunkSize, byteLength - byteOffset);\n\n    if (!job->consumer->consumeChunk(bytes
        + byteOffset, chunkSize)) {\n      break;\n    }\n\n    byteOffset += chunkSize;\n
        \ }\n\ndone:\n  auto state = bufferStreamState->lock();\n  size_t jobIndex
        = 0;\n  while (state->jobs[jobIndex].get() != job) {\n    jobIndex++;\n  }\n
        \ job->thread.detach();  // quiet assert in ~Thread() called by erase().\n
        \ state->jobs.erase(state->jobs.begin() + jobIndex);\n  if (state->jobs.empty())
        {\n    state.notify_all(/* jobs empty */);\n  }\n}\n\nstatic bool ConsumeBufferSource(JSContext*
        cx, JS::HandleObject obj,\n                                JS::MimeType, JS::StreamConsumer*
        consumer) {\n  {\n    RootedValue url(cx);\n    if (!JS_GetProperty(cx, obj,
        \"url\", &url)) {\n      return false;\n    }\n    UniqueChars urlChars;\n
        \   if (url.isString()) {\n      Rooted<JSString*> str(cx, url.toString());\n
        \     urlChars = JS_EncodeStringToUTF8(cx, str);\n      if (!urlChars) {\n
        \       return false;\n      }\n    }\n\n    RootedValue mapUrl(cx);\n    if
        (!JS_GetProperty(cx, obj, \"sourceMappingURL\", &mapUrl)) {\n      return
        false;\n    }\n    UniqueChars mapUrlChars;\n    if (mapUrl.isString()) {\n
        \     Rooted<JSString*> str(cx, mapUrl.toString());\n      mapUrlChars = JS_EncodeStringToUTF8(cx,
        str);\n      if (!mapUrlChars) {\n        return false;\n      }\n    }\n\n
        \   consumer->noteResponseURLs(urlChars.get(), mapUrlChars.get());\n  }\n\n
        \ UniquePtr<BufferStreamJob> job;\n\n  SharedMem<uint8_t*> dataPointer;\n
        \ size_t byteLength;\n  if (IsBufferSource(obj, &dataPointer, &byteLength))
        {\n    Uint8Vector bytes;\n    if (!bytes.resize(byteLength)) {\n      JS_ReportOutOfMemory(cx);\n
        \     return false;\n    }\n\n    memcpy(bytes.begin(), dataPointer.unwrap(),
        byteLength);\n    job = cx->make_unique<BufferStreamJob>(std::move(bytes),
        consumer);\n  } else if (obj->is<StreamCacheEntryObject>()) {\n    job = cx->make_unique<BufferStreamJob>(\n
        \       obj->as<StreamCacheEntryObject>().cache(), consumer);\n  } else {\n
        \   JS_ReportErrorASCII(\n        cx,\n        \"shell streaming consumes
        a buffer source (buffer or view) \"\n        \"or StreamCacheEntryObject\");\n
        \   return false;\n  }\n  if (!job) {\n    return false;\n  }\n\n  BufferStreamJob*
        jobPtr = job.get();\n\n  {\n    auto state = bufferStreamState->lock();\n
        \   MOZ_ASSERT(!state->shutdown);\n    if (!state->jobs.append(std::move(job)))
        {\n      JS_ReportOutOfMemory(cx);\n      return false;\n    }\n  }\n\n  {\n
        \   AutoEnterOOMUnsafeRegion oomUnsafe;\n    if (!jobPtr->thread.init(BufferStreamMain,
        jobPtr)) {\n      oomUnsafe.crash(\"ConsumeBufferSource\");\n    }\n  }\n\n
        \ return true;\n}\n\nstatic void ReportStreamError(JSContext* cx, size_t errorNumber)
        {\n  JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr, errorNumber);\n}\n\nstatic
        bool SetBufferStreamParams(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx, \"setBufferStreamParams\",
        2)) {\n    return false;\n  }\n\n  double delayMillis;\n  if (!ToNumber(cx,
        args[0], &delayMillis)) {\n    return false;\n  }\n\n  double chunkSize;\n
        \ if (!ToNumber(cx, args[1], &chunkSize)) {\n    return false;\n  }\n\n  {\n
        \   auto state = bufferStreamState->lock();\n    state->delayMillis = delayMillis;\n
        \   state->chunkSize = chunkSize;\n  }\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic void ShutdownBufferStreams() {\n  auto state =
        bufferStreamState->lock();\n  state->shutdown = true;\n  while (!state->jobs.empty())
        {\n    state.wait(/* jobs empty */);\n  }\n  state->jobs.clearAndFree();\n}\n\nstatic
        bool DumpScopeChain(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (js::SupportDifferentialTesting()) {\n    ReportUsageErrorASCII(\n        cx,
        callee, \"Function not available in differential testing mode.\");\n    return
        false;\n  }\n\n  if (args.length() != 1) {\n    ReportUsageErrorASCII(cx,
        callee, \"Wrong number of arguments\");\n    return false;\n  }\n\n  if (!args[0].isObject()
        ||\n      !(args[0].toObject().is<JSFunction>() ||\n        args[0].toObject().is<ShellModuleObjectWrapper>()))
        {\n    ReportUsageErrorASCII(\n        cx, callee, \"Argument must be an interpreted
        function or a module\");\n    return false;\n  }\n\n  RootedObject obj(cx,
        &args[0].toObject());\n  RootedScript script(cx);\n\n  if (obj->is<JSFunction>())
        {\n    RootedFunction fun(cx, &obj->as<JSFunction>());\n    if (!fun->isInterpreted())
        {\n      ReportUsageErrorASCII(cx, callee,\n                            \"Argument
        must be an interpreted function\");\n      return false;\n    }\n    script
        = JSFunction::getOrCreateScript(cx, fun);\n    if (!script) {\n      return
        false;\n    }\n  } else {\n    script = obj->as<ShellModuleObjectWrapper>().get()->maybeScript();\n
        \   if (!script) {\n      JS_ReportErrorASCII(cx, \"module does not have an
        associated script\");\n      return false;\n    }\n  }\n\n  script->bodyScope()->dump();\n\n
        \ args.rval().setUndefined();\n  return true;\n}\n\n// For testing GC marking,
        blackRoot() and grayRoot() will heap-allocate an\n// array whose elements
        (as well as the array itself) will be marked as roots in\n// subsequent GCs.\n//\n//
        Note that EnsureGrayRoot() will blacken the returned object, so it will not\n//
        actually end up marked gray until the following GC clears the black bit\n//
        (assuming nothing is holding onto it.)\n//\n// The idea is that you can set
        up a whole graph of objects to be marked gray,\n// hanging off of the object
        returned from grayRoot(). Then you GC to clear the\n// black bits and set
        the gray bits.\n//\n// To test grayness, register the objects of interest
        with addMarkObservers(),\n// which takes an Array of objects (which will be
        marked black at the time\n// they're passed in). Their mark bits may be retrieved
        at any time with\n// getMarks(), in the form of an array of strings with each
        index corresponding\n// to the original objects passed to addMarkObservers().\n\nstatic
        bool EnsureRootArray(JSContext* cx, gc::MarkColor color, unsigned argc,\n
        \                           Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  auto priv = EnsureShellCompartmentPrivate(cx);\n  if (!priv) {\n
        \   return false;\n  }\n\n  GCPtr<ArrayObject*>& root =\n      (color == gc::MarkColor::Black)
        ? priv->blackRoot : priv->grayRoot;\n\n  if (!root && !(root = NewTenuredDenseEmptyArray(cx)))
        {\n    return false;\n  }\n\n  // Barrier to enforce the invariant that JS
        does not touch gray objects.\n  JSObject* obj = root;\n  JS::ExposeObjectToActiveJS(obj);\n\n
        \ args.rval().setObject(*obj);\n  return true;\n}\n\nstatic bool EnsureBlackRoot(JSContext*
        cx, unsigned argc, Value* vp) {\n  return EnsureRootArray(cx, gc::MarkColor::Black,
        argc, vp);\n}\n\nstatic bool EnsureGrayRoot(JSContext* cx, unsigned argc,
        Value* vp) {\n  return EnsureRootArray(cx, gc::MarkColor::Gray, argc, vp);\n}\n\nstatic
        MarkBitObservers* EnsureMarkBitObservers(JSContext* cx) {\n  ShellContext*
        sc = GetShellContext(cx);\n  if (!sc->markObservers) {\n    auto* observers
        =\n        cx->new_<MarkBitObservers>(cx->runtime(), NonshrinkingGCObjectVector());\n
        \   if (!observers) {\n      return nullptr;\n    }\n    sc->markObservers.reset(observers);\n
        \ }\n  return sc->markObservers.get();\n}\n\nstatic bool ClearMarkObservers(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ auto markObservers = EnsureMarkBitObservers(cx);\n  if (!markObservers)
        {\n    return false;\n  }\n\n  markObservers->get().clear();\n\n  args.rval().setUndefined();\n
        \ return true;\n}\n\nstatic bool AddMarkObservers(JSContext* cx, unsigned
        argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  auto
        markObservers = EnsureMarkBitObservers(cx);\n  if (!markObservers) {\n    return
        false;\n  }\n\n  if (!args.get(0).isObject()) {\n    JS_ReportErrorASCII(cx,
        \"argument must be an Array of objects\");\n    return false;\n  }\n\n  RootedObject
        observersArg(cx, &args[0].toObject());\n  uint64_t length;\n  if (!GetLengthProperty(cx,
        observersArg, &length)) {\n    return false;\n  }\n\n  if (length > UINT32_MAX)
        {\n    JS_ReportErrorASCII(cx, \"Invalid length for observers array\");\n
        \   return false;\n  }\n\n  RootedValue value(cx);\n  RootedObject object(cx);\n
        \ for (uint32_t i = 0; i < length; i++) {\n    if (!JS_GetElement(cx, observersArg,
        i, &value)) {\n      return false;\n    }\n\n    if (!value.isObject()) {\n
        \     JS_ReportErrorASCII(cx, \"argument must be an Array of objects\");\n
        \     return false;\n    }\n\n    object = &value.toObject();\n    if (gc::IsInsideNursery(object))
        {\n      // WeakCaches are not swept during a minor GC. To prevent\n      //
        nursery-allocated contents from having the mark bits be deceptively\n      //
        black until the second GC, they would need to be marked weakly (cf\n      //
        NurseryAwareHashMap). It is simpler to evict the nursery to prevent\n      //
        nursery objects from being observed.\n      cx->runtime()->gc.evictNursery();\n
        \   }\n\n    if (!markObservers->get().append(object)) {\n      return false;\n
        \   }\n  }\n\n  args.rval().setInt32(length);\n  return true;\n}\n\nstatic
        bool GetMarks(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n\n  auto& observers = GetShellContext(cx)->markObservers;\n
        \ if (!observers) {\n    args.rval().setUndefined();\n    return true;\n  }\n\n
        \ size_t length = observers->get().length();\n  Rooted<ArrayObject*> ret(cx,
        js::NewDenseEmptyArray(cx));\n  if (!ret) {\n    return false;\n  }\n\n  for
        (uint32_t i = 0; i < length; i++) {\n    const char* color;\n    JSObject*
        obj = observers->get()[i];\n    if (!obj) {\n      color = \"dead\";\n    }
        else if (obj->zone()->isGCPreparing()) {\n      color = \"unmarked\";\n    }
        else {\n      gc::TenuredCell* cell = &obj->asTenured();\n      if (cell->isMarkedGray())
        {\n        color = \"gray\";\n      } else if (cell->isMarkedBlack()) {\n
        \       color = \"black\";\n      } else {\n        color = \"unmarked\";\n
        \     }\n    }\n    JSString* s = JS_NewStringCopyZ(cx, color);\n    if (!s)
        {\n      return false;\n    }\n    if (!NewbornArrayPush(cx, ret, StringValue(s)))
        {\n      return false;\n    }\n  }\n\n  args.rval().setObject(*ret);\n  return
        true;\n}\n\nnamespace js {\nnamespace shell {\n\nclass ShellAutoEntryMonitor
        : JS::dbg::AutoEntryMonitor {\n  Vector<UniqueChars, 1, js::SystemAllocPolicy>
        log;\n  bool oom;\n  bool enteredWithoutExit;\n\n public:\n  explicit ShellAutoEntryMonitor(JSContext*
        cx)\n      : AutoEntryMonitor(cx), oom(false), enteredWithoutExit(false) {}\n\n
        \ ~ShellAutoEntryMonitor() { MOZ_ASSERT(!enteredWithoutExit); }\n\n  void
        Entry(JSContext* cx, JSFunction* function, JS::HandleValue asyncStack,\n             const
        char* asyncCause) override {\n    MOZ_ASSERT(!enteredWithoutExit);\n    enteredWithoutExit
        = true;\n\n    RootedString displayId(cx, JS_GetMaybePartialFunctionDisplayId(function));\n
        \   if (displayId) {\n      UniqueChars displayIdStr = JS_EncodeStringToUTF8(cx,
        displayId);\n      if (!displayIdStr) {\n        // We report OOM in buildResult.\n
        \       cx->recoverFromOutOfMemory();\n        oom = true;\n        return;\n
        \     }\n      oom = !log.append(std::move(displayIdStr));\n      return;\n
        \   }\n\n    oom = !log.append(DuplicateString(\"anonymous\"));\n  }\n\n  void
        Entry(JSContext* cx, JSScript* script, JS::HandleValue asyncStack,\n             const
        char* asyncCause) override {\n    MOZ_ASSERT(!enteredWithoutExit);\n    enteredWithoutExit
        = true;\n\n    UniqueChars label(JS_smprintf(\"eval:%s\", JS_GetScriptFilename(script)));\n
        \   oom = !label || !log.append(std::move(label));\n  }\n\n  void Exit(JSContext*
        cx) override {\n    MOZ_ASSERT(enteredWithoutExit);\n    enteredWithoutExit
        = false;\n  }\n\n  bool buildResult(JSContext* cx, MutableHandleValue resultValue)
        {\n    if (oom) {\n      JS_ReportOutOfMemory(cx);\n      return false;\n
        \   }\n\n    RootedObject result(cx, JS::NewArrayObject(cx, log.length()));\n
        \   if (!result) {\n      return false;\n    }\n\n    for (size_t i = 0; i
        < log.length(); i++) {\n      char* name = log[i].get();\n      RootedString
        string(cx, AtomizeUTF8Chars(cx, name, strlen(name)));\n      if (!string)
        {\n        return false;\n      }\n      RootedValue value(cx, StringValue(string));\n
        \     if (!JS_SetElement(cx, result, i, value)) {\n        return false;\n
        \     }\n    }\n\n    resultValue.setObject(*result.get());\n    return true;\n
        \ }\n};\n\n}  // namespace shell\n}  // namespace js\n\nstatic bool EntryPoints(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ if (args.length() != 1) {\n    JS_ReportErrorASCII(cx, \"Wrong number of
        arguments\");\n    return false;\n  }\n\n  RootedObject opts(cx, ToObject(cx,
        args[0]));\n  if (!opts) {\n    return false;\n  }\n\n  // { function: f }
        --- Call f.\n  {\n    RootedValue fun(cx), dummy(cx);\n\n    if (!JS_GetProperty(cx,
        opts, \"function\", &fun)) {\n      return false;\n    }\n    if (!fun.isUndefined())
        {\n      js::shell::ShellAutoEntryMonitor sarep(cx);\n      if (!Call(cx,
        UndefinedHandleValue, fun, JS::HandleValueArray::empty(),\n                &dummy))
        {\n        return false;\n      }\n      return sarep.buildResult(cx, args.rval());\n
        \   }\n  }\n\n  // { object: o, property: p, value: v } --- Fetch o[p], or
        if\n  // v is present, assign o[p] = v.\n  {\n    RootedValue objectv(cx),
        propv(cx), valuev(cx);\n\n    if (!JS_GetProperty(cx, opts, \"object\", &objectv)
        ||\n        !JS_GetProperty(cx, opts, \"property\", &propv))\n      return
        false;\n    if (!objectv.isUndefined() && !propv.isUndefined()) {\n      RootedObject
        object(cx, ToObject(cx, objectv));\n      if (!object) {\n        return false;\n
        \     }\n\n      RootedString string(cx, ToString(cx, propv));\n      if (!string)
        {\n        return false;\n      }\n      RootedId id(cx);\n      if (!JS_StringToId(cx,
        string, &id)) {\n        return false;\n      }\n\n      if (!JS_GetProperty(cx,
        opts, \"value\", &valuev)) {\n        return false;\n      }\n\n      js::shell::ShellAutoEntryMonitor
        sarep(cx);\n\n      if (!valuev.isUndefined()) {\n        if (!JS_SetPropertyById(cx,
        object, id, valuev)) {\n          return false;\n        }\n      } else {\n
        \       if (!JS_GetPropertyById(cx, object, id, &valuev)) {\n          return
        false;\n        }\n      }\n\n      return sarep.buildResult(cx, args.rval());\n
        \   }\n  }\n\n  // { ToString: v } --- Apply JS::ToString to v.\n  {\n    RootedValue
        v(cx);\n\n    if (!JS_GetProperty(cx, opts, \"ToString\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      js::shell::ShellAutoEntryMonitor
        sarep(cx);\n      if (!JS::ToString(cx, v)) {\n        return false;\n      }\n
        \     return sarep.buildResult(cx, args.rval());\n    }\n  }\n\n  // { ToNumber:
        v } --- Apply JS::ToNumber to v.\n  {\n    RootedValue v(cx);\n    double
        dummy;\n\n    if (!JS_GetProperty(cx, opts, \"ToNumber\", &v)) {\n      return
        false;\n    }\n    if (!v.isUndefined()) {\n      js::shell::ShellAutoEntryMonitor
        sarep(cx);\n      if (!JS::ToNumber(cx, v, &dummy)) {\n        return false;\n
        \     }\n      return sarep.buildResult(cx, args.rval());\n    }\n  }\n\n
        \ // { eval: code } --- Apply ToString and then Evaluate to code.\n  {\n    RootedValue
        code(cx), dummy(cx);\n\n    if (!JS_GetProperty(cx, opts, \"eval\", &code))
        {\n      return false;\n    }\n    if (!code.isUndefined()) {\n      RootedString
        codeString(cx, ToString(cx, code));\n      if (!codeString) {\n        return
        false;\n      }\n\n      AutoStableStringChars linearChars(cx);\n      if
        (!linearChars.initTwoByte(cx, codeString)) {\n        return false;\n      }\n
        \     JS::SourceText<char16_t> srcBuf;\n      if (!srcBuf.initMaybeBorrowed(cx,
        linearChars)) {\n        return false;\n      }\n\n      CompileOptions options(cx);\n
        \     options.setIntroductionType(\"entryPoint eval\")\n          .setFileAndLine(\"entryPoint
        eval\", 1);\n\n      js::shell::ShellAutoEntryMonitor sarep(cx);\n      if
        (!JS::Evaluate(cx, options, srcBuf, &dummy)) {\n        return false;\n      }\n
        \     return sarep.buildResult(cx, args.rval());\n    }\n  }\n\n  JS_ReportErrorASCII(cx,
        \"bad 'params' object\");\n  return false;\n}\n\n#ifndef __wasi__\nstatic
        bool WasmTextToBinary(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (!args.requireAtLeast(cx, \"wasmTextToBinary\", 1)) {\n    return false;\n
        \ }\n\n  if (!args[0].isString()) {\n    ReportUsageErrorASCII(cx, callee,
        \"First argument must be a String\");\n    return false;\n  }\n\n  size_t
        textLen = args[0].toString()->length();\n\n  AutoStableStringChars twoByteChars(cx);\n
        \ if (!twoByteChars.initTwoByte(cx, args[0].toString())) {\n    return false;\n
        \ }\n\n  wasm::Bytes bytes;\n  UniqueChars error;\n  if (!wasm::TextToBinary(twoByteChars.twoByteChars(),
        textLen, &bytes,\n                          &error)) {\n    JS_ReportErrorNumberUTF8(cx,
        GetErrorMessage, nullptr, JSMSG_WASM_TEXT_FAIL,\n                             error.get()
        ? error.get() : \"out of memory\");\n    return false;\n  }\n\n  RootedObject
        binary(cx, JS_NewUint8Array(cx, bytes.length()));\n  if (!binary) {\n    return
        false;\n  }\n\n  memcpy(binary->as<TypedArrayObject>().dataPointerUnshared(),
        bytes.begin(),\n         bytes.length());\n\n  args.rval().setObject(*binary);\n
        \ return true;\n}\n\n#  ifndef __AFL_HAVE_MANUAL_CONTROL\n#    define __AFL_LOOP(x)
        true\n#  endif\n\nstatic bool WasmLoop(JSContext* cx, unsigned argc, Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx,
        &args.callee());\n\n  if (args.length() < 1 || args.length() > 2) {\n    ReportUsageErrorASCII(cx,
        callee, \"Wrong number of arguments\");\n    return false;\n  }\n\n  if (!args[0].isString())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be a String\");\n
        \   return false;\n  }\n\n  RootedObject importObj(cx);\n  if (!args.get(1).isUndefined())
        {\n    if (!args.get(1).isObject()) {\n      ReportUsageErrorASCII(cx, callee,\n
        \                           \"Second argument, if present, must be an Object\");\n
        \     return false;\n    }\n    importObj = &args[1].toObject();\n  }\n\n
        \ RootedString givenPath(cx, args[0].toString());\n  RootedString filename(cx,
        ResolvePath(cx, givenPath, RootRelative));\n  if (!filename) {\n    return
        false;\n  }\n\n  while (__AFL_LOOP(1000)) {\n    Rooted<JSObject*> ret(cx,
        FileAsTypedArray(cx, filename));\n    if (!ret) {\n      return false;\n    }\n\n
        \   Rooted<TypedArrayObject*> typedArray(cx, &ret->as<TypedArrayObject>());\n
        \   Rooted<WasmInstanceObject*> instanceObj(cx);\n    if (!wasm::Eval(cx,
        typedArray, importObj, &instanceObj)) {\n      // Clear any pending exceptions,
        we don't care about them\n      cx->clearPendingException();\n    }\n  }\n\n#
        \ ifdef __AFL_HAVE_MANUAL_CONTROL  // to silence unreachable code warning\n
        \ return true;\n#  endif\n}\n#endif  // __wasi__\n\nstatic constexpr uint32_t
        DOM_OBJECT_SLOT = 0;\nstatic constexpr uint32_t DOM_OBJECT_SLOT2 = 1;\n\nstatic
        const JSClass* GetDomClass();\n\nstatic JSObject* GetDOMPrototype(JSContext*
        cx, JSObject* global);\n\nstatic const JSClass TransplantableDOMObjectClass
        = {\n    \"TransplantableDOMObject\",\n    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)};\n\nstatic
        const JSClass TransplantableDOMProxyObjectClass =\n    PROXY_CLASS_DEF(\"TransplantableDOMProxyObject\",\n
        \                   JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1));\n\nclass
        TransplantableDOMProxyHandler final : public ForwardingProxyHandler {\n public:\n
        \ static const TransplantableDOMProxyHandler singleton;\n  static const char
        family;\n\n  constexpr TransplantableDOMProxyHandler() : ForwardingProxyHandler(&family)
        {}\n\n  // These two proxy traps are called in |js::DeadProxyTargetValue|,
        which in\n  // turn is called when nuking proxies. Because this proxy can
        temporarily be\n  // without an object in its private slot, see |EnsureExpandoObject|,
        the\n  // default implementation inherited from ForwardingProxyHandler can't
        be used,\n  // since it tries to derive the callable/constructible value from
        the target.\n  bool isCallable(JSObject* obj) const override { return false;
        }\n  bool isConstructor(JSObject* obj) const override { return false; }\n\n
        \ // Simplified implementation of |DOMProxyHandler::GetAndClearExpandoObject|.\n
        \ static JSObject* GetAndClearExpandoObject(JSObject* obj) {\n    const Value&
        v = GetProxyPrivate(obj);\n    if (v.isUndefined()) {\n      return nullptr;\n
        \   }\n\n    JSObject* expandoObject = &v.toObject();\n    SetProxyPrivate(obj,
        UndefinedValue());\n    return expandoObject;\n  }\n\n  // Simplified implementation
        of |DOMProxyHandler::EnsureExpandoObject|.\n  static JSObject* EnsureExpandoObject(JSContext*
        cx, JS::HandleObject obj) {\n    const Value& v = GetProxyPrivate(obj);\n
        \   if (v.isObject()) {\n      return &v.toObject();\n    }\n    MOZ_ASSERT(v.isUndefined());\n\n
        \   JSObject* expando = JS_NewObjectWithGivenProto(cx, nullptr, nullptr);\n
        \   if (!expando) {\n      return nullptr;\n    }\n    SetProxyPrivate(obj,
        ObjectValue(*expando));\n    return expando;\n  }\n};\n\nconst TransplantableDOMProxyHandler
        TransplantableDOMProxyHandler::singleton;\nconst char TransplantableDOMProxyHandler::family
        = 0;\n\nenum TransplantObjectSlots {\n  TransplantSourceObject = 0,\n};\n\nstatic
        bool TransplantObject(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedFunction callee(cx, &args.callee().as<JSFunction>());\n\n
        \ if (args.length() != 1 || !args[0].isObject()) {\n    JS_ReportErrorASCII(cx,
        \"transplant() must be called with an object\");\n    return false;\n  }\n\n
        \ // |newGlobal| needs to be a GlobalObject.\n  RootedObject newGlobal(\n
        \     cx, js::CheckedUnwrapDynamic(&args[0].toObject(), cx,\n                                   /*
        stopAtWindowProxy = */ false));\n  if (!newGlobal) {\n    ReportAccessDenied(cx);\n
        \   return false;\n  }\n  if (!JS_IsGlobalObject(newGlobal)) {\n    JS_ReportErrorNumberASCII(\n
        \       cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,\n        \"\\\"global\\\"
        passed to transplant()\", \"not a global object\");\n    return false;\n  }\n\n
        \ const Value& reserved =\n      GetFunctionNativeReserved(callee, TransplantSourceObject);\n
        \ RootedObject source(cx, CheckedUnwrapStatic(&reserved.toObject()));\n  if
        (!source) {\n    ReportAccessDenied(cx);\n    return false;\n  }\n  if (JS_IsDeadWrapper(source))
        {\n    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_DEAD_OBJECT);\n
        \   return false;\n  }\n  MOZ_ASSERT(source->getClass()->isDOMClass());\n\n
        \ // The following steps aim to replicate the behavior of UpdateReflectorGlobal\n
        \ // in dom/bindings/BindingUtils.cpp. In detail:\n  // 1. Check the recursion
        depth using checkConservative.\n  // 2. Enter the target compartment.\n  //
        3. Clone the source object using JS_CloneObject.\n  // 4. Check if new wrappers
        can be created if source and target are in\n  //    different compartments.\n
        \ // 5. Copy all properties from source to a temporary holder object.\n  //
        6. Actually transplant the object.\n  // 7. And finally copy the properties
        back to the source object.\n  //\n  // As an extension to the algorithm in
        UpdateReflectorGlobal, we also allow\n  // to transplant an object into the
        same compartment as the source object to\n  // cover all operations supported
        by JS_TransplantObject.\n\n  AutoCheckRecursionLimit recursion(cx);\n  if
        (!recursion.checkConservative(cx)) {\n    return false;\n  }\n\n  bool isProxy
        = IsProxy(source);\n  RootedObject expandoObject(cx);\n  if (isProxy) {\n
        \   expandoObject =\n        TransplantableDOMProxyHandler::GetAndClearExpandoObject(source);\n
        \ }\n\n  JSAutoRealm ar(cx, newGlobal);\n\n  RootedObject proto(cx);\n  if
        (JS::GetClass(source) == GetDomClass()) {\n    proto = GetDOMPrototype(cx,
        newGlobal);\n  } else {\n    proto = JS::GetRealmObjectPrototype(cx);\n  }\n
        \ if (!proto) {\n    return false;\n  }\n\n  RootedObject target(cx, JS_CloneObject(cx,
        source, proto));\n  if (!target) {\n    return false;\n  }\n\n  if (JS::GetCompartment(source)
        != JS::GetCompartment(target) &&\n      !AllowNewWrapper(JS::GetCompartment(source),
        target)) {\n    JS_ReportErrorASCII(cx, \"Cannot transplant into nuked compartment\");\n
        \   return false;\n  }\n\n  RootedObject copyFrom(cx, isProxy ? expandoObject
        : source);\n  RootedObject propertyHolder(cx,\n                              JS_NewObjectWithGivenProto(cx,
        nullptr, nullptr));\n  if (!propertyHolder) {\n    return false;\n  }\n\n
        \ if (!JS_CopyOwnPropertiesAndPrivateFields(cx, propertyHolder, copyFrom))
        {\n    return false;\n  }\n\n  JS::SetReservedSlot(target, DOM_OBJECT_SLOT,\n
        \                     JS::GetReservedSlot(source, DOM_OBJECT_SLOT));\n  JS::SetReservedSlot(source,
        DOM_OBJECT_SLOT, JS::PrivateValue(nullptr));\n  if (JS::GetClass(source) ==
        GetDomClass()) {\n    JS::SetReservedSlot(target, DOM_OBJECT_SLOT2,\n                        JS::GetReservedSlot(source,
        DOM_OBJECT_SLOT2));\n    JS::SetReservedSlot(source, DOM_OBJECT_SLOT2, UndefinedValue());\n
        \ }\n\n  source = JS_TransplantObject(cx, source, target);\n  if (!source)
        {\n    return false;\n  }\n\n  RootedObject copyTo(cx);\n  if (isProxy) {\n
        \   copyTo = TransplantableDOMProxyHandler::EnsureExpandoObject(cx, source);\n
        \   if (!copyTo) {\n      return false;\n    }\n  } else {\n    copyTo = source;\n
        \ }\n  if (!JS_CopyOwnPropertiesAndPrivateFields(cx, copyTo, propertyHolder))
        {\n    return false;\n  }\n\n  args.rval().setUndefined();\n  return true;\n}\n\nstatic
        bool TransplantableObject(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (args.length() > 1) {\n    ReportUsageErrorASCII(cx, callee, \"Wrong
        number of arguments\");\n    return false;\n  }\n\n  bool createProxy = false;\n
        \ RootedObject source(cx);\n  if (args.length() == 1 && !args[0].isUndefined())
        {\n    if (!args[0].isObject()) {\n      ReportUsageErrorASCII(cx, callee,
        \"Argument must be an object\");\n      return false;\n    }\n\n    RootedObject
        options(cx, &args[0].toObject());\n    RootedValue value(cx);\n\n    if (!JS_GetProperty(cx,
        options, \"proxy\", &value)) {\n      return false;\n    }\n    createProxy
        = JS::ToBoolean(value);\n\n    if (!JS_GetProperty(cx, options, \"object\",
        &value)) {\n      return false;\n    }\n    if (!value.isUndefined()) {\n
        \     if (!value.isObject()) {\n        ReportUsageErrorASCII(cx, callee,
        \"'object' option must be an object\");\n        return false;\n      }\n\n
        \     source = &value.toObject();\n      if (JS::GetClass(source) != GetDomClass())
        {\n        ReportUsageErrorASCII(cx, callee, \"Object not a FakeDOMObject\");\n
        \       return false;\n      }\n\n      // |source| must be a tenured object
        to be transplantable.\n      if (gc::IsInsideNursery(source)) {\n        JS_GC(cx);\n\n
        \       MOZ_ASSERT(!gc::IsInsideNursery(source),\n                   \"Live
        objects should be tenured after one GC, because \"\n                   \"the
        nursery has only a single generation\");\n      }\n    }\n  }\n\n  if (!source)
        {\n    if (!createProxy) {\n      source = NewBuiltinClassInstance(cx, &TransplantableDOMObjectClass,\n
        \                                      TenuredObject);\n      if (!source)
        {\n        return false;\n      }\n\n      JS::SetReservedSlot(source, DOM_OBJECT_SLOT,
        JS::PrivateValue(nullptr));\n    } else {\n      JSObject* expando = JS_NewPlainObject(cx);\n
        \     if (!expando) {\n        return false;\n      }\n      RootedValue expandoVal(cx,
        ObjectValue(*expando));\n\n      ProxyOptions options;\n      options.setClass(&TransplantableDOMProxyObjectClass);\n
        \     options.setLazyProto(true);\n\n      source = NewProxyObject(cx, &TransplantableDOMProxyHandler::singleton,\n
        \                             expandoVal, nullptr, options);\n      if (!source)
        {\n        return false;\n      }\n\n      SetProxyReservedSlot(source, DOM_OBJECT_SLOT,
        JS::PrivateValue(nullptr));\n    }\n  }\n\n  jsid emptyId = NameToId(cx->names().empty_);\n
        \ RootedObject transplant(\n      cx, NewFunctionByIdWithReserved(cx, TransplantObject,
        0, 0, emptyId));\n  if (!transplant) {\n    return false;\n  }\n\n  SetFunctionNativeReserved(transplant,
        TransplantSourceObject,\n                            ObjectValue(*source));\n\n
        \ RootedObject result(cx, JS_NewPlainObject(cx));\n  if (!result) {\n    return
        false;\n  }\n\n  RootedValue sourceVal(cx, ObjectValue(*source));\n  RootedValue
        transplantVal(cx, ObjectValue(*transplant));\n  if (!JS_DefineProperty(cx,
        result, \"object\", sourceVal, 0) ||\n      !JS_DefineProperty(cx, result,
        \"transplant\", transplantVal, 0)) {\n    return false;\n  }\n\n  args.rval().setObject(*result);\n
        \ return true;\n}\n\n#ifdef DEBUG\nstatic bool DebugGetQueuedJobs(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n
        \ JSObject* jobs = js::GetJobsInInternalJobQueue(cx);\n  if (!jobs) {\n    return
        false;\n  }\n\n  args.rval().setObject(*jobs);\n  return true;\n}\n#endif\n\n#ifdef
        FUZZING_INTERFACES\nextern \"C\" {\nsize_t gluesmith(uint8_t* data, size_t
        size, uint8_t* out, size_t maxsize);\n}\n\nstatic bool GetWasmSmithModule(JSContext*
        cx, unsigned argc, Value* vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n
        \ RootedObject callee(cx, &args.callee());\n\n  if (args.length() != 1) {\n
        \   ReportUsageErrorASCII(cx, callee, \"Wrong number of arguments\");\n    return
        false;\n  }\n\n  if (!args[0].isObject() || !args[0].toObject().is<ArrayBufferObject>())
        {\n    ReportUsageErrorASCII(cx, callee, \"Argument must be ArrayBuffer.\");\n
        \   return false;\n  }\n\n  ArrayBufferObject* arrayBuffer = &args[0].toObject().as<ArrayBufferObject>();\n
        \ size_t length = arrayBuffer->byteLength();\n  uint8_t* data = arrayBuffer->dataPointer();\n\n
        \ const size_t maxModuleSize = 4096;\n  uint8_t tmp[maxModuleSize];\n\n  size_t
        outSize = gluesmith(data, length, tmp, maxModuleSize);\n  if (!outSize) {\n
        \   JS_ReportErrorASCII(cx, \"Generated module is too large.\");\n    return
        false;\n  }\n\n  JS::Rooted<JSObject*> outArr(cx, JS_NewUint8ClampedArray(cx,
        outSize));\n  if (!outArr) {\n    return false;\n  }\n\n  {\n    JS::AutoCheckCannotGC
        nogc;\n    bool isShared;\n    uint8_t* data = JS_GetUint8ClampedArrayData(outArr,
        &isShared, nogc);\n    MOZ_RELEASE_ASSERT(!isShared);\n    memcpy(data, tmp,
        outSize);\n  }\n\n  args.rval().setObject(*outArr);\n  return true;\n}\n\n#endif\n\nstatic
        bool IsValidJSON(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (!args.get(0).isString()) {\n    ReportUsageErrorASCII(cx, callee, \"First
        argument must be a String\");\n    return false;\n  }\n\n  JS::Rooted<JSLinearString*>
        input(cx, args[0].toString()->ensureLinear(cx));\n  if (!input) {\n    return
        false;\n  }\n\n  bool result;\n  if (input->hasLatin1Chars()) {\n    JS::AutoCheckCannotGC
        nogc;\n    result = JS::IsValidJSON(input->latin1Chars(nogc), input->length());\n
        \ } else {\n    JS::AutoCheckCannotGC nogc;\n    result = JS::IsValidJSON(input->twoByteChars(nogc),
        input->length());\n  }\n\n  args.rval().setBoolean(result);\n  return true;\n}\n\n//
        Quick file format for a LZ4 compressed file\nstatic constexpr uint32_t LZ4MagicHeader
        = -1;\n// A magic word and a length field\nstatic constexpr size_t LZ4HeaderSize
        = sizeof(uint32_t) * 2;\nstatic constexpr size_t LZ4MaxSize = UINT32_MAX;\n\nstatic
        bool CompressLZ4(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs args
        = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (!args.get(0).isObject() ||\n      !args.get(0).toObject().is<ArrayBufferObject>())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be an ArrayBuffer\");\n
        \   return false;\n  }\n\n  JS::Rooted<ArrayBufferObject*> bytes(\n      cx,
        &args.get(0).toObject().as<ArrayBufferObject>());\n  size_t byteLength = bytes->byteLength();\n
        \ if (byteLength > LZ4MaxSize) {\n    ReportOutOfMemory(cx);\n    return false;\n
        \ }\n\n  // Create a buffer big enough for the header and the max amount of
        compressed\n  // bytes.\n  size_t outputCapacity =\n      LZ4HeaderSize +
        mozilla::Compression::LZ4::maxCompressedSize(byteLength);\n\n  mozilla::UniquePtr<void,
        JS::FreePolicy> output(js_malloc(outputCapacity));\n  if (!output) {\n    ReportOutOfMemory(cx);\n
        \   return false;\n  }\n\n  // Write the magic header word and decompressed
        size in bytes.\n  ((uint32_t*)(output.get()))[0] = LZ4MagicHeader;\n  ((uint32_t*)(output.get()))[1]
        = byteLength;\n\n  // Compress the bytes into the output\n  char* compressedBytesStart
        = ((char*)output.get()) + LZ4HeaderSize;\n  size_t compressedBytesLength =
        mozilla::Compression::LZ4::compress(\n      (const char*)bytes->dataPointer(),
        byteLength, compressedBytesStart);\n  size_t outputLength = compressedBytesLength
        + LZ4HeaderSize;\n\n  // Create an ArrayBuffer wrapping the compressed bytes\n
        \ JSObject* outputArrayBuffer =\n      NewArrayBufferWithContents(cx, outputLength,
        std::move(output));\n  if (!outputArrayBuffer) {\n    return false;\n  }\n\n
        \ args.rval().setObject(*outputArrayBuffer);\n  return true;\n}\n\nstatic
        bool DecompressLZ4(JSContext* cx, unsigned argc, Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n  RootedObject callee(cx, &args.callee());\n\n
        \ if (!args.get(0).isObject() ||\n      !args.get(0).toObject().is<ArrayBufferObject>())
        {\n    ReportUsageErrorASCII(cx, callee, \"First argument must be an ArrayBuffer\");\n
        \   return false;\n  }\n\n  JS::Rooted<ArrayBufferObject*> bytes(\n      cx,
        &args.get(0).toObject().as<ArrayBufferObject>());\n  size_t byteLength = bytes->byteLength();\n
        \ if (byteLength < LZ4HeaderSize) {\n    JS_ReportErrorASCII(cx, \"Invalid
        LZ4 buffer\");\n    return false;\n  }\n\n  // Check the magic header and
        get the decompressed byte length.\n  uint32_t magicHeader = ((uint32_t*)(bytes->dataPointer()))[0];\n
        \ uint32_t decompressedBytesLength = ((uint32_t*)(bytes->dataPointer()))[1];\n
        \ if (magicHeader != LZ4MagicHeader) {\n    JS_ReportErrorASCII(cx, \"Invalid
        magic header\");\n    return false;\n  }\n\n  // Allocate a buffer to store
        the decompressed bytes.\n  mozilla::UniquePtr<void, JS::FreePolicy> decompressedBytes(\n
        \     js_malloc(decompressedBytesLength));\n  if (!decompressedBytes) {\n
        \   ReportOutOfMemory(cx);\n    return false;\n  }\n\n  // Decompress the
        bytes into the output\n  const char* compressedBytesStart =\n      ((const
        char*)bytes->dataPointer()) + LZ4HeaderSize;\n  size_t compressedBytesLength
        = byteLength - LZ4HeaderSize;\n  size_t actualDecompressedBytesLength = 0;\n
        \ if (!mozilla::Compression::LZ4::decompress(\n          compressedBytesStart,
        compressedBytesLength,\n          (char*)decompressedBytes.get(), decompressedBytesLength,\n
        \         &actualDecompressedBytesLength) ||\n      actualDecompressedBytesLength
        != decompressedBytesLength) {\n    JS_ReportErrorASCII(cx, \"Invalid LZ4 buffer\");\n
        \   return false;\n  }\n\n  // Create an ArrayBuffer wrapping the decompressed
        bytes\n  JSObject* outputArrayBuffer = NewArrayBufferWithContents(\n      cx,
        decompressedBytesLength, std::move(decompressedBytes));\n  if (!outputArrayBuffer)
        {\n    return false;\n  }\n\n  args.rval().setObject(*outputArrayBuffer);\n
        \ return true;\n}\n\nstatic bool SideEffectfulResolveObject_enumerate(\n    JSContext*
        cx, JS::HandleObject obj, JS::MutableHandleIdVector properties,\n    bool
        enumerableOnly) {\n  return properties.append(NameToId(cx->names().test));\n}\n\nstatic
        bool SideEffectfulResolveObject_resolve(JSContext* cx, HandleObject obj,\n
        \                                              HandleId id, bool* resolvedp)
        {\n  *resolvedp = false;\n  if (JS::dbg::ShouldAvoidSideEffects(cx)) {\n    return
        false;\n  }\n\n  if (id == NameToId(cx->names().test)) {\n    RootedValue
        value(cx, JS::NumberValue(42));\n    if (!JS_DefinePropertyById(cx, obj, id,
        value, JSPROP_ENUMERATE)) {\n      return false;\n    }\n    *resolvedp =
        true;\n  }\n\n  return true;\n}\n\nstatic const JSClassOps SideEffectfulResolveObject_classOps
        = {\n    nullptr,                               // addProperty\n    nullptr,
        \                              // delProperty\n    nullptr,                               //
        enumerate\n    SideEffectfulResolveObject_enumerate,  // newEnumerate\n    SideEffectfulResolveObject_resolve,
        \   // resolve\n    nullptr,                               // mayResolve\n
        \   nullptr,                               // finalize\n    nullptr,                               //
        call\n    nullptr,                               // construct\n    nullptr,\n};\n\nstatic
        const JSClass SideEffectfulResolveObject_class = {\n    \"SideEffectfulResolveObject\",
        0, &SideEffectfulResolveObject_classOps};\n\nstatic bool CreateSideEffectfulResolveObject(JSContext*
        cx, unsigned argc,\n                                             JS::Value*
        vp) {\n  CallArgs args = CallArgsFromVp(argc, vp);\n\n  RootedObject obj(cx,
        JS_NewObject(cx, &SideEffectfulResolveObject_class));\n  if (!obj) {\n    return
        false;\n  }\n\n  args.rval().setObject(*obj);\n  return true;\n}\n\n// clang-format
        off\nstatic const JSFunctionSpecWithHelp shell_functions[] = {\n    JS_FN_HELP(\"options\",
        Options, 0, 0,\n\"options([option ...])\",\n\"  Get or toggle JavaScript options.\"),\n\n
        \   JS_FN_HELP(\"load\", Load, 1, 0,\n\"load(['foo.js' ...])\",\n\"  Load
        files named by string arguments. Filename is relative to the\\n\"\n\"      current
        working directory.\"),\n\n    JS_FN_HELP(\"loadRelativeToScript\", LoadScriptRelativeToScript,
        1, 0,\n\"loadRelativeToScript(['foo.js' ...])\",\n\"  Load files named by
        string arguments. Filename is relative to the\\n\"\n\"      calling script.\"),\n\n
        \   JS_FN_HELP(\"evaluate\", Evaluate, 2, 0,\n\"evaluate(code[, options])\",\n\"
        \ Evaluate code as though it were the contents of a file.\\n\"\n\"  options
        is an optional object that may have these properties:\\n\"\n\"      isRunOnce:
        use the isRunOnce compiler option (default: false)\\n\"\n\"      noScriptRval:
        use the no-script-rval compiler option (default: false)\\n\"\n\"      fileName:
        filename for error messages and debug info\\n\"\n\"      skipFileNameValidation:
        skip the filename-validation callback\\n\"\n\"      lineNumber: starting line
        number for error messages and debug info\\n\"\n\"      columnNumber: starting
        column number for error messages and debug info\\n\"\n\"      global: global
        in which to execute the code\\n\"\n\"      newContext: if true, create and
        use a new cx (default: false)\\n\"\n\"      catchTermination: if true, catch
        termination (failure without\\n\"\n\"         an exception value, as for slow
        scripts or out-of-memory)\\n\"\n\"         and return 'terminated'\\n\"\n\"
        \     element: if present with value |v|, convert |v| to an object |o| and\\n\"\n\"
        \        mark the source as being attached to the DOM element |o|. If the\\n\"\n\"
        \        property is omitted or |v| is null, don't attribute the source to\\n\"\n\"
        \        any DOM element.\\n\"\n\"      elementAttributeName: if present and
        not undefined, the name of\\n\"\n\"         property of 'element' that holds
        this code. This is what\\n\"\n\"         Debugger.Source.prototype.elementAttributeName
        returns.\\n\"\n\"      sourceMapURL: if present with value |v|, convert |v|
        to a string, and\\n\"\n\"         provide that as the code's source map URL.
        If omitted, attach no\\n\"\n\"         source map URL to the code (although
        the code may provide one itself,\\n\"\n\"         via a //#sourceMappingURL
        comment).\\n\"\n\"      sourceIsLazy: if present and true, indicates that,
        after compilation, \\n\"\n\"          script source should not be cached by
        the JS engine and should be \\n\"\n\"          lazily loaded from the embedding
        as-needed.\\n\"\n\"      forceFullParse: if present and true, disable syntax-parse.\\n\"\n\"
        \     loadBytecode: if true, and if the source is a CacheEntryObject,\\n\"\n\"
        \        the bytecode would be loaded and decoded from the cache entry instead\\n\"\n\"
        \        of being parsed, then it would be executed as usual.\\n\"\n\"      saveIncrementalBytecode:
        if true, and if the source is a\\n\"\n\"         CacheEntryObject, the bytecode
        would be incrementally encoded and\\n\"\n\"         saved into the cache entry.\\n\"\n\"
        \     execute: if false, do not execute the script, but do parse and/or\\n\"\n\"
        \              transcode.\\n\"\n\"      assertEqBytecode: if true, and if
        both loadBytecode and either\\n\"\n\"         saveIncrementalBytecode is true,
        then the loaded\\n\"\n\"         bytecode and the encoded bytecode are compared.\\n\"\n\"
        \        and an assertion is raised if they differ.\\n\"\n\"      envChainObject:
        object to put on the scope chain, with its fields added\\n\"\n\"         as
        var bindings, akin to how elements are added to the environment in\\n\"\n\"
        \        event handlers in Gecko.\\n\"\n),\n\n    JS_FN_HELP(\"run\", Run,
        1, 0,\n\"run('foo.js')\",\n\"  Run the file named by the first argument, returning
        the number of\\n\"\n\"  of milliseconds spent compiling and executing it.\"),\n\n
        \   JS_FN_HELP(\"readline\", ReadLine, 0, 0,\n\"readline()\",\n\"  Read a
        single line from stdin.\"),\n\n    JS_FN_HELP(\"readlineBuf\", ReadLineBuf,
        1, 0,\n\"readlineBuf([ buf ])\",\n\"  Emulate readline() on the specified
        string. The first call with a string\\n\"\n\"  argument sets the source buffer.
        Subsequent calls without an argument\\n\"\n\"  then read from this buffer
        line by line.\\n\"),\n\n    JS_FN_HELP(\"print\", Print, 0, 0,\n\"print([exp
        ...])\",\n\"  Evaluate and print expressions to stdout.\"),\n\n    JS_FN_HELP(\"printErr\",
        PrintErr, 0, 0,\n\"printErr([exp ...])\",\n\"  Evaluate and print expressions
        to stderr.\"),\n\n    JS_FN_HELP(\"putstr\", PutStr, 0, 0,\n\"putstr([exp])\",\n\"
        \ Evaluate and print expression without newline.\"),\n\n    JS_FN_HELP(\"dateNow\",
        Now, 0, 0,\n\"dateNow()\",\n\"  Return the current time with sub-ms precision.\"),\n\n
        \   JS_FN_HELP(\"help\", Help, 0, 0,\n\"help([function or interface object
        or /pattern/])\",\n\"  Display usage and help messages.\"),\n\n    JS_FN_HELP(\"quit\",
        Quit, 0, 0,\n\"quit()\",\n\"  Quit the shell.\"),\n\n    JS_FN_HELP(\"assertEq\",
        AssertEq, 2, 0,\n\"assertEq(actual, expected[, msg])\",\n\"  Throw if the
        first two arguments are not the same (both +0 or both -0,\\n\"\n\"  both NaN,
        or non-zero and ===).\"),\n\n    JS_FN_HELP(\"startTimingMutator\", StartTimingMutator,
        0, 0,\n\"startTimingMutator()\",\n\"  Start accounting time to mutator vs
        GC.\"),\n\n    JS_FN_HELP(\"stopTimingMutator\", StopTimingMutator, 0, 0,\n\"stopTimingMutator()\",\n\"
        \ Stop accounting time to mutator vs GC and dump the results.\"),\n\n    JS_FN_HELP(\"throwError\",
        ThrowError, 0, 0,\n\"throwError()\",\n\"  Throw an error from JS_ReportError.\"),\n\n
        \   JS_FN_HELP(\"createErrorReport\", CreateErrorReport, 1, 0,\n\"createErrorReport(value)\",\n\"
        \ Create an JS::ErrorReportBuilder object from the given value and serialize\\n\"\n\"
        \ to an object.\"),\n\n#if defined(DEBUG) || defined(JS_JITSPEW)\n    JS_FN_HELP(\"disassemble\",
        DisassembleToString, 1, 0,\n\"disassemble([fun/code])\",\n\"  Return the disassembly
        for the given function or code.\\n\"\n\"  All disassembly functions take these
        options as leading string arguments:\\n\"\n\"    \\\"-r\\\" (disassemble recursively)\\n\"\n\"
        \   \\\"-l\\\" (show line numbers)\\n\"\n\"    \\\"-S\\\" (omit source notes)\"),\n\n
        \   JS_FN_HELP(\"dis\", Disassemble, 1, 0,\n\"dis([fun/code])\",\n\"  Disassemble
        functions into bytecodes.\"),\n\n    JS_FN_HELP(\"disfile\", DisassFile, 1,
        0,\n\"disfile('foo.js')\",\n\"  Disassemble script file into bytecodes.\\n\"),\n\n
        \   JS_FN_HELP(\"dissrc\", DisassWithSrc, 1, 0,\n\"dissrc([fun/code])\",\n\"
        \ Disassemble functions with source lines.\"),\n\n    JS_FN_HELP(\"notes\",
        Notes, 1, 0,\n\"notes([fun])\",\n\"  Show source notes for functions.\"),\n\n
        \   JS_FN_HELP(\"stackDump\", StackDump, 3, 0,\n\"stackDump(showArgs, showLocals,
        showThisProps)\",\n\"  Tries to print a lot of information about the current
        stack. \\n\"\n\"  Similar to the DumpJSStack() function in the browser.\"),\n\n#endif\n\n
        \   JS_FN_HELP(\"getslx\", GetSLX, 1, 0,\n\"getslx(obj)\",\n\"  Get script
        line extent.\"),\n\n    JS_FN_HELP(\"evalcx\", EvalInContext, 1, 0,\n\"evalcx(s[,
        o])\",\n\"  Evaluate s in optional sandbox object o.\\n\"\n\"  if (s == ''
        && !o) return new o with eager standard classes\\n\"\n\"  if (s == 'lazy'
        && !o) return new o with lazy standard classes\"),\n\n    JS_FN_HELP(\"evalInWorker\",
        EvalInWorker, 1, 0,\n\"evalInWorker(str)\",\n\"  Evaluate 'str' in a separate
        thread with its own runtime.\\n\"),\n\n    JS_FN_HELP(\"getSharedObject\",
        GetSharedObject, 0, 0,\n\"getSharedObject()\",\n\"  Retrieve the shared object
        from the cross-worker mailbox.\\n\"\n\"  The object retrieved may not be identical
        to the object that was\\n\"\n\"  installed, but it references the same shared
        memory.\\n\"\n\"  getSharedObject performs an ordering memory barrier.\\n\"),\n\n
        \   JS_FN_HELP(\"setSharedObject\", SetSharedObject, 0, 0,\n\"setSharedObject(obj)\",\n\"
        \ Install the shared object in the cross-worker mailbox.  The object\\n\"\n\"
        \ may be null.  setSharedObject performs an ordering memory barrier.\\n\"),\n\n
        \   JS_FN_HELP(\"getSharedArrayBuffer\", GetSharedObject, 0, 0,\n\"getSharedArrayBuffer()\",\n\"
        \ Obsolete alias for getSharedObject().\\n\"),\n\n    JS_FN_HELP(\"setSharedArrayBuffer\",
        SetSharedObject, 0, 0,\n\"setSharedArrayBuffer(obj)\",\n\"  Obsolete alias
        for setSharedObject(obj).\\n\"),\n\n    JS_FN_HELP(\"shapeOf\", ShapeOf, 1,
        0,\n\"shapeOf(obj)\",\n\"  Get the shape of obj (an implementation detail).\"),\n\n#ifdef
        DEBUG\n    JS_FN_HELP(\"arrayInfo\", ArrayInfo, 1, 0,\n\"arrayInfo(a1, a2,
        ...)\",\n\"  Report statistics about arrays.\"),\n#endif\n\n    JS_FN_HELP(\"sleep\",
        Sleep_fn, 1, 0,\n\"sleep(dt)\",\n\"  Sleep for dt seconds.\"),\n\n    JS_FN_HELP(\"parseModule\",
        ParseModule, 1, 0,\n\"parseModule(code)\",\n\"  Parses source text as a module
        and returns a ModuleObject wrapper object.\"),\n\n    JS_FN_HELP(\"instantiateModuleStencil\",
        InstantiateModuleStencil, 1, 0,\n\"instantiateModuleStencil(stencil, [options])\",\n\"
        \ Instantiates the given stencil as module, and return the module object.\"),\n\n
        \   JS_FN_HELP(\"instantiateModuleStencilXDR\", InstantiateModuleStencilXDR,
        1, 0,\n\"instantiateModuleStencilXDR(stencil, [options])\",\n\"  Reads the
        given stencil XDR object, instantiates the stencil as module, and\"\n\"  return
        the module object.\"),\n\n    JS_FN_HELP(\"registerModule\", RegisterModule,
        2, 0,\n\"registerModule(specifier, module)\",\n\"  Register a module with
        the module loader, so that subsequent import from\\n\"\n\"  |specifier| will
        resolve to |module|.  Returns |module|.\"),\n\n    JS_FN_HELP(\"clearModules\",
        ClearModules, 0, 0,\n\"clearModules()\",\n\"  Clear knowledge of all loaded
        modules.\"),\n\n    JS_FN_HELP(\"moduleLink\", ModuleLink, 1, 0,\n\"moduleLink(moduleOjbect)\",\n\"
        \ Link a module graph, performing the spec's Link method.\"),\n\n    JS_FN_HELP(\"moduleEvaluate\",
        ModuleEvaluate, 1, 0,\n\"moduleEvaluate(moduleOjbect)\",\n\"  Evaluate a module
        graph, performing the spec's Evaluate method.\"),\n\n    JS_FN_HELP(\"getModuleEnvironmentNames\",
        GetModuleEnvironmentNames, 1, 0,\n\"getModuleEnvironmentNames(module)\",\n\"
        \ Get the list of a module environment's bound names for a specified module.\\n\"),\n\n
        \   JS_FN_HELP(\"getModuleEnvironmentValue\", GetModuleEnvironmentValue, 2,
        0,\n\"getModuleEnvironmentValue(module, name)\",\n\"  Get the value of a bound
        name in a module environment.\\n\"),\n\n    JS_FN_HELP(\"dumpStencil\", DumpStencil,
        1, 0,\n\"dumpStencil(code, [options])\",\n\"  Parses a string and returns
        string that represents stencil.\\n\"\n\"  If present, |options| may have properties
        saying how the code should be\\n\"\n\"  compiled:\\n\"\n\"      module: if
        present and true, compile the source as module.\\n\"\n\"      smoosh: if present
        and true, use SmooshMonkey.\\n\"\n\"  CompileOptions-related properties of
        evaluate function's option can also\\n\"\n\"  be used.\"),\n\n    JS_FN_HELP(\"parse\",
        Parse, 1, 0,\n\"parse(code, [options])\",\n\"  Parses a string, potentially
        throwing. If present, |options| may\\n\"\n\"  have properties saying how the
        code should be compiled:\\n\"\n\"      module: if present and true, compile
        the source as module.\\n\"\n\"      smoosh: if present and true, use SmooshMonkey.\\n\"\n\"
        \ CompileOptions-related properties of evaluate function's option can also\\n\"\n\"
        \ be used. except forceFullParse. This function always use full parse.\"),\n\n
        \   JS_FN_HELP(\"syntaxParse\", SyntaxParse, 1, 0,\n\"syntaxParse(code)\",\n\"
        \ Check the syntax of a string, returning success value\"),\n\n    JS_FN_HELP(\"offThreadCompileModuleToStencil\",
        OffThreadCompileModuleToStencil, 1, 0,\n\"offThreadCompileModuleToStencil(code[,
        options])\",\n\"  Compile |code| on a helper thread, returning a job ID. To
        wait for the\\n\"\n\"  compilation to finish and and get the module stencil
        object call\\n\"\n\"  |finishOffThreadStencil| passing the job ID.\"),\n\n
        \   JS_FN_HELP(\"offThreadDecodeStencil\", OffThreadDecodeStencil, 1, 0,\n\"offThreadDecodeStencil(cacheEntry[,
        options])\",\n\"  Decode |code| on a helper thread, returning a job ID. To
        wait for the\\n\"\n\"  decoding to finish and run the code, call |finishOffThreadStencil|
        passing\\n\"\n\"  the job ID. If present, |options| may have properties saying
        how the code\\n\"\n\"  should be compiled (see also offThreadCompileToStencil).\"),\n\n
        \   JS_FN_HELP(\"offThreadCompileToStencil\", OffThreadCompileToStencil, 1,
        0,\n\"offThreadCompileToStencil(code[, options])\",\n\"  Compile |code| on
        a helper thread, returning a job ID. To wait for the\\n\"\n\"  compilation
        to finish and get the stencil object, call\\n\"\n\"  |finishOffThreadStencil|
        passing the job ID.  If present, \\n\"\n\"  |options| may have properties
        saying how the code should be compiled:\\n\"\n\"      noScriptRval: use the
        no-script-rval compiler option (default: false)\\n\"\n\"      fileName: filename
        for error messages and debug info\\n\"\n\"      lineNumber: starting line
        number for error messages and debug info\\n\"\n\"      columnNumber: starting
        column number for error messages and debug info\\n\"\n\"      element: if
        present with value |v|, convert |v| to an object |o| and\\n\"\n\"         mark
        the source as being attached to the DOM element |o|. If the\\n\"\n\"         property
        is omitted or |v| is null, don't attribute the source to\\n\"\n\"         any
        DOM element.\\n\"\n\"      elementAttributeName: if present and not undefined,
        the name of\\n\"\n\"         property of 'element' that holds this code. This
        is what\\n\"\n\"         Debugger.Source.prototype.elementAttributeName returns.\"),\n\n
        \   JS_FN_HELP(\"finishOffThreadStencil\", FinishOffThreadStencil, 0, 0,\n\"finishOffThreadStencil([jobID])\",\n\"
        \ Wait for an off-thread compilation or decode job to complete. The job ID\\n\"\n\"
        \ can be ommitted if there is only one job pending. If an error occurred,\\n\"\n\"
        \ throw the appropriate exception; otherwise, return the stencil object,\"\n\"
        \ that can be passed to |evalStencil|.\"),\n\n    JS_FN_HELP(\"timeout\",
        Timeout, 1, 0,\n\"timeout([seconds], [func])\",\n\"  Get/Set the limit in
        seconds for the execution time for the current context.\\n\"\n\"  When the
        timeout expires the current interrupt callback is invoked.\\n\"\n\"  The timeout
        is used just once.  If the callback returns a falsy value, the\\n\"\n\"  script
        is aborted.  A negative value for seconds (this is the default) cancels\\n\"\n\"
        \ any pending timeout.\\n\"\n\"  If a second argument is provided, it is installed
        as the interrupt handler,\\n\"\n\"  exactly as if by |setInterruptCallback|.\\n\"),\n\n
        \   JS_FN_HELP(\"interruptIf\", InterruptIf, 1, 0,\n\"interruptIf(cond)\",\n\"
        \ Requests interrupt callback if cond is true. If a callback function is set
        via\\n\"\n\"  |timeout| or |setInterruptCallback|, it will be called. No-op
        otherwise.\"),\n\n    JS_FN_HELP(\"invokeInterruptCallback\", InvokeInterruptCallbackWrapper,
        0, 0,\n\"invokeInterruptCallback(fun)\",\n\"  Forcefully set the interrupt
        flag and invoke the interrupt handler. If a\\n\"\n\"  callback function is
        set via |timeout| or |setInterruptCallback|, it will\\n\"\n\"  be called.
        Before returning, fun is called with the return value of the\\n\"\n\"  interrupt
        handler.\"),\n\n    JS_FN_HELP(\"setInterruptCallback\", SetInterruptCallback,
        1, 0,\n\"setInterruptCallback(func)\",\n\"  Sets func as the interrupt callback
        function.\\n\"\n\"  Calling this function will replace any callback set by
        |timeout|.\\n\"\n\"  If the callback returns a falsy value, the script is
        aborted.\\n\"),\n\n    JS_FN_HELP(\"setJitCompilerOption\", SetJitCompilerOption,
        2, 0,\n\"setJitCompilerOption(<option>, <number>)\",\n\"  Set a compiler option
        indexed in JSCompileOption enum to a number.\\n\"),\n#ifdef DEBUG\n    JS_FN_HELP(\"interruptRegexp\",
        InterruptRegexp, 2, 0,\n\"interruptRegexp(<regexp>, <string>)\",\n\"  Interrrupt
        the execution of regular expression.\\n\"),\n#endif\n    JS_FN_HELP(\"checkRegExpSyntax\",
        CheckRegExpSyntax, 1, 0,\n\"checkRegExpSyntax(<string>)\",\n\"  Return undefined
        if the string parses as a RegExp. If the string does not\\n\"\n\"  parse correctly,
        return the SyntaxError that occurred.\"),\n\n    JS_FN_HELP(\"enableLastWarning\",
        EnableLastWarning, 0, 0,\n\"enableLastWarning()\",\n\"  Enable storing the
        last warning.\"),\n    JS_FN_HELP(\"disableLastWarning\", DisableLastWarning,
        0, 0,\n\"disableLastWarning()\",\n\"  Disable storing the last warning.\"),\n\n
        \   JS_FN_HELP(\"getLastWarning\", GetLastWarning, 0, 0,\n\"getLastWarning()\",\n\"
        \ Returns an object that represents the last warning.\"),\n\n    JS_FN_HELP(\"clearLastWarning\",
        ClearLastWarning, 0, 0,\n\"clearLastWarning()\",\n\"  Clear the last warning.\"),\n\n
        \   JS_FN_HELP(\"elapsed\", Elapsed, 0, 0,\n\"elapsed()\",\n\"  Execution
        time elapsed for the current thread.\"),\n\n    JS_FN_HELP(\"decompileFunction\",
        DecompileFunction, 1, 0,\n\"decompileFunction(func)\",\n\"  Decompile a function.\"),\n\n
        \   JS_FN_HELP(\"decompileThis\", DecompileThisScript, 0, 0,\n\"decompileThis()\",\n\"
        \ Decompile the currently executing script.\"),\n\n    JS_FN_HELP(\"valueToSource\",
        ValueToSource, 1, 0,\n\"valueToSource(value)\",\n\"  Format a value for inspection.\"),\n\n
        \   JS_FN_HELP(\"thisFilename\", ThisFilename, 0, 0,\n\"thisFilename()\",\n\"
        \ Return the filename of the current script\"),\n\n    JS_FN_HELP(\"newGlobal\",
        NewGlobal, 1, 0,\n\"newGlobal([options])\",\n\"  Return a new global object/realm.
        The new global is created in the\\n\"\n\"  'newGlobal' function object's compartment
        and zone, unless the\\n\"\n\"  '--more-compartments' command-line flag was
        given, in which case new\\n\"\n\"  globals get a fresh compartment and zone.
        If options is given, it may\\n\"\n\"  have any of the following properties:\\n\"\n\"
        \     sameCompartmentAs: If an object, the global will be in the same\\n\"\n\"
        \        compartment and zone as the given object.\\n\"\n\"      sameZoneAs:
        The global will be in a new compartment in the same zone\\n\"\n\"         as
        the given object.\\n\"\n\"      newCompartment: If true, the global will always
        be created in a new\\n\"\n\"         compartment and zone.\\n\"\n\"      invisibleToDebugger:
        If true, the global will be invisible to the\\n\"\n\"         debugger (default
        false)\\n\"\n\"      discardSource: If true, discard source after compiling
        a script\\n\"\n\"         (default false).\\n\"\n\"      useWindowProxy: the
        global will be created with a WindowProxy attached. In this\\n\"\n\"          case,
        the WindowProxy will be returned.\\n\"\n\"      freezeBuiltins: certain builtin
        constructors will be frozen when created and\\n\"\n\"          their prototypes
        will be sealed. These constructors will be defined on the\\n\"\n\"          global
        as non-configurable and non-writable.\\n\"\n\"      immutablePrototype: whether
        the global's prototype is immutable.\\n\"\n\"      principal: if present,
        its value converted to a number must be an\\n\"\n\"         integer that fits
        in 32 bits; use that as the new realm's\\n\"\n\"         principal. Shell
        principals are toys, meant only for testing; one\\n\"\n\"         shell principal
        subsumes another if its set bits are a superset of\\n\"\n\"         the other's.
        Thus, a principal of 0 subsumes nothing, while a\\n\"\n\"         principals
        of ~0 subsumes all other principals. The absence of a\\n\"\n\"         principal
        is treated as if its bits were 0xffff, for subsumption\\n\"\n\"         purposes.
        If this property is omitted, supply no principal.\\n\"\n\"      systemPrincipal:
        If true, use the shell's trusted principals for the\\n\"\n\"         new realm.
        This creates a realm that's marked as a 'system' realm.\"),\n\n    JS_FN_HELP(\"nukeAllCCWs\",
        NukeAllCCWs, 0, 0,\n\"nukeAllCCWs()\",\n\"  Like nukeCCW, but for all CrossCompartmentWrappers
        targeting the current realm.\"),\n\n    JS_FN_HELP(\"recomputeWrappers\",
        RecomputeWrappers, 2, 0,\n\"recomputeWrappers([src, [target]])\",\n\"  Recompute
        all cross-compartment wrappers. src and target are both optional\\n\"\n\"
        \ and can be used to filter source or target compartments: the unwrapped\\n\"\n\"
        \ object's compartment is used as CompartmentFilter.\\n\"),\n\n    JS_FN_HELP(\"dumpObjectWrappers\",
        DumpObjectWrappers, 2, 0,\n\"dumpObjectWrappers()\",\n\"  Print information
        about cross-compartment object wrappers.\\n\"),\n\n    JS_FN_HELP(\"wrapWithProto\",
        WrapWithProto, 2, 0,\n\"wrapWithProto(obj)\",\n\"  Wrap an object into a noop
        wrapper with prototype semantics.\"),\n\n    JS_FN_HELP(\"createExternalArrayBuffer\",
        CreateExternalArrayBuffer, 1, 0,\n\"createExternalArrayBuffer(size)\",\n\"
        \ Create an array buffer that has external data of size.\"),\n\n    JS_FN_HELP(\"createMappedArrayBuffer\",
        CreateMappedArrayBuffer, 1, 0,\n\"createMappedArrayBuffer(filename, [offset,
        [size]])\",\n\"  Create an array buffer that mmaps the given file.\"),\n\nJS_FN_HELP(\"createUserArrayBuffer\",
        CreateUserArrayBuffer, 1, 0,\n\"createUserArrayBuffer(size)\",\n\"  Create
        an array buffer that uses user-controlled memory.\"),\n\n    JS_FN_HELP(\"addPromiseReactions\",
        AddPromiseReactions, 3, 0,\n\"addPromiseReactions(promise, onResolve, onReject)\",\n\"
        \ Calls the JS::AddPromiseReactions JSAPI function with the given arguments.\"),\n\n
        \   JS_FN_HELP(\"ignoreUnhandledRejections\", IgnoreUnhandledRejections, 0,
        0,\n\"ignoreUnhandledRejections()\",\n\"  By default, js shell tracks unhandled
        promise rejections and reports\\n\"\n\"  them at the end of the exectuion.
        \ If a testcase isn't interested\\n\"\n\"  in those rejections, call this
        to stop tracking and reporting.\"),\n\n    JS_FN_HELP(\"getMaxArgs\", GetMaxArgs,
        0, 0,\n\"getMaxArgs()\",\n\"  Return the maximum number of supported args
        for a call.\"),\n\n    JS_FN_HELP(\"createIsHTMLDDA\", CreateIsHTMLDDA, 0,
        0,\n\"createIsHTMLDDA()\",\n\"  Return an object |obj| that \\\"looks like\\\"
        the |document.all| object in\\n\"\n\"  browsers in certain ways: |typeof obj
        === \\\"undefined\\\"|, |obj == null|\\n\"\n\"  and |obj == undefined| (vice
        versa for !=), |ToBoolean(obj) === false|,\\n\"\n\"  and when called with
        no arguments or the single argument \\\"\\\" returns\\n\"\n\"  null.  (Calling
        |obj| any other way crashes or throws an exception.)\\n\"\n\"  This function
        implements the exact requirements of the $262.IsHTMLDDA\\n\"\n\"  property
        in test262.\"),\n\n    JS_FN_HELP(\"cacheEntry\", CacheEntry, 1, 0,\n\"cacheEntry(code)\",\n\"
        \ Return a new opaque object which emulates a cache entry of a script.  This\\n\"\n\"
        \ object encapsulates the code and its cached content. The cache entry is
        filled\\n\"\n\"  and read by the \\\"evaluate\\\" function by using it in
        place of the source, and\\n\"\n\"  by setting \\\"saveIncrementalBytecode\\\"
        and \\\"loadBytecode\\\" options.\"),\n\n    JS_FN_HELP(\"streamCacheEntry\",
        StreamCacheEntryObject::construct, 1, 0,\n\"streamCacheEntry(buffer)\",\n\"
        \ Create a shell-only object that holds wasm bytecode and can be streaming-\\n\"\n\"
        \ compiled and cached by WebAssembly.{compile,instantiate}Streaming(). On
        a\\n\"\n\"  second compilation of the same cache entry, the cached code will
        be used.\"),\n\n    JS_FN_HELP(\"printProfilerEvents\", PrintProfilerEvents,
        0, 0,\n\"printProfilerEvents()\",\n\"  Register a callback with the profiler
        that prints javascript profiler events\\n\"\n\"  to stderr.  Callback is only
        registered if profiling is enabled.\"),\n\n    JS_FN_HELP(\"enableSingleStepProfiling\",
        EnableSingleStepProfiling, 0, 0,\n\"enableSingleStepProfiling()\",\n\"  This
        function will fail on platforms that don't support single-step profiling\\n\"\n\"
        \ (currently ARM and MIPS64 support it). When enabled, at every instruction
        a\\n\"\n\"  backtrace will be recorded and stored in an array. Adjacent duplicate
        backtraces\\n\"\n\"  are discarded.\"),\n\n    JS_FN_HELP(\"disableSingleStepProfiling\",
        DisableSingleStepProfiling, 0, 0,\n\"disableSingleStepProfiling()\",\n\"  Return
        the array of backtraces recorded by enableSingleStepProfiling.\"),\n\n    JS_FN_HELP(\"enableGeckoProfiling\",
        EnableGeckoProfiling, 0, 0,\n\"enableGeckoProfiling()\",\n\"  Enables Gecko
        Profiler instrumentation and corresponding assertions, with slow\\n\"\n\"
        \ assertions disabled.\\n\"),\n\n    JS_FN_HELP(\"enableGeckoProfilingWithSlowAssertions\",
        EnableGeckoProfilingWithSlowAssertions, 0, 0,\n\"enableGeckoProfilingWithSlowAssertions()\",\n\"
        \ Enables Gecko Profiler instrumentation and corresponding assertions, with
        slow\\n\"\n\"  assertions enabled.\\n\"),\n\n    JS_FN_HELP(\"disableGeckoProfiling\",
        DisableGeckoProfiling, 0, 0,\n\"disableGeckoProfiling()\",\n\"  Disables Gecko
        Profiler instrumentation\"),\n\n    JS_FN_HELP(\"isLatin1\", IsLatin1, 1,
        0,\n\"isLatin1(s)\",\n\"  Return true iff the string's characters are stored
        as Latin1.\"),\n\n    JS_FN_HELP(\"stackPointerInfo\", StackPointerInfo, 0,
        0,\n\"stackPointerInfo()\",\n\"  Return an int32 value which corresponds to
        the offset of the latest stack\\n\"\n\"  pointer, such that one can take the
        differences of 2 to estimate a frame-size.\"),\n\n    JS_FN_HELP(\"entryPoints\",
        EntryPoints, 1, 0,\n\"entryPoints(params)\",\n\"Carry out some JSAPI operation
        as directed by |params|, and return an array of\\n\"\n\"objects describing
        which JavaScript entry points were invoked as a result.\\n\"\n\"|params| is
        an object whose properties indicate what operation to perform. Here\\n\"\n\"are
        the recognized groups of properties:\\n\"\n\"\\n\"\n\"{ function }: Call the
        object |params.function| with no arguments.\\n\"\n\"\\n\"\n\"{ object, property
        }: Fetch the property named |params.property| of\\n\"\n\"|params.object|.\\n\"\n\"\\n\"\n\"{
        ToString }: Apply JS::ToString to |params.toString|.\\n\"\n\"\\n\"\n\"{ ToNumber
        }: Apply JS::ToNumber to |params.toNumber|.\\n\"\n\"\\n\"\n\"{ eval }: Apply
        JS::Evaluate to |params.eval|.\\n\"\n\"\\n\"\n\"The return value is an array
        of strings, with one element for each\\n\"\n\"JavaScript invocation that occurred
        as a result of the given\\n\"\n\"operation. Each element is the name of the
        function invoked, or the\\n\"\n\"string 'eval:FILENAME' if the code was invoked
        by 'eval' or something\\n\"\n\"similar.\\n\"),\n\n    JS_FN_HELP(\"enqueueJob\",
        EnqueueJob, 1, 0,\n\"enqueueJob(fn)\",\n\"  Enqueue 'fn' on the shell's job
        queue.\"),\n\n    JS_FN_HELP(\"globalOfFirstJobInQueue\", GlobalOfFirstJobInQueue,
        0, 0,\n\"globalOfFirstJobInQueue()\",\n\"  Returns the global of the first
        item in the job queue. Throws an exception\\n\"\n\"  if the queue is empty.\\n\"),\n\n
        \   JS_FN_HELP(\"drainJobQueue\", DrainJobQueue, 0, 0,\n\"drainJobQueue()\",\n\"Take
        jobs from the shell's job queue in FIFO order and run them until the\\n\"\n\"queue
        is empty.\\n\"),\n\n    JS_FN_HELP(\"setPromiseRejectionTrackerCallback\",
        SetPromiseRejectionTrackerCallback, 1, 0,\n\"setPromiseRejectionTrackerCallback()\",\n\"Sets
        the callback to be invoked whenever a Promise rejection is unhandled\\n\"\n\"or
        a previously-unhandled rejection becomes handled.\"),\n\n    JS_FN_HELP(\"dumpScopeChain\",
        DumpScopeChain, 1, 0,\n\"dumpScopeChain(obj)\",\n\"  Prints the scope chain
        of an interpreted function or a module.\"),\n\n    JS_FN_HELP(\"blackRoot\",
        EnsureBlackRoot, 0, 0,\n\"blackRoot()\",\n\"  Return an array in the current
        compartment whose elements will be marked\\n\"\n\"  as black roots by the
        GC.\"),\n\n    JS_FN_HELP(\"grayRoot\", EnsureGrayRoot, 0, 0,\n\"grayRoot()\",\n\"
        \ Return an array in the current compartment whose elements will be marked\\n\"\n\"
        \ as gray roots by the GC.\"),\n\n    JS_FN_HELP(\"addMarkObservers\", AddMarkObservers,
        1, 0,\n\"addMarkObservers(array_of_objects)\",\n\"  Register an array of objects
        whose mark bits will be tested by calls to\\n\"\n\"  getMarks. The objects
        will be in calling compartment. Objects from\\n\"\n\"  multiple compartments
        may be monitored by calling this function in\\n\"\n\"  different compartments.\"),\n\n
        \   JS_FN_HELP(\"clearMarkObservers\", ClearMarkObservers, 1, 0,\n\"clearMarkObservers()\",\n\"
        \ Clear out the list of objects whose mark bits will be tested.\\n\"),\n\n
        \   JS_FN_HELP(\"getMarks\", GetMarks, 0, 0,\n\"getMarks()\",\n\"  Return
        an array of strings representing the current state of the mark\\n\"\n\"  bits
        ('gray' or 'black', or 'dead' if the object has been collected)\\n\"\n\"  for
        the objects registered via addMarkObservers. Note that some of the\\n\"\n\"
        \ objects tested may be from different compartments than the one in which\\n\"\n\"
        \ this function runs.\"),\n\n    JS_FN_HELP(\"bindToAsyncStack\", BindToAsyncStack,
        2, 0,\n\"bindToAsyncStack(fn, { stack, cause, explicit })\",\n\"  Returns
        a new function that calls 'fn' with no arguments, passing\\n\"\n\"  'undefined'
        as the 'this' value, and supplies an async stack for the\\n\"\n\"  call as
        described by the second argument, an object with the following\\n\"\n\"  properties
        (which are not optional, unless specified otherwise):\\n\"\n\"\\n\"\n\"  stack:
        \   A SavedFrame object, like that returned by 'saveStack'. Stacks\\n\"\n\"
        \           captured during calls to the returned function capture this as\\n\"\n\"
        \           their async stack parent, accessible via a SavedFrame's\\n\"\n\"
        \           'asyncParent' property.\\n\"\n\"\\n\"\n\"  cause:    A string,
        supplied as the async cause on the top frame of\\n\"\n\"            captured
        async stacks.\\n\"\n\"\\n\"\n\"  explicit: A boolean value, indicating whether
        the given 'stack' should\\n\"\n\"            always supplant the returned
        function's true callers (true),\\n\"\n\"            or only when there are
        no other JavaScript frames on the stack\\n\"\n\"            below it (false).
        If omitted, this is treated as 'true'.\"),\n\n#ifndef __wasi__\n    JS_FN_HELP(\"wasmCompileInSeparateProcess\",
        WasmCompileInSeparateProcess, 1, 0,\n\"wasmCompileInSeparateProcess(buffer)\",\n\"
        \ Compile the given buffer in a separate process, serialize the resulting\\n\"\n\"
        \ wasm::Module into bytes, and deserialize those bytes in the current\\n\"\n\"
        \ process, returning the resulting WebAssembly.Module.\"),\n\n    JS_FN_HELP(\"wasmTextToBinary\",
        WasmTextToBinary, 1, 0,\n\"wasmTextToBinary(str)\",\n\"  Translates the given
        text wasm module into its binary encoding.\"),\n#endif // __wasi__\n\n    JS_FN_HELP(\"transplantableObject\",
        TransplantableObject, 0, 0,\n\"transplantableObject([options])\",\n\"  Returns
        the pair {object, transplant}. |object| is an object which can be\\n\"\n\"
        \ transplanted into a new object when the |transplant| function, which must\\n\"\n\"
        \ be invoked with a global object, is called.\\n\"\n\"  |object| is swapped
        with a cross-compartment wrapper if the global object\\n\"\n\"  is in a different
        compartment.\\n\"\n\"\\n\"\n\"  If options is given, it may have any of the
        following properties:\\n\"\n\"    proxy: Create a DOM Proxy object instead
        of a plain DOM object.\\n\"\n\"    object: Don't create a new DOM object,
        but instead use the supplied\\n\"\n\"            FakeDOMObject.\"),\n\n    JS_FN_HELP(\"cpuNow\",
        CpuNow, /* nargs= */ 0, /* flags = */ 0,\n\"cpuNow()\",\n\" Returns the approximate
        processor time used by the process since an arbitrary epoch, in seconds.\\n\"\n\"
        Only the difference between two calls to `cpuNow()` is meaningful.\"),\n\n#ifdef
        FUZZING_JS_FUZZILLI\n    JS_FN_HELP(\"fuzzilli\", Fuzzilli, 0, 0,\n\"fuzzilli(operation,
        arg)\",\n\"  Exposes functionality used by the Fuzzilli JavaScript fuzzer.\"),\n#endif\n\n#ifdef
        FUZZING_INTERFACES\n    JS_FN_HELP(\"getWasmSmithModule\", GetWasmSmithModule,
        1, 0,\n\"getWasmSmithModule(arrayBuffer)\",\n\"  Call wasm-smith to generate
        a random wasm module from the provided data.\"),\n#endif\n\n    JS_FN_HELP(\"isValidJSON\",
        IsValidJSON, 1, 0,\n\"isValidJSON(source)\",\n\" Returns true if the given
        source is valid JSON.\"),\n\n    JS_FN_HELP(\"compressLZ4\", CompressLZ4,
        1, 0,\n\"compressLZ4(bytes)\",\n\" Return a compressed copy of bytes using
        LZ4.\"),\n\n    JS_FN_HELP(\"decompressLZ4\", DecompressLZ4, 1, 0,\n\"decompressLZ4(bytes)\",\n\"
        Return a decompressed copy of bytes using LZ4.\"),\n\n    JS_FN_HELP(\"createSideEffectfulResolveObject\",
        CreateSideEffectfulResolveObject, 0, 0,\n\"createSideEffectfulResolveObject()\",\n\"
        Return an object with a property 'obj.test == 42', backed by a resolve hook
        \"\n\" with the Debugger shouldAvoidSideEffects flag integration.\"),\n\n
        \ JS_FN_HELP(\"getUseCounterResults\", GetUseCounterResults, 0, 0,\n\"getUseCounterResults()\",\n\"
        Return the values of the shell use counters.\"),\n\n    JS_FS_HELP_END\n};\n//
        clang-format on\n\n// clang-format off\n#ifdef FUZZING_JS_FUZZILLI\nstatic
        const JSFunctionSpec shell_function_fuzzilli_hash[] = {\n    JS_INLINABLE_FN(\"fuzzilli_hash\",
        fuzzilli_hash, 1, 0, FuzzilliHash),\n    JS_FS_END\n};\n#endif\n// clang-format
        on\n\n// clang-format off\nstatic const JSFunctionSpecWithHelp diff_testing_unsafe_functions[]
        = {\n\n    JS_FS_HELP_END\n};\n// clang-format on\n\n// clang-format off\nstatic
        const JSFunctionSpecWithHelp fuzzing_unsafe_functions[] = {\n    JS_FN_HELP(\"getSelfHostedValue\",
        GetSelfHostedValue, 1, 0,\n\"getSelfHostedValue()\",\n\"  Get a self-hosted
        value by its name. Note that these values don't get \\n\"\n\"  cached, so
        repeatedly getting the same value creates multiple distinct clones.\"),\n\n
        \   JS_FN_HELP(\"line2pc\", LineToPC, 0, 0,\n\"line2pc([fun,] line)\",\n\"
        \ Map line number to PC.\"),\n\n    JS_FN_HELP(\"pc2line\", PCToLine, 0, 0,\n\"pc2line(fun[,
        pc])\",\n\"  Map PC to line number.\"),\n\n    JS_INLINABLE_FN_HELP(\"assertFloat32\",
        testingFunc_assertFloat32, 2, 0, TestAssertFloat32,\n\"assertFloat32(value,
        isFloat32)\",\n\"  In IonMonkey only, asserts that value has (resp. hasn't)
        the MIRType::Float32 if isFloat32 is true (resp. false).\"),\n\n    JS_INLINABLE_FN_HELP(\"assertRecoveredOnBailout\",
        testingFunc_assertRecoveredOnBailout, 2, 0,\nTestAssertRecoveredOnBailout,\n\"assertRecoveredOnBailout(var)\",\n\"
        \ In IonMonkey only, asserts that variable has RecoveredOnBailout flag.\"),\n\n
        \   JS_FN_HELP(\"withSourceHook\", WithSourceHook, 1, 0,\n\"withSourceHook(hook,
        fun)\",\n\"  Set this JS runtime's lazy source retrieval hook (that is, the
        hook\\n\"\n\"  used to find sources compiled with |CompileOptions::LAZY_SOURCE|)
        to\\n\"\n\"  |hook|; call |fun| with no arguments; and then restore the runtime's\\n\"\n\"
        \ original hook. Return or throw whatever |fun| did. |hook| gets\\n\"\n\"
        \ passed the requested code's URL, and should return a string.\\n\"\n\"\\n\"\n\"
        \ Notes:\\n\"\n\"\\n\"\n\"  1) SpiderMonkey may assert if the returned code
        isn't close enough\\n\"\n\"  to the script's real code, so this function is
        not fuzzer-safe.\\n\"\n\"\\n\"\n\"  2) The runtime can have only one source
        retrieval hook active at a\\n\"\n\"  time. If |fun| is not careful, |hook|
        could be asked to retrieve the\\n\"\n\"  source code for compilations that
        occurred long before it was set,\\n\"\n\"  and that it knows nothing about.
        The reverse applies as well: the\\n\"\n\"  original hook, that we reinstate
        after the call to |fun| completes,\\n\"\n\"  might be asked for the source
        code of compilations that |fun|\\n\"\n\"  performed, and which, presumably,
        only |hook| knows how to find.\\n\"),\n\n    JS_FN_HELP(\"crash\", Crash,
        0, 0,\n\"crash([message, [{disable_minidump:true}]])\",\n\"  Crashes the process
        with a MOZ_CRASH, optionally providing a message.\\n\"\n\"  An options object
        may be passed as the second argument. If the key\\n\"\n\"  'suppress_minidump'
        is set to true, then a minidump will not be\\n\"\n\"  generated by the crash
        (which only has an effect if the breakpad\\n\"\n\"  dumping library is loaded.)\"),\n\n#ifndef
        __wasi__\n    JS_FN_HELP(\"wasmLoop\", WasmLoop, 2, 0,\n\"wasmLoop(filename,
        imports)\",\n\"  Performs an AFL-style persistent loop reading data from the
        given file and passing it\\n\"\n\"  to the 'wasmEval' function together with
        the specified imports object.\"),\n#endif // __wasi__\n\n    JS_FN_HELP(\"setBufferStreamParams\",
        SetBufferStreamParams, 2, 0,\n\"setBufferStreamParams(delayMillis, chunkByteSize)\",\n\"
        \ Set the delay time (between calls to StreamConsumer::consumeChunk) and chunk\\n\"\n\"
        \ size (in bytes).\"),\n\n#ifdef JS_CACHEIR_SPEW\n  JS_FN_HELP(\"cacheIRHealthReport\",
        CacheIRHealthReport, 0, 0,\n\"cacheIRHealthReport()\",\n\"  Show health rating
        of CacheIR stubs.\"),\n#endif\n\n#ifdef DEBUG\n  JS_FN_HELP(\"debugGetQueuedJobs\",
        DebugGetQueuedJobs, 0, 0,\n\"debugGetQueuedJobs()\",\n\"  Returns an array
        of queued jobs.\"),\n#endif\n\n#ifdef JS_HAS_INTL_API\n  // One of the extras
        is AddMozDateTimeFormatConstructor, which is not fuzzing\n  // safe, since
        it doesn't validate the custom format pattern.\n  //\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=1887585#c1\n
        \   JS_FN_HELP(\"addIntlExtras\", AddIntlExtras, 1, 0,\n\"addIntlExtras(obj)\",\n\"Adds
        various not-yet-standardized Intl functions as properties on the\\n\"\n\"provided
        object (this should generally be Intl itself).  The added\\n\"\n\"functions
        and their behavior are experimental: don't depend upon them\\n\"\n\"unless
        you're willing to update your code if these experimental APIs change\\n\"\n\"underneath
        you.\"),\n#endif // JS_HAS_INTL_API\n\n    JS_FS_HELP_END\n};\n// clang-format
        on\n\n// clang-format off\nstatic const JSFunctionSpecWithHelp performance_functions[]
        = {\n    JS_FN_HELP(\"now\", Now, 0, 0,\n\"now()\",\n\"  Return the current
        time with sub-ms precision.\\n\"\n\"  This function is an alias of the dateNow()
        function.\"),\n    JS_FS_HELP_END\n};\n// clang-format on\n\n// clang-format
        off\nstatic const JSFunctionSpecWithHelp console_functions[] = {\n    JS_FN_HELP(\"log\",
        Print, 0, 0,\n\"log([exp ...])\",\n\"  Evaluate and print expressions to stdout.\\n\"\n\"
        \ This function is an alias of the print() function.\"),\n    JS_FS_HELP_END\n};\n//
        clang-format on\n\nbool DefineConsole(JSContext* cx, HandleObject global)
        {\n  RootedObject obj(cx, JS_NewPlainObject(cx));\n  return obj && JS_DefineFunctionsWithHelp(cx,
        obj, console_functions) &&\n         JS_DefineProperty(cx, global, \"console\",
        obj, 0);\n}\n\n#ifdef MOZ_PROFILING\n#  define PROFILING_FUNCTION_COUNT 5\n#
        \ ifdef MOZ_CALLGRIND\n#    define CALLGRIND_FUNCTION_COUNT 3\n#  else\n#
        \   define CALLGRIND_FUNCTION_COUNT 0\n#  endif\n#  ifdef MOZ_VTUNE\n#    define
        VTUNE_FUNCTION_COUNT 4\n#  else\n#    define VTUNE_FUNCTION_COUNT 0\n#  endif\n#
        \ define EXTERNAL_FUNCTION_COUNT \\\n    (PROFILING_FUNCTION_COUNT + CALLGRIND_FUNCTION_COUNT
        + VTUNE_FUNCTION_COUNT)\n#else\n#  define EXTERNAL_FUNCTION_COUNT 0\n#endif\n\n#undef
        PROFILING_FUNCTION_COUNT\n#undef CALLGRIND_FUNCTION_COUNT\n#undef VTUNE_FUNCTION_COUNT\n#undef
        EXTERNAL_FUNCTION_COUNT\n\nstatic bool PrintHelpString(JSContext* cx, HandleValue
        v) {\n  RootedString str(cx, v.toString());\n  MOZ_ASSERT(gOutFile->isOpen());\n\n
        \ UniqueChars bytes = JS_EncodeStringToUTF8(cx, str);\n  if (!bytes) {\n    return
        false;\n  }\n\n  fprintf(gOutFile->fp, \"%s\\n\", bytes.get());\n  return
        true;\n}\n\nstatic bool PrintHelp(JSContext* cx, HandleObject obj) {\n  RootedValue
        usage(cx);\n  if (!JS_GetProperty(cx, obj, \"usage\", &usage)) {\n    return
        false;\n  }\n  RootedValue help(cx);\n  if (!JS_GetProperty(cx, obj, \"help\",
        &help)) {\n    return false;\n  }\n\n  if (!usage.isString() || !help.isString())
        {\n    return true;\n  }\n\n  return PrintHelpString(cx, usage) && PrintHelpString(cx,
        help);\n}\n\nstruct ExtraGlobalBindingWithHelp {\n  const char* name;\n  const
        char* help;\n};\n\n// clang-format off\nstatic ExtraGlobalBindingWithHelp
        extraGlobalBindingsWithHelp[] = {\n// Defined in BindScriptArgs.\n    {\n\"scriptArgs\",\n\"
        \ An array containing the command line arguments passed after the path\\n\"\n\"
        \ to a JS script.\"},\n    {\n\"scriptPath\",\n\"  The path to the JS script
        passed to JS shell.  This does not reflect\\n\"\n\"  modules evaluated via
        -m option.\"},\n\n// Defined in DefineConsole.\n    {\n\"console\",\n\"  An
        object with console.log() which aliases print().\"},\n\n// Defined in NewGlobalObject.\n
        \   {\n\"performance\",\n\"  An object with the following properties:\\n\"\n\"
        \   performance.now()\\n\"\n\"      See help(performance.now)\\n\"\n\"    performance.mozMemory.gc\\n\"\n\"
        \     An object that represents GC statistics with the following properties:\\n\"\n\"
        \       gcBytes\\n\"\n\"        gcMaxBytes\\n\"\n\"        mallocBytes\\n\"\n\"
        \       gcIsHighFrequencyMode\\n\"\n\"        gcNumber\\n\"\n\"        majorGCCount\\n\"\n\"
        \       minorGCCount\\n\"\n\"        sliceCount\\n\"\n\"        compartmentCount\\n\"\n\"
        \       lastStartReason\\n\"\n\"        zone.gcBytes\\n\"\n\"        zone.gcTriggerBytes\\n\"\n\"
        \       zone.gcAllocTrigger\\n\"\n\"        zone.mallocBytes\\n\"\n\"        zone.mallocTriggerBytes\\n\"\n\"
        \       zone.gcNumber\"},\n    {\n\"new FakeDOMObject()\",\n\"  A constructor
        to test IonMonkey DOM optimizations in JS shell.\\n\"\n\"  The prototype object
        has the following properties:\\n\"\n\"    FakeDOMObject.prototype.x\\n\"\n\"
        \     Generic getter/setter with JSJitInfo\\n\"\n\"    FakeDOMObject.prototype.slot\\n\"\n\"
        \     Getter with JSJitInfo.slotIndex\\n\"\n\"    FakeDOMObject.prototype.global\\n\"\n\"
        \     Getter/setter with JSJitInfo::AliasEverything\\n\"\n\"    FakeDOMObject.prototype.doFoo()\\n\"\n\"
        \     Method with JSJitInfo\"},\n};\n// clang-format on\n\nstatic bool MatchPattern(JSContext*
        cx, JS::Handle<RegExpObject*> regex,\n                         JS::Handle<JSString*>
        inputStr, bool* result) {\n  JS::Rooted<JSString*> linearInputStr(cx, inputStr);\n
        \ if (!linearInputStr->ensureLinear(cx)) {\n    return false;\n  }\n\n  //
        Execute the regular expression in |regex|'s compartment.\n  JSAutoRealm ar(cx,
        regex);\n  if (!cx->compartment()->wrap(cx, &linearInputStr)) {\n    return
        false;\n  }\n  JS::Rooted<JSLinearString*> input(cx, &linearInputStr->asLinear());\n
        \ size_t ignored = 0;\n  JS::Rooted<JS::Value> v(cx);\n  if (!ExecuteRegExpLegacy(cx,
        nullptr, regex, input, &ignored, true, &v)) {\n    return false;\n  }\n  *result
        = !v.isNull();\n  return true;\n}\n\nstatic bool PrintEnumeratedHelp(JSContext*
        cx, HandleObject obj,\n                                HandleObject pattern,
        bool brief) {\n  RootedIdVector idv(cx);\n  if (!GetPropertyKeys(cx, obj,
        JSITER_OWNONLY | JSITER_HIDDEN, &idv)) {\n    return false;\n  }\n\n  Rooted<RegExpObject*>
        regex(cx);\n  if (pattern) {\n    regex = &UncheckedUnwrap(pattern)->as<RegExpObject>();\n
        \ }\n\n  for (size_t i = 0; i < idv.length(); i++) {\n    RootedValue v(cx);\n
        \   RootedId id(cx, idv[i]);\n    if (!JS_GetPropertyById(cx, obj, id, &v))
        {\n      return false;\n    }\n    if (!v.isObject()) {\n      continue;\n
        \   }\n\n    RootedObject funcObj(cx, &v.toObject());\n    if (regex) {\n
        \     // Only pay attention to objects with a 'help' property, which will\n
        \     // either be documented functions or interface objects.\n      if (!JS_GetProperty(cx,
        funcObj, \"help\", &v)) {\n        return false;\n      }\n      if (!v.isString())
        {\n        continue;\n      }\n\n      // For functions, match against the
        name. For interface objects,\n      // match against the usage string.\n      if
        (!JS_GetProperty(cx, funcObj, \"name\", &v)) {\n        return false;\n      }\n
        \     if (!v.isString()) {\n        if (!JS_GetProperty(cx, funcObj, \"usage\",
        &v)) {\n          return false;\n        }\n        if (!v.isString()) {\n
        \         continue;\n        }\n      }\n\n      Rooted<JSString*> inputStr(cx,
        v.toString());\n      bool result = false;\n      if (!MatchPattern(cx, regex,
        inputStr, &result)) {\n        return false;\n      }\n      if (!result)
        {\n        continue;\n      }\n    }\n\n    if (!PrintHelp(cx, funcObj)) {\n
        \     return false;\n    }\n  }\n\n  return true;\n}\n\nstatic bool PrintExtraGlobalEnumeratedHelp(JSContext*
        cx, HandleObject pattern,\n                                           bool
        brief) {\n  Rooted<RegExpObject*> regex(cx);\n  if (pattern) {\n    regex
        = &UncheckedUnwrap(pattern)->as<RegExpObject>();\n  }\n\n  for (const auto&
        item : extraGlobalBindingsWithHelp) {\n    if (regex) {\n      JS::Rooted<JSString*>
        name(cx, JS_NewStringCopyZ(cx, item.name));\n      if (!name) {\n        return
        false;\n      }\n\n      bool result = false;\n      if (!MatchPattern(cx,
        regex, name, &result)) {\n        return false;\n      }\n      if (!result)
        {\n        continue;\n      }\n    }\n    fprintf(gOutFile->fp, \"%s\\n\",
        item.name);\n    fprintf(gOutFile->fp, \"%s\\n\", item.help);\n  }\n\n  return
        true;\n}\n\nstatic bool Help(JSContext* cx, unsigned argc, Value* vp) {\n
        \ if (!gOutFile->isOpen()) {\n    JS_ReportErrorASCII(cx, \"output file is
        closed\");\n    return false;\n  }\n\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  args.rval().setUndefined();\n  RootedObject global(cx, JS::CurrentGlobalOrNull(cx));\n\n
        \ // help() - display the version and dump out help for all functions on the\n
        \ // global.\n  if (args.length() == 0) {\n    fprintf(gOutFile->fp, \"%s\\n\",
        JS_GetImplementationVersion());\n\n    if (!PrintEnumeratedHelp(cx, global,
        nullptr, false)) {\n      return false;\n    }\n    if (!PrintExtraGlobalEnumeratedHelp(cx,
        nullptr, false)) {\n      return false;\n    }\n    return true;\n  }\n\n
        \ RootedValue v(cx);\n\n  if (args[0].isPrimitive()) {\n    // help(\"foo\")\n
        \   JS_ReportErrorASCII(cx, \"primitive arg\");\n    return false;\n  }\n\n
        \ RootedObject obj(cx, &args[0].toObject());\n  if (!obj) {\n    return true;\n
        \ }\n  bool isRegexp;\n  if (!JS::ObjectIsRegExp(cx, obj, &isRegexp)) {\n
        \   return false;\n  }\n\n  if (isRegexp) {\n    // help(/pattern/)\n    if
        (!PrintEnumeratedHelp(cx, global, obj, false)) {\n      return false;\n    }\n
        \   if (!PrintExtraGlobalEnumeratedHelp(cx, obj, false)) {\n      return false;\n
        \   }\n    return true;\n  }\n\n  // help(function)\n  // help(namespace_obj)\n
        \ return PrintHelp(cx, obj);\n}\n\nstatic const JSErrorFormatString jsShell_ErrorFormatString[JSShellErr_Limit]
        = {\n#define MSG_DEF(name, count, exception, format) \\\n  {#name, format,
        count, JSEXN_ERR},\n#include \"jsshell.msg\"\n#undef MSG_DEF\n};\n\nconst
        JSErrorFormatString* js::shell::my_GetErrorMessage(\n    void* userRef, const
        unsigned errorNumber) {\n  if (errorNumber == 0 || errorNumber >= JSShellErr_Limit)
        {\n    return nullptr;\n  }\n\n  return &jsShell_ErrorFormatString[errorNumber];\n}\n\nstatic
        bool CreateLastWarningObject(JSContext* cx, JSErrorReport* report) {\n  RootedObject
        warningObj(cx, JS_NewObject(cx, nullptr));\n  if (!warningObj) {\n    return
        false;\n  }\n\n  if (!CopyErrorReportToObject(cx, report, warningObj)) {\n
        \   return false;\n  }\n\n  GetShellContext(cx)->lastWarning.setObject(*warningObj);\n
        \ return true;\n}\n\nstatic FILE* ErrorFilePointer() {\n  if (gErrFile->isOpen())
        {\n    return gErrFile->fp;\n  }\n\n  fprintf(stderr, \"error file is closed;
        falling back to stderr\\n\");\n  return stderr;\n}\n\nbool shell::PrintStackTrace(JSContext*
        cx, HandleObject stackObj) {\n  if (!stackObj || !stackObj->is<SavedFrame>())
        {\n    return true;\n  }\n\n  JSPrincipals* principals = stackObj->nonCCWRealm()->principals();\n
        \ RootedString stackStr(cx);\n  if (!BuildStackString(cx, principals, stackObj,
        &stackStr, 2)) {\n    return false;\n  }\n\n  UniqueChars stack = JS_EncodeStringToUTF8(cx,
        stackStr);\n  if (!stack) {\n    return false;\n  }\n\n  FILE* fp = ErrorFilePointer();\n
        \ fputs(\"Stack:\\n\", fp);\n  fputs(stack.get(), fp);\n\n  return true;\n}\n\njs::shell::AutoReportException::~AutoReportException()
        {\n  if (!JS_IsExceptionPending(cx)) {\n    return;\n  }\n\n  auto printError
        = [](JSContext* cx, auto& report, const auto& exnStack,\n                       const
        char* prefix = nullptr) {\n    if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects))
        {\n      fprintf(stderr, \"out of memory initializing JS::ErrorReportBuilder\\n\");\n
        \     fflush(stderr);\n      JS_ClearPendingException(cx);\n      return false;\n
        \   }\n\n    MOZ_ASSERT(!report.report()->isWarning());\n\n    FILE* fp =
        ErrorFilePointer();\n    if (prefix) {\n      fputs(prefix, fp);\n    }\n
        \   JS::PrintError(fp, report, reportWarnings);\n    JS_ClearPendingException(cx);\n\n
        \   // If possible, use the original error stack as the source of truth, because\n
        \   // finally block handlers may have overwritten the exception stack.\n
        \   RootedObject stack(cx, exnStack.stack());\n    if (exnStack.exception().isObject())
        {\n      RootedObject exception(cx, &exnStack.exception().toObject());\n      if
        (JSObject* exceptionStack = JS::ExceptionStackOrNull(exception)) {\n        stack.set(exceptionStack);\n
        \     }\n    }\n\n    if (!PrintStackTrace(cx, stack)) {\n      fputs(\"(Unable
        to print stack trace)\\n\", fp);\n      JS_ClearPendingException(cx);\n    }\n\n
        \   return true;\n  };\n\n  // Get exception object and stack before printing
        and clearing exception.\n  JS::ExceptionStack exnStack(cx);\n  if (!JS::StealPendingExceptionStack(cx,
        &exnStack)) {\n    fprintf(stderr, \"out of memory while stealing exception\\n\");\n
        \   fflush(stderr);\n    JS_ClearPendingException(cx);\n    return;\n  }\n\n
        \ ShellContext* sc = GetShellContext(cx);\n  JS::ErrorReportBuilder report(cx);\n
        \ if (!printError(cx, report, exnStack)) {\n    // Return if we couldn't initialize
        the error report.\n    return;\n  }\n\n  // Print the error's cause, if available.\n
        \ if (exnStack.exception().isObject()) {\n    JSObject* exception = &exnStack.exception().toObject();\n
        \   if (exception->is<ErrorObject>()) {\n      auto* error = &exception->as<ErrorObject>();\n
        \     if (auto maybeCause = error->getCause()) {\n        RootedValue cause(cx,
        maybeCause.value());\n\n        RootedObject causeStack(cx);\n        if (cause.isObject())
        {\n          RootedObject causeObj(cx, &cause.toObject());\n          causeStack
        = JS::ExceptionStackOrNull(causeObj);\n        }\n\n        JS::ExceptionStack
        exnStack(cx, cause, causeStack);\n        JS::ErrorReportBuilder report(cx);\n
        \       printError(cx, report, exnStack, \"Caused by: \");\n      }\n    }\n
        \ }\n\n#if defined(DEBUG) || defined(JS_OOM_BREAKPOINT)\n  // Don't quit the
        shell if an unhandled exception is reported during OOM\n  // testing.\n  if
        (cx->runningOOMTest) {\n    return;\n  }\n#endif\n\n  if (report.report()->errorNumber
        == JSMSG_OUT_OF_MEMORY) {\n    sc->exitCode = EXITCODE_OUT_OF_MEMORY;\n  }
        else {\n    sc->exitCode = EXITCODE_RUNTIME_ERROR;\n  }\n}\n\nvoid js::shell::WarningReporter(JSContext*
        cx, JSErrorReport* report) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ FILE* fp = ErrorFilePointer();\n\n  MOZ_ASSERT(report->isWarning());\n\n
        \ if (sc->lastWarningEnabled) {\n    JS::AutoSaveExceptionState savedExc(cx);\n
        \   if (!CreateLastWarningObject(cx, report)) {\n      fputs(\"Unhandled error
        happened while creating last warning object.\\n\",\n            fp);\n      fflush(fp);\n
        \   }\n    savedExc.restore();\n  }\n\n  // Print the warning.\n  JS::PrintError(fp,
        report, reportWarnings);\n}\n\nstatic bool global_enumerate(JSContext* cx,
        JS::HandleObject obj,\n                             JS::MutableHandleIdVector
        properties,\n                             bool enumerableOnly) {\n#ifdef LAZY_STANDARD_CLASSES\n
        \ return JS_NewEnumerateStandardClasses(cx, obj, properties, enumerableOnly);\n#else\n
        \ return true;\n#endif\n}\n\nstatic bool global_resolve(JSContext* cx, HandleObject
        obj, HandleId id,\n                           bool* resolvedp) {\n#ifdef LAZY_STANDARD_CLASSES\n
        \ if (!JS_ResolveStandardClass(cx, obj, id, resolvedp)) {\n    return false;\n
        \ }\n#endif\n  return true;\n}\n\nstatic bool global_mayResolve(const JSAtomState&
        names, jsid id,\n                              JSObject* maybeObj) {\n  return
        JS_MayResolveStandardClass(names, id, maybeObj);\n}\n\nstatic const JSClassOps
        global_classOps = {\n    nullptr,                   // addProperty\n    nullptr,
        \                  // delProperty\n    nullptr,                   // enumerate\n
        \   global_enumerate,          // newEnumerate\n    global_resolve,            //
        resolve\n    global_mayResolve,         // mayResolve\n    nullptr,                   //
        finalize\n    nullptr,                   // call\n    nullptr,                   //
        construct\n    JS_GlobalObjectTraceHook,  // trace\n};\n\nstatic constexpr
        uint32_t DOM_PROTOTYPE_SLOT = JSCLASS_GLOBAL_SLOT_COUNT;\nstatic constexpr
        uint32_t DOM_GLOBAL_SLOTS = 1;\n\nstatic const JSClass global_class = {\n
        \   \"global\",\n    JSCLASS_GLOBAL_FLAGS | JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(DOM_GLOBAL_SLOTS),\n
        \   &global_classOps};\n\n/*\n * Define a FakeDOMObject constructor. It returns
        an object with a getter,\n * setter and method with attached JitInfo. This
        object can be used to test\n * IonMonkey DOM optimizations in the shell.\n
        */\n\n/* Fow now just use to a constant we can check. */\nstatic const void*
        DOM_PRIVATE_VALUE = (void*)0x1234;\n\nstatic bool dom_genericGetter(JSContext*
        cx, unsigned argc, JS::Value* vp);\n\nstatic bool dom_genericSetter(JSContext*
        cx, unsigned argc, JS::Value* vp);\n\nstatic bool dom_genericMethod(JSContext*
        cx, unsigned argc, JS::Value* vp);\n\nstatic bool dom_get_x(JSContext* cx,
        HandleObject obj, void* self,\n                      JSJitGetterCallArgs args)
        {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self ==
        DOM_PRIVATE_VALUE);\n  args.rval().set(JS_NumberValue(double(3.14)));\n  return
        true;\n}\n\nstatic bool dom_set_x(JSContext* cx, HandleObject obj, void* self,\n
        \                     JSJitSetterCallArgs args) {\n  MOZ_ASSERT(JS::GetClass(obj)
        == GetDomClass());\n  MOZ_ASSERT(self == DOM_PRIVATE_VALUE);\n  return true;\n}\n\nstatic
        bool dom_get_slot(JSContext* cx, HandleObject obj, void* self,\n                         JSJitGetterCallArgs
        args) {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self
        == DOM_PRIVATE_VALUE);\n\n  Value v = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT2);\n
        \ MOZ_ASSERT(v.toInt32() == 42);\n  args.rval().set(v);\n  return true;\n}\n\nstatic
        bool dom_get_global(JSContext* cx, HandleObject obj, void* self,\n                           JSJitGetterCallArgs
        args) {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self
        == DOM_PRIVATE_VALUE);\n\n  // Return the current global (instead of obj->global())
        to test cx->realm\n  // switching in the JIT.\n  args.rval().setObject(*ToWindowProxyIfWindow(cx->global()));\n\n
        \ return true;\n}\n\nstatic bool dom_set_global(JSContext* cx, HandleObject
        obj, void* self,\n                           JSJitSetterCallArgs args) {\n
        \ MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n  MOZ_ASSERT(self == DOM_PRIVATE_VALUE);\n\n
        \ // Throw an exception if our argument is not the current global. This lets\n
        \ // us test cx->realm switching.\n  if (!args[0].isObject() ||\n      ToWindowIfWindowProxy(&args[0].toObject())
        != cx->global()) {\n    JS_ReportErrorASCII(cx, \"Setter not called with matching
        global argument\");\n    return false;\n  }\n\n  return true;\n}\n\nstatic
        bool dom_doFoo(JSContext* cx, HandleObject obj, void* self,\n                      const
        JSJitMethodCallArgs& args) {\n  MOZ_ASSERT(JS::GetClass(obj) == GetDomClass());\n
        \ MOZ_ASSERT(self == DOM_PRIVATE_VALUE);\n  MOZ_ASSERT(cx->realm() == args.callee().as<JSFunction>().realm());\n\n
        \ /* Just return args.length(). */\n  args.rval().setInt32(args.length());\n
        \ return true;\n}\n\nstatic const JSJitInfo dom_x_getterinfo = {\n    {(JSJitGetterOp)dom_get_x},\n
        \   {0}, /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Getter,\n    JSJitInfo::AliasNone,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,   /* returnType */\n    true,                 /*
        isInfallible. False in setters. */\n    true,                 /* isMovable
        */\n    true,                 /* isEliminatable */\n    false,                /*
        isAlwaysInSlot */\n    false,                /* isLazilyCachedInSlot */\n
        \   false,                /* isTypedMethod */\n    0                     /*
        slotIndex */\n};\n\nstatic const JSJitInfo dom_x_setterinfo = {\n    {(JSJitGetterOp)dom_set_x},\n
        \   {0}, /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Setter,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,         /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable. */\n    false,                      /* isEliminatable. */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSJitInfo
        dom_slot_getterinfo = {\n    {(JSJitGetterOp)dom_get_slot},\n    {0}, /* protoID
        */\n    {0}, /* depth */\n    JSJitInfo::Getter,\n    JSJitInfo::AliasNone,
        /* aliasSet */\n    JSVAL_TYPE_INT32,     /* returnType */\n    false,                /*
        isInfallible. False in setters. */\n    true,                 /* isMovable
        */\n    true,                 /* isEliminatable */\n    true,                 /*
        isAlwaysInSlot */\n    false,                /* isLazilyCachedInSlot */\n
        \   false,                /* isTypedMethod */\n    DOM_OBJECT_SLOT2      /*
        slotIndex */\n};\n\n// Note: this getter uses AliasEverything and is marked
        as fallible and\n// non-movable (1) to prevent Ion from getting too clever
        optimizing it and\n// (2) it's nice to have a few different kinds of getters
        in the shell.\nstatic const JSJitInfo dom_global_getterinfo = {\n    {(JSJitGetterOp)dom_get_global},\n
        \   {0}, /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Getter,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_OBJECT,          /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable */\n    false,                      /* isEliminatable */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSJitInfo
        dom_global_setterinfo = {\n    {(JSJitGetterOp)dom_set_global},\n    {0},
        /* protoID */\n    {0}, /* depth */\n    JSJitInfo::Setter,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,         /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable. */\n    false,                      /* isEliminatable. */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSJitInfo
        doFoo_methodinfo = {\n    {(JSJitGetterOp)dom_doFoo},\n    {0}, /* protoID
        */\n    {0}, /* depth */\n    JSJitInfo::Method,\n    JSJitInfo::AliasEverything,
        /* aliasSet */\n    JSVAL_TYPE_UNKNOWN,         /* returnType */\n    false,
        \                     /* isInfallible. False in setters. */\n    false,                      /*
        isMovable */\n    false,                      /* isEliminatable */\n    false,
        \                     /* isAlwaysInSlot */\n    false,                      /*
        isLazilyCachedInSlot */\n    false,                      /* isTypedMethod
        */\n    0                           /* slotIndex */\n};\n\nstatic const JSPropertySpec
        dom_props[] = {\n    JSPropertySpec::nativeAccessors(\"x\", JSPROP_ENUMERATE,
        dom_genericGetter,\n                                    &dom_x_getterinfo,
        dom_genericSetter,\n                                    &dom_x_setterinfo),\n
        \   JSPropertySpec::nativeAccessors(\"slot\", JSPROP_ENUMERATE, dom_genericGetter,\n
        \                                   &dom_slot_getterinfo),\n    JSPropertySpec::nativeAccessors(\"global\",
        JSPROP_ENUMERATE,\n                                    dom_genericGetter,
        &dom_global_getterinfo,\n                                    dom_genericSetter,
        &dom_global_setterinfo),\n    JS_PS_END};\n\nstatic const JSFunctionSpec dom_methods[]
        = {\n    JS_FNINFO(\"doFoo\", dom_genericMethod, &doFoo_methodinfo, 3,\n              JSPROP_ENUMERATE),\n
        \   JS_FS_END};\n\nstatic const JSClass dom_class = {\n    \"FakeDOMObject\",
        JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2)};\n\nstatic const JSClass*
        GetDomClass() { return &dom_class; }\n\nstatic bool dom_genericGetter(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (!args.thisv().isObject()) {\n    args.rval().setUndefined();\n
        \   return true;\n  }\n\n  RootedObject obj(cx, &args.thisv().toObject());\n
        \ if (JS::GetClass(obj) != &dom_class) {\n    args.rval().set(UndefinedValue());\n
        \   return true;\n  }\n\n  JS::Value val = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT);\n\n
        \ const JSJitInfo* info = FUNCTION_VALUE_TO_JITINFO(args.calleev());\n  MOZ_ASSERT(info->type()
        == JSJitInfo::Getter);\n  JSJitGetterOp getter = info->getter;\n  return getter(cx,
        obj, val.toPrivate(), JSJitGetterCallArgs(args));\n}\n\nstatic bool dom_genericSetter(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (args.length() < 1 || !args.thisv().isObject()) {\n    args.rval().setUndefined();\n
        \   return true;\n  }\n\n  RootedObject obj(cx, &args.thisv().toObject());\n
        \ if (JS::GetClass(obj) != &dom_class) {\n    args.rval().set(UndefinedValue());\n
        \   return true;\n  }\n\n  JS::Value val = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT);\n\n
        \ const JSJitInfo* info = FUNCTION_VALUE_TO_JITINFO(args.calleev());\n  MOZ_ASSERT(info->type()
        == JSJitInfo::Setter);\n  JSJitSetterOp setter = info->setter;\n  if (!setter(cx,
        obj, val.toPrivate(), JSJitSetterCallArgs(args))) {\n    return false;\n  }\n
        \ args.rval().set(UndefinedValue());\n  return true;\n}\n\nstatic bool dom_genericMethod(JSContext*
        cx, unsigned argc, JS::Value* vp) {\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n\n  if (!args.thisv().isObject()) {\n    args.rval().setUndefined();\n
        \   return true;\n  }\n\n  RootedObject obj(cx, &args.thisv().toObject());\n
        \ if (JS::GetClass(obj) != &dom_class) {\n    args.rval().set(UndefinedValue());\n
        \   return true;\n  }\n\n  JS::Value val = JS::GetReservedSlot(obj, DOM_OBJECT_SLOT);\n\n
        \ const JSJitInfo* info = FUNCTION_VALUE_TO_JITINFO(args.calleev());\n  MOZ_ASSERT(info->type()
        == JSJitInfo::Method);\n  JSJitMethodOp method = info->method;\n  return method(cx,
        obj, val.toPrivate(), JSJitMethodCallArgs(args));\n}\n\nstatic void InitDOMObject(HandleObject
        obj) {\n  JS::SetReservedSlot(obj, DOM_OBJECT_SLOT,\n                      PrivateValue(const_cast<void*>(DOM_PRIVATE_VALUE)));\n
        \ JS::SetReservedSlot(obj, DOM_OBJECT_SLOT2, Int32Value(42));\n}\n\nstatic
        JSObject* GetDOMPrototype(JSContext* cx, JSObject* global) {\n  MOZ_ASSERT(JS_IsGlobalObject(global));\n
        \ if (JS::GetClass(global) != &global_class) {\n    JS_ReportErrorASCII(cx,
        \"Can't get FakeDOMObject prototype in sandbox\");\n    return nullptr;\n
        \ }\n\n  const JS::Value& slot = JS::GetReservedSlot(global, DOM_PROTOTYPE_SLOT);\n
        \ MOZ_ASSERT(slot.isObject());\n  return &slot.toObject();\n}\n\nstatic bool
        dom_constructor(JSContext* cx, unsigned argc, JS::Value* vp) {\n  CallArgs
        args = CallArgsFromVp(argc, vp);\n\n  RootedObject callee(cx, &args.callee());\n
        \ RootedValue protov(cx);\n  if (!GetProperty(cx, callee, callee, cx->names().prototype,
        &protov)) {\n    return false;\n  }\n\n  if (!protov.isObject()) {\n    JS_ReportErrorNumberASCII(cx,
        GetErrorMessage, nullptr, JSMSG_BAD_PROTOTYPE,\n                              \"FakeDOMObject\");\n
        \   return false;\n  }\n\n  RootedObject proto(cx, &protov.toObject());\n
        \ RootedObject domObj(cx, JS_NewObjectWithGivenProto(cx, &dom_class, proto));\n
        \ if (!domObj) {\n    return false;\n  }\n\n  InitDOMObject(domObj);\n\n  args.rval().setObject(*domObj);\n
        \ return true;\n}\n\nstatic bool InstanceClassHasProtoAtDepth(const JSClass*
        clasp, uint32_t protoID,\n                                         uint32_t
        depth) {\n  // Only the (fake) DOM object supports any JIT optimizations.\n
        \ return clasp == GetDomClass();\n}\n\nstatic bool ShellBuildId(JS::BuildIdCharVector*
        buildId) {\n  // The browser embeds the date into the buildid and the buildid
        is embedded\n  // in the binary, so every 'make' necessarily builds a new
        firefox binary.\n  // Fortunately, the actual firefox executable is tiny --
        all the code is in\n  // libxul.so and other shared modules -- so this isn't
        a big deal. Not so\n  // for the statically-linked JS shell. To avoid recompiling
        js.cpp and\n  // re-linking 'js' on every 'make', we use a constant buildid
        and rely on\n  // the shell user to manually clear any caches between cache-breaking
        updates.\n  const char buildid[] = \"JS-shell\";\n  return buildId->append(buildid,
        sizeof(buildid));\n}\n\nstatic bool TimesAccessed(JSContext* cx, unsigned
        argc, Value* vp) {\n  static int32_t accessed = 0;\n  CallArgs args = CallArgsFromVp(argc,
        vp);\n  args.rval().setInt32(++accessed);\n  return true;\n}\n\nstatic const
        JSPropertySpec TestingProperties[] = {\n    JS_PSG(\"timesAccessed\", TimesAccessed,
        0), JS_PS_END};\n\nstatic JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions&
        options,\n                                 JSPrincipals* principals, ShellGlobalKind
        kind,\n                                 bool immutablePrototype) {\n  RootedObject
        glob(cx,\n                    JS_NewGlobalObject(cx, &global_class, principals,\n
        \                                      JS::DontFireOnNewGlobalHook, options));\n
        \ if (!glob) {\n    return nullptr;\n  }\n\n  {\n    JSAutoRealm ar(cx, glob);\n\n
        \   if (kind == ShellGlobalKind::WindowProxy) {\n      RootedObject proxy(cx,
        NewShellWindowProxy(cx, glob));\n      if (!proxy) {\n        return nullptr;\n
        \     }\n      js::SetWindowProxy(cx, glob, proxy);\n    }\n\n#ifndef LAZY_STANDARD_CLASSES\n
        \   if (!JS::InitRealmStandardClasses(cx)) {\n      return nullptr;\n    }\n#endif\n\n
        \   if (immutablePrototype) {\n      bool succeeded;\n      if (!JS_SetImmutablePrototype(cx,
        glob, &succeeded)) {\n        return nullptr;\n      }\n      MOZ_ASSERT(succeeded,\n
        \                \"a fresh, unexposed global object is always capable of \"\n
        \                \"having its [[Prototype]] be immutable\");\n    }\n\n#ifdef
        JS_HAS_CTYPES\n    if (!fuzzingSafe && !JS::InitCTypesClass(cx, glob)) {\n
        \     return nullptr;\n    }\n#endif\n    if (!JS_InitReflectParse(cx, glob))
        {\n      return nullptr;\n    }\n    if (!JS_DefineDebuggerObject(cx, glob))
        {\n      return nullptr;\n    }\n    if (!JS_DefineFunctionsWithHelp(cx, glob,
        shell_functions) ||\n        !JS_DefineProfilingFunctions(cx, glob)) {\n      return
        nullptr;\n    }\n#ifdef FUZZING_JS_FUZZILLI\n    if (!JS_DefineFunctions(cx,
        glob, shell_function_fuzzilli_hash)) {\n      return nullptr;\n    }\n#endif\n
        \   if (!js::DefineTestingFunctions(cx, glob, fuzzingSafe,\n                                    disableOOMFunctions))
        {\n      return nullptr;\n    }\n    if (!JS_DefineProperties(cx, glob, TestingProperties))
        {\n      return nullptr;\n    }\n\n    if (!fuzzingSafe) {\n      if (!JS_DefineFunctionsWithHelp(cx,
        glob, fuzzing_unsafe_functions)) {\n        return nullptr;\n      }\n      if
        (!DefineConsole(cx, glob)) {\n        return nullptr;\n      }\n    }\n\n
        \   if (!DefineOS(cx, glob, fuzzingSafe, &gOutFile, &gErrFile)) {\n      return
        nullptr;\n    }\n\n    if (!js::SupportDifferentialTesting()) {\n      if
        (!JS_DefineFunctionsWithHelp(cx, glob,\n                                      diff_testing_unsafe_functions))
        {\n        return nullptr;\n      }\n\n      RootedObject performanceObj(cx,
        JS_NewObject(cx, nullptr));\n      if (!performanceObj) {\n        return
        nullptr;\n      }\n      if (!JS_DefineFunctionsWithHelp(cx, performanceObj,\n
        \                                     performance_functions)) {\n        return
        nullptr;\n      }\n      RootedObject mozMemoryObj(cx, JS_NewObject(cx, nullptr));\n
        \     if (!mozMemoryObj) {\n        return nullptr;\n      }\n      RootedObject
        gcObj(cx, gc::NewMemoryInfoObject(cx));\n      if (!gcObj) {\n        return
        nullptr;\n      }\n      if (!JS_DefineProperty(cx, glob, \"performance\",
        performanceObj,\n                             JSPROP_ENUMERATE)) {\n        return
        nullptr;\n      }\n      if (!JS_DefineProperty(cx, performanceObj, \"mozMemory\",
        mozMemoryObj,\n                             JSPROP_ENUMERATE)) {\n        return
        nullptr;\n      }\n      if (!JS_DefineProperty(cx, mozMemoryObj, \"gc\",
        gcObj, JSPROP_ENUMERATE)) {\n        return nullptr;\n      }\n    }\n\n    /*
        Initialize FakeDOMObject. */\n    static const js::DOMCallbacks DOMcallbacks
        = {InstanceClassHasProtoAtDepth};\n    SetDOMCallbacks(cx, &DOMcallbacks);\n\n
        \   RootedObject domProto(\n        cx, JS_InitClass(cx, glob, &dom_class,
        nullptr, \"FakeDOMObject\",\n                         dom_constructor, 0,
        dom_props, dom_methods, nullptr,\n                         nullptr));\n    if
        (!domProto) {\n      return nullptr;\n    }\n\n    // FakeDOMObject.prototype
        is the only DOM object which needs to retrieved\n    // in the shell; store
        it directly instead of creating a separate layer\n    // (ProtoAndIfaceCache)
        as done in the browser.\n    JS::SetReservedSlot(glob, DOM_PROTOTYPE_SLOT,
        ObjectValue(*domProto));\n\n    /* Initialize FakeDOMObject.prototype */\n
        \   InitDOMObject(domProto);\n\n    if (!DefineToStringTag(cx, glob, cx->names().global))
        {\n      return nullptr;\n    }\n\n    JS_FireOnNewGlobalObject(cx, glob);\n
        \ }\n\n  return glob;\n}\n\nstatic bool BindScriptArgs(JSContext* cx, OptionParser*
        op) {\n  AutoReportException are(cx);\n\n  MultiStringRange msr = op->getMultiStringArg(\"scriptArgs\");\n
        \ RootedObject scriptArgs(cx);\n  scriptArgs = JS::NewArrayObject(cx, 0);\n
        \ if (!scriptArgs) {\n    return false;\n  }\n\n  if (!JS_DefineProperty(cx,
        cx->global(), \"scriptArgs\", scriptArgs, 0)) {\n    return false;\n  }\n\n
        \ for (size_t i = 0; !msr.empty(); msr.popFront(), ++i) {\n    const char*
        scriptArg = msr.front();\n    UniqueChars scriptArgUtf8 = JS::EncodeNarrowToUtf8(cx,
        scriptArg);\n    if (!scriptArgUtf8) {\n      return false;\n    }\n    RootedString
        str(cx, NewStringCopyUTF8(cx, scriptArgUtf8.get()));\n    if (!str || !JS_DefineElement(cx,
        scriptArgs, i, str, JSPROP_ENUMERATE)) {\n      return false;\n    }\n  }\n\n
        \ RootedValue scriptPathValue(cx);\n  if (const char* scriptPath = op->getStringArg(\"script\"))
        {\n    UniqueChars scriptPathUtf8 = JS::EncodeNarrowToUtf8(cx, scriptPath);\n
        \   if (!scriptPathUtf8) {\n      return false;\n    }\n    RootedString scriptPathString(cx,\n
        \                                 NewStringCopyUTF8(cx, scriptPathUtf8.get()));\n
        \   if (!scriptPathString) {\n      return false;\n    }\n    scriptPathValue
        = StringValue(scriptPathString);\n  } else {\n    scriptPathValue = UndefinedValue();\n
        \ }\n\n  if (!JS_DefineProperty(cx, cx->global(), \"scriptPath\", scriptPathValue,
        0)) {\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool OptionFailure(const
        char* option, const char* str) {\n  fprintf(stderr, \"Unrecognized option
        for %s: %s\\n\", option, str);\n  return false;\n}\n\ntemplate <typename...
        Ts>\nauto minVal(Ts... args);\ntemplate <typename T>\nauto minVal(T a) {\n
        \ return a;\n}\n\ntemplate <typename T, typename... Ts>\nauto minVal(T a,
        Ts... args) {\n  return std::min(a, minVal(args...));\n}\n\n[[nodiscard]]
        static bool ProcessArgs(JSContext* cx, OptionParser* op) {\n  ShellContext*
        sc = GetShellContext(cx);\n\n  /* |scriptArgs| gets bound on the global before
        any code is run. */\n  if (!BindScriptArgs(cx, op)) {\n    return false;\n
        \ }\n\n  MultiStringRange filePaths = op->getMultiStringOption('f');\n  MultiStringRange
        utf16FilePaths = op->getMultiStringOption('u');\n  MultiStringRange preludePaths
        = op->getMultiStringOption('p');\n  MultiStringRange codeChunks = op->getMultiStringOption('e');\n
        \ MultiStringRange modulePaths = op->getMultiStringOption('m');\n\n#ifdef
        FUZZING_JS_FUZZILLI\n  // Check for REPRL file source\n  if (op->getBoolOption(\"reprl\"))
        {\n    return FuzzilliReprlGetAndRun(cx);\n  }\n#endif /* FUZZING_JS_FUZZILLI
        */\n\n  if (filePaths.empty() && utf16FilePaths.empty() && codeChunks.empty()
        &&\n      modulePaths.empty() && !op->getStringArg(\"script\")) {\n    //
        Always use the interactive shell when -i is used. Without -i we let\n    //
        Process figure it out based on isatty.\n    bool forceTTY = op->getBoolOption('i');\n
        \   return Process(cx, nullptr, forceTTY, FileScript);\n  }\n\n  while (!preludePaths.empty()
        || !filePaths.empty() ||\n         !utf16FilePaths.empty() || !codeChunks.empty()
        ||\n         !modulePaths.empty()) {\n    size_t ppArgno = preludePaths.empty()
        ? SIZE_MAX : preludePaths.argno();\n    size_t fpArgno = filePaths.empty()
        ? SIZE_MAX : filePaths.argno();\n    size_t ufpArgno =\n        utf16FilePaths.empty()
        ? SIZE_MAX : utf16FilePaths.argno();\n    size_t ccArgno = codeChunks.empty()
        ? SIZE_MAX : codeChunks.argno();\n    size_t mpArgno = modulePaths.empty()
        ? SIZE_MAX : modulePaths.argno();\n    size_t minArgno = minVal(ppArgno, fpArgno,
        ufpArgno, ccArgno, mpArgno);\n\n    if (ppArgno == minArgno) {\n      UniqueChars
        path = JS::EncodeNarrowToUtf8(cx, preludePaths.front());\n      if (!path)
        {\n        return false;\n      }\n      if (!Process(cx, path.get(), false,
        PreludeScript)) {\n        return false;\n      }\n\n      preludePaths.popFront();\n
        \     continue;\n    }\n\n    if (fpArgno == minArgno) {\n      UniqueChars
        path = JS::EncodeNarrowToUtf8(cx, filePaths.front());\n      if (!path) {\n
        \       return false;\n      }\n      if (!Process(cx, path.get(), false,
        FileScript)) {\n        return false;\n      }\n\n      filePaths.popFront();\n
        \     continue;\n    }\n\n    if (ufpArgno == minArgno) {\n      UniqueChars
        path = JS::EncodeNarrowToUtf8(cx, utf16FilePaths.front());\n      if (!path)
        {\n        return false;\n      }\n      if (!Process(cx, path.get(), false,
        FileScriptUtf16)) {\n        return false;\n      }\n\n      utf16FilePaths.popFront();\n
        \     continue;\n    }\n\n    if (ccArgno == minArgno) {\n      UniqueChars
        code = JS::EncodeNarrowToUtf8(cx, codeChunks.front());\n      if (!code) {\n
        \       return false;\n      }\n\n      // Command line scripts are always
        parsed with full-parse to evaluate\n      // conditions which might filter
        code coverage conditions.\n      JS::CompileOptions opts(cx);\n      opts.setFileAndLine(\"-e\",
        1).setForceFullParse();\n\n      JS::SourceText<Utf8Unit> srcBuf;\n      if
        (!srcBuf.init(cx, code.get(), strlen(code.get()),\n                       JS::SourceOwnership::Borrowed))
        {\n        return false;\n      }\n\n      RootedValue rval(cx);\n      if
        (!JS::Evaluate(cx, opts, srcBuf, &rval)) {\n        return false;\n      }\n\n
        \     codeChunks.popFront();\n      if (sc->quitting) {\n        break;\n
        \     }\n\n      continue;\n    }\n\n    MOZ_ASSERT(mpArgno == minArgno);\n\n
        \   UniqueChars path = JS::EncodeNarrowToUtf8(cx, modulePaths.front());\n
        \   if (!path) {\n      return false;\n    }\n    if (!Process(cx, path.get(),
        false, FileModule)) {\n      return false;\n    }\n\n    modulePaths.popFront();\n
        \ }\n\n  if (sc->quitting) {\n    return false;\n  }\n\n  /* The |script|
        argument is processed after all options. */\n  if (const char* path = op->getStringArg(\"script\"))
        {\n    UniqueChars pathUtf8 = JS::EncodeNarrowToUtf8(cx, path);\n    if (!pathUtf8)
        {\n      return false;\n    }\n    if (!Process(cx, pathUtf8.get(), false,
        FileScript)) {\n      return false;\n    }\n  }\n\n  if (op->getBoolOption('i'))
        {\n    if (!Process(cx, nullptr, true, FileScript)) {\n      return false;\n
        \   }\n  }\n\n  return true;\n}\n\nstatic void SetWorkerContextOptions(JSContext*
        cx) {\n  // Copy option values from the main thread.\n  JS::ContextOptionsRef(cx)\n
        \     .setAsmJS(enableAsmJS)\n      .setWasm(enableWasm)\n      .setWasmBaseline(enableWasmBaseline)\n
        \     .setWasmIon(enableWasmOptimizing)\n\n      .setWasmVerbose(enableWasmVerbose)\n
        \     .setTestWasmAwaitTier2(enableTestWasmAwaitTier2)\n      .setSourcePragmas(enableSourcePragmas);\n\n
        \ cx->runtime()->setOffthreadIonCompilationEnabled(offthreadCompilation);\n
        \ cx->runtime()->profilingScripts =\n      enableCodeCoverage || enableDisassemblyDumps;\n\n#ifdef
        JS_GC_ZEAL\n  if (gZealBits && gZealFrequency) {\n    for (size_t i = 0; i
        < size_t(gc::ZealMode::Count); i++) {\n      if (gZealBits & (1 << i)) {\n
        \       cx->runtime()->gc.setZeal(i, gZealFrequency);\n      }\n    }\n  }\n#endif\n\n
        \ JS_SetNativeStackQuota(cx, gWorkerStackSize);\n}\n\n[[nodiscard]] static
        bool PrintUnhandledRejection(\n    JSContext* cx, Handle<PromiseObject*> promise)
        {\n  RootedValue reason(cx, promise->reason());\n  RootedObject site(cx, promise->resolutionSite());\n\n
        \ RootedString str(cx, JS_ValueToSource(cx, reason));\n  if (!str) {\n    return
        false;\n  }\n\n  UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, str);\n
        \ if (!utf8chars) {\n    return false;\n  }\n\n  FILE* fp = ErrorFilePointer();\n
        \ fprintf(fp, \"Unhandled rejection: %s\\n\", utf8chars.get());\n\n  if (!site)
        {\n    fputs(\"(no stack trace available)\\n\", stderr);\n    return true;\n
        \ }\n\n  JSPrincipals* principals = cx->realm()->principals();\n  RootedString
        stackStr(cx);\n  if (!BuildStackString(cx, principals, site, &stackStr, 2))
        {\n    return false;\n  }\n\n  UniqueChars stack = JS_EncodeStringToUTF8(cx,
        stackStr);\n  if (!stack) {\n    return false;\n  }\n\n  fputs(\"Stack:\\n\",
        fp);\n  fputs(stack.get(), fp);\n\n  return true;\n}\n\n[[nodiscard]] static
        bool ReportUnhandledRejections(JSContext* cx) {\n  ShellContext* sc = GetShellContext(cx);\n
        \ if (!sc->trackUnhandledRejections) {\n    return true;\n  }\n\n  if (!sc->unhandledRejectedPromises)
        {\n    return true;\n  }\n\n  AutoRealm ar(cx, sc->unhandledRejectedPromises);\n\n
        \ if (!SetObject::size(cx, sc->unhandledRejectedPromises)) {\n    return true;\n
        \ }\n\n  sc->exitCode = EXITCODE_RUNTIME_ERROR;\n\n  RootedValue iter(cx);\n
        \ if (!SetObject::iterator(cx, SetObject::IteratorKind::Values,\n                           sc->unhandledRejectedPromises,
        &iter)) {\n    return false;\n  }\n\n  Rooted<SetIteratorObject*> iterObj(cx,\n
        \                                    &iter.toObject().as<SetIteratorObject>());\n
        \ JSObject* obj = SetIteratorObject::createResult(cx);\n  if (!obj) {\n    return
        false;\n  }\n\n  Rooted<ArrayObject*> resultObj(cx, &obj->as<ArrayObject>());\n
        \ while (true) {\n    bool done = SetIteratorObject::next(iterObj, resultObj);\n
        \   if (done) {\n      break;\n    }\n\n    RootedObject obj(cx, &resultObj->getDenseElement(0).toObject());\n
        \   Rooted<PromiseObject*> promise(cx, obj->maybeUnwrapIf<PromiseObject>());\n
        \   if (!promise) {\n      FILE* fp = ErrorFilePointer();\n      fputs(\n
        \         \"Unhandled rejection: dead proxy found in unhandled \"\n          \"rejections
        set\\n\",\n          fp);\n      continue;\n    }\n\n    AutoRealm ar2(cx,
        promise);\n\n    if (!PrintUnhandledRejection(cx, promise)) {\n      return
        false;\n    }\n  }\n\n  sc->unhandledRejectedPromises = nullptr;\n\n  return
        true;\n}\n\nbool ShellContext::registerWithCx(JSContext* cx) {\n  cx_ = cx;\n
        \ JS_SetContextPrivate(cx, this);\n\n  if (isWorker) {\n    SetWorkerContextOptions(cx);\n
        \ }\n\n  JS::SetWarningReporter(cx, WarningReporter);\n  JS_SetFutexCanWait(cx);\n
        \ JS_InitDestroyPrincipalsCallback(cx, ShellPrincipals::destroy);\n  JS_SetDestroyCompartmentCallback(cx,
        DestroyShellCompartmentPrivate);\n  js::SetWindowProxyClass(cx, &ShellWindowProxyClass);\n\n
        \ js::UseInternalJobQueues(cx);\n\n  js::SetPreserveWrapperCallbacks(cx, DummyPreserveWrapperCallback,\n
        \                                 DummyHasReleasedWrapperCallback);\n\n  JS::SetHostCleanupFinalizationRegistryCallback(\n
        \     cx, ShellCleanupFinalizationRegistryCallback, this);\n  JS_AddExtraGCRootsTracer(cx,
        TraceBlackRoots, nullptr);\n  JS_SetGrayGCRootsTracer(cx, TraceGrayRoots,
        nullptr);\n\n  return true;\n}\n\nShellContext::~ShellContext() {\n  markObservers.reset();\n
        \ if (cx_) {\n    JS_SetContextPrivate(cx_, nullptr);\n    JS::SetHostCleanupFinalizationRegistryCallback(cx_,
        nullptr, nullptr);\n    JS_SetGrayGCRootsTracer(cx_, nullptr, nullptr);\n
        \   JS_RemoveExtraGCRootsTracer(cx_, TraceBlackRoots, nullptr);\n  }\n  MOZ_ASSERT(offThreadJobs.empty());\n}\n\nstatic
        int Shell(JSContext* cx, OptionParser* op) {\n#ifdef JS_STRUCTURED_SPEW\n
        \ cx->spewer().enableSpewing();\n#endif\n\n  auto exitShell = MakeScopeExit([&]
        {\n#ifdef JS_STRUCTURED_SPEW\n    cx->spewer().disableSpewing();\n#endif\n
        \ });\n\n#ifdef MOZ_CODE_COVERAGE\n  InstallCoverageSignalHandlers();\n#endif\n\n
        \ Maybe<JS::AutoDisableGenerationalGC> noggc;\n  if (op->getBoolOption(\"no-ggc\"))
        {\n    noggc.emplace(cx);\n  }\n\n  Maybe<AutoDisableCompactingGC> nocgc;\n
        \ if (op->getBoolOption(\"no-cgc\")) {\n    nocgc.emplace(cx);\n  }\n\n#ifdef
        DEBUG\n  if (op->getBoolOption(\"differential-testing\")) {\n    JS::SetSupportDifferentialTesting(true);\n
        \ }\n#endif\n\n  if (op->getBoolOption(\"disable-oom-functions\")) {\n    disableOOMFunctions
        = true;\n  }\n\n  if (op->getBoolOption(\"more-compartments\")) {\n    defaultToSameCompartment
        = false;\n  }\n\n  bool reprl_mode = FuzzilliUseReprlMode(op);\n\n  // Begin
        REPRL Loop\n  int result = EXIT_SUCCESS;\n  do {\n    JS::RealmOptions options;\n
        \   SetStandardRealmOptions(options);\n    RootedObject glob(\n        cx,
        NewGlobalObject(cx, options, nullptr, ShellGlobalKind::WindowProxy,\n                            /*
        immutablePrototype = */ true));\n    if (!glob) {\n      return 1;\n    }\n\n
        \   JSAutoRealm ar(cx, glob);\n\n    ShellContext* sc = GetShellContext(cx);\n
        \   if (!sc->moduleLoader && !InitModuleLoader(cx, *op)) {\n      return EXIT_FAILURE;\n
        \   }\n\n#ifdef FUZZING_INTERFACES\n    if (fuzzHaveModule) {\n      return
        FuzzJSRuntimeStart(cx, &sArgc, &sArgv);\n    }\n#endif\n\n    sc->exitCode
        = 0;\n    result = EXIT_SUCCESS;\n    {\n      AutoReportException are(cx);\n
        \     if (!ProcessArgs(cx, op) && !sc->quitting) {\n        result = EXITCODE_RUNTIME_ERROR;\n
        \     }\n    }\n\n    /*\n     * The job queue must be drained even on error
        to finish outstanding async\n     * tasks before the main thread JSRuntime
        is torn down. Drain after\n     * uncaught exceptions have been reported since
        draining runs callbacks.\n     */\n    RunShellJobs(cx);\n\n    // Only if
        there's no other error, report unhandled rejections.\n    if (!result && !sc->exitCode)
        {\n      AutoReportException are(cx);\n      if (!ReportUnhandledRejections(cx))
        {\n        FILE* fp = ErrorFilePointer();\n        fputs(\"Error while printing
        unhandled rejection\\n\", fp);\n      }\n    }\n\n    if (sc->exitCode) {\n
        \     result = sc->exitCode;\n    }\n\n#ifdef FUZZING_JS_FUZZILLI\n    if
        (reprl_mode) {\n      fflush(stdout);\n      fflush(stderr);\n      // Send
        return code to parent and reset edge counters.\n      int status = (result
        & 0xff) << 8;\n      if (js::SupportDifferentialTesting()) {\n        struct
        {\n          int status;\n          uint32_t execHash;\n          uint32_t
        execHashInputs;\n        } s;\n        s.status = status;\n        s.execHash
        = cx->executionHash;\n        s.execHashInputs = cx->executionHashInputs;\n
        \       MOZ_RELEASE_ASSERT(write(REPRL_CWFD, &s, 12) == 12);\n      } else
        {\n        MOZ_RELEASE_ASSERT(write(REPRL_CWFD, &status, 4) == 4);\n      }\n
        \     __sanitizer_cov_reset_edgeguards();\n      cx->executionHash = 1;\n
        \     cx->executionHashInputs = 0;\n    }\n#endif\n\n    if (enableDisassemblyDumps)
        {\n      AutoReportException are(cx);\n      if (!js::DumpRealmPCCounts(cx))
        {\n        result = EXITCODE_OUT_OF_MEMORY;\n      }\n    }\n\n    // End
        REPRL loop\n  } while (reprl_mode);\n\n  return result;\n}\n\n// Used to allocate
        memory when jemalloc isn't yet initialized.\nJS_DECLARE_NEW_METHODS(SystemAlloc_New,
        malloc, static)\n\nstatic void SetOutputFile(const char* const envVar, RCFile*
        defaultOut,\n                          RCFile** outFileP) {\n  RCFile* outFile;\n\n
        \ const char* outPath = getenv(envVar);\n  FILE* newfp;\n  if (outPath &&
        *outPath && (newfp = fopen(outPath, \"w\"))) {\n    outFile = SystemAlloc_New<RCFile>(newfp);\n
        \ } else {\n    outFile = defaultOut;\n  }\n\n  if (!outFile) {\n    MOZ_CRASH(\"Failed
        to allocate output file\");\n  }\n\n  outFile->acquire();\n  *outFileP = outFile;\n}\n\nstatic
        void PreInit() {\n#ifdef XP_WIN\n  const char* crash_option = getenv(\"XRE_NO_WINDOWS_CRASH_DIALOG\");\n
        \ if (crash_option && crash_option[0] == '1') {\n    // Disable the segfault
        dialog. We want to fail the tests immediately\n    // instead of hanging automation.\n
        \   UINT newMode = SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX;\n    UINT
        prevMode = SetErrorMode(newMode);\n    SetErrorMode(prevMode | newMode);\n
        \ }\n#endif\n}\n\n#ifndef JS_WITHOUT_NSPR\nclass AutoLibraryLoader {\n  Vector<PRLibrary*,
        4, SystemAllocPolicy> libraries;\n\n public:\n  ~AutoLibraryLoader() {\n    for
        (auto dll : libraries) {\n      PR_UnloadLibrary(dll);\n    }\n  }\n\n  PRLibrary*
        load(const char* path) {\n    PRLibSpec libSpec;\n    libSpec.type = PR_LibSpec_Pathname;\n
        \   libSpec.value.pathname = path;\n    PRLibrary* dll = PR_LoadLibraryWithFlags(libSpec,
        PR_LD_NOW | PR_LD_GLOBAL);\n    if (!dll) {\n      fprintf(stderr, \"LoadLibrary
        '%s' failed with code %d\\n\", path,\n              PR_GetError());\n      MOZ_CRASH(\"Failed
        to load library\");\n    }\n\n    MOZ_ALWAYS_TRUE(libraries.append(dll));\n
        \   return dll;\n  }\n};\n#endif\n\nstatic bool ReadSelfHostedXDRFile(JSContext*
        cx, FileContents& buf) {\n  FILE* file = fopen(selfHostedXDRPath, \"rb\");\n
        \ if (!file) {\n    fprintf(stderr, \"Can't open self-hosted stencil XDR file.\\n\");\n
        \   return false;\n  }\n  AutoCloseFile autoClose(file);\n\n  struct stat
        st;\n  if (fstat(fileno(file), &st) < 0) {\n    fprintf(stderr, \"Unable to
        stat self-hosted stencil XDR file.\\n\");\n    return false;\n  }\n\n  if
        (st.st_size >= INT32_MAX) {\n    fprintf(stderr, \"self-hosted stencil XDR
        file too large.\\n\");\n    return false;\n  }\n  uint32_t filesize = uint32_t(st.st_size);\n\n
        \ if (!buf.growBy(filesize)) {\n    return false;\n  }\n  size_t cc = fread(buf.begin(),
        1, filesize, file);\n  if (cc != filesize) {\n    fprintf(stderr, \"Short
        read on self-hosted stencil XDR file.\\n\");\n    return false;\n  }\n\n  return
        true;\n}\n\nstatic bool WriteSelfHostedXDRFile(JSContext* cx, JS::SelfHostedCache
        buffer) {\n  FILE* file = fopen(selfHostedXDRPath, \"wb\");\n  if (!file)
        {\n    JS_ReportErrorUTF8(cx, \"Can't open self-hosted stencil XDR file.\");\n
        \   return false;\n  }\n  AutoCloseFile autoClose(file);\n\n  size_t cc =
        fwrite(buffer.Elements(), 1, buffer.LengthBytes(), file);\n  if (cc != buffer.LengthBytes())
        {\n    JS_ReportErrorUTF8(cx, \"Short write on self-hosted stencil XDR file.\");\n
        \   return false;\n  }\n\n  return true;\n}\n\ntemplate <typename T>\nstatic
        bool ParsePrefValue(const char* name, const char* val, T* result) {\n  if
        constexpr (std::is_same_v<T, bool>) {\n    if (strcmp(val, \"true\") == 0)
        {\n      *result = true;\n      return true;\n    }\n    if (strcmp(val, \"false\")
        == 0) {\n      *result = false;\n      return true;\n    }\n    fprintf(stderr,
        \"Invalid value for boolean pref %s: %s\\n\", name, val);\n    return false;\n
        \ } else {\n    static_assert(std::is_same_v<T, int32_t> || std::is_same_v<T,
        uint32_t>);\n    char* end;\n    long v = strtol(val, &end, 10);\n    if (end
        != val + strlen(val) || static_cast<long>(static_cast<T>(v)) != v) {\n      fprintf(stderr,
        \"Invalid value for integer pref %s: %s\\n\", name, val);\n      return false;\n
        \   }\n    *result = static_cast<T>(v);\n    return true;\n  }\n}\n\nstatic
        bool SetJSPrefToTrueForBool(const char* name) {\n  // Search for a matching
        pref and try to set it to a default value for the\n  // type.\n#define CHECK_PREF(NAME,
        CPP_NAME, TYPE, SETTER, IS_STARTUP_PREF)      \\\n  if (strcmp(name, NAME)
        == 0) {                                       \\\n    if constexpr (std::is_same_v<TYPE,
        bool>) {                        \\\n      JS::Prefs::SETTER(true);                                         \\\n
        \     return true;                                                     \\\n
        \   } else {                                                           \\\n
        \     fprintf(stderr, \"Pref %s must have a value specified.\\n\", name);
        \\\n      return false;                                                    \\\n
        \   }                                                                  \\\n
        \ }\n  FOR_EACH_JS_PREF(CHECK_PREF)\n#undef CHECK_PREF\n\n  // Nothing matched.
        If --fuzzing-safe is used, return true after printing a\n  // message, to
        continue execution without breaking fuzzing when a pref is\n  // removed.\n
        \ if (fuzzingSafe) {\n    fprintf(stderr, \"Warning: Ignoring unknown pref
        name: %s\\n\", name);\n    return true;\n  }\n  fprintf(stderr, \"Invalid
        pref name: %s\\n\", name);\n  return false;\n}\n\nstatic bool SetJSPrefToValue(const
        char* name, size_t nameLen,\n                             const char* value)
        {\n  // Search for a matching pref and try to set it to the provided value.\n#define
        CHECK_PREF(NAME, CPP_NAME, TYPE, SETTER, IS_STARTUP_PREF)         \\\n  if
        (nameLen == strlen(NAME) && memcmp(name, NAME, strlen(NAME)) == 0) { \\\n
        \   TYPE v;                                                               \\\n
        \   if (!ParsePrefValue<TYPE>(NAME, value, &v)) {                         \\\n
        \     return false;                                                       \\\n
        \   }                                                                     \\\n
        \   JS::Prefs::SETTER(v);                                                 \\\n
        \   return true;                                                          \\\n
        \ }\n  FOR_EACH_JS_PREF(CHECK_PREF)\n#undef CHECK_PREF\n\n  // Nothing matched.
        If --fuzzing-safe is used, return true after printing a\n  // message, to
        continue execution without breaking fuzzing when a pref is\n  // removed.\n
        \ if (fuzzingSafe) {\n    fprintf(stderr, \"Warning: Ignoring unknown pref
        name: %s\\n\", name);\n    return true;\n  }\n  fprintf(stderr, \"Invalid
        pref name: %s\\n\", name);\n  return false;\n}\n\nstatic bool SetJSPref(const
        char* pref) {\n  const char* assign = strchr(pref, '=');\n  if (!assign) {\n
        \   if (!SetJSPrefToTrueForBool(pref)) {\n      return false;\n    }\n    return
        true;\n  }\n\n  size_t nameLen = assign - pref;\n  const char* valStart =
        assign + 1;  // Skip '='.\n\n  if (!SetJSPrefToValue(pref, nameLen, valStart))
        {\n    return false;\n  }\n  return true;\n}\n\nstatic void ListJSPrefs()
        {\n  auto printPref = [](const char* name, auto defaultVal) {\n    using T
        = decltype(defaultVal);\n    if constexpr (std::is_same_v<T, bool>) {\n      fprintf(stderr,
        \"%s=%s\\n\", name, defaultVal ? \"true\" : \"false\");\n    } else if constexpr
        (std::is_same_v<T, int32_t>) {\n      fprintf(stderr, \"%s=%d\\n\", name,
        defaultVal);\n    } else {\n      static_assert(std::is_same_v<T, uint32_t>);\n
        \     fprintf(stderr, \"%s=%u\\n\", name, defaultVal);\n    }\n  };\n\n#define
        PRINT_PREF(NAME, CPP_NAME, TYPE, SETTER, IS_STARTUP_PREF) \\\n  printPref(NAME,
        JS::Prefs::CPP_NAME());\n  FOR_EACH_JS_PREF(PRINT_PREF)\n#undef PRINT_PREF\n}\n\nstatic
        bool SetGCParameterFromArg(JSContext* cx, char* arg) {\n  char* c = strchr(arg,
        '=');\n  if (!c) {\n    fprintf(stderr,\n            \"Error: --gc-param argument
        '%s' must be of the form \"\n            \"name=decimalValue\\n\",\n            arg);\n
        \   return false;\n  }\n\n  *c = '\\0';\n  const char* name = arg;\n  const
        char* valueStr = c + 1;\n\n  JSGCParamKey key;\n  bool writable;\n  if (!GetGCParameterInfo(name,
        &key, &writable)) {\n    fprintf(stderr, \"Error: Unknown GC parameter name
        '%s'\\n\", name);\n    fprintf(stderr, \"Writable GC parameter names are:\\n\");\n#define
        PRINT_WRITABLE_PARAM_NAME(name, _, writable) \\\n  if (writable) {                                    \\\n
        \   fprintf(stderr, \"  %s\\n\", name);                 \\\n  }\n    FOR_EACH_GC_PARAM(PRINT_WRITABLE_PARAM_NAME)\n#undef
        PRINT_WRITABLE_PARAM_NAME\n    return false;\n  }\n\n  if (!writable) {\n
        \   fprintf(stderr, \"Error: GC parameter '%s' is not writable\\n\", name);\n
        \   return false;\n  }\n\n  char* end = nullptr;\n  unsigned long int value
        = strtoul(valueStr, &end, 10);\n  if (end == valueStr || *end) {\n    fprintf(stderr,\n
        \           \"Error: Could not parse '%s' as decimal for GC parameter '%s'\\n\",\n
        \           valueStr, name);\n    return false;\n  }\n\n  uint32_t paramValue
        = uint32_t(value);\n  if (value == ULONG_MAX || value != paramValue ||\n      !cx->runtime()->gc.setParameter(cx,
        key, paramValue)) {\n    fprintf(stderr, \"Error: Value %s is out of range
        for GC parameter '%s'\\n\",\n            valueStr, name);\n    return false;\n
        \ }\n\n  return true;\n}\n\nint main(int argc, char** argv) {\n  PreInit();\n\n
        \ sArgc = argc;\n  sArgv = argv;\n\n  int result;\n\n  setlocale(LC_ALL, \"\");\n\n
        \ // Special-case stdout and stderr. We bump their refcounts to prevent them\n
        \ // from getting closed and then having some printf fail somewhere.\n  RCFile
        rcStdout(stdout);\n  rcStdout.acquire();\n  RCFile rcStderr(stderr);\n  rcStderr.acquire();\n\n
        \ SetOutputFile(\"JS_STDOUT\", &rcStdout, &gOutFile);\n  SetOutputFile(\"JS_STDERR\",
        &rcStderr, &gErrFile);\n\n  // Use a larger jemalloc page cache. This should
        match the value for browser\n  // foreground processes in ContentChild::RecvNotifyProcessPriorityChanged.\n
        \ moz_set_max_dirty_page_modifier(4);\n\n  OptionParser op(\"Usage: {progname}
        [options] [[script] scriptArgs*]\");\n  if (!InitOptionParser(op)) {\n    return
        EXIT_FAILURE;\n  }\n\n  switch (op.parseArgs(argc, argv)) {\n    case OptionParser::EarlyExit:\n
        \     return EXIT_SUCCESS;\n    case OptionParser::ParseError:\n      op.printHelp(argv[0]);\n
        \     return EXIT_FAILURE;\n    case OptionParser::Fail:\n      return EXIT_FAILURE;\n
        \   case OptionParser::Okay:\n      break;\n  }\n\n  if (op.getHelpOption())
        {\n    return EXIT_SUCCESS;\n  }\n\n  if (!SetGlobalOptionsPreJSInit(op))
        {\n    return EXIT_FAILURE;\n  }\n\n  // Start the engine.\n  if (const char*
        message = JS_InitWithFailureDiagnostic()) {\n    fprintf(gErrFile->fp, \"JS_Init
        failed: %s\\n\", message);\n    return 1;\n  }\n\n  // `selfHostedXDRBuffer`
        contains XDR buffer of the self-hosted JS.\n  // A part of it is borrowed
        by ImmutableScriptData of the self-hosted scripts.\n  //\n  // This buffer
        should outlive JS_Shutdown.\n  Maybe<FileContents> selfHostedXDRBuffer;\n\n
        \ auto shutdownEngine = MakeScopeExit([] { JS_ShutDown(); });\n\n  if (!SetGlobalOptionsPostJSInit(op))
        {\n    return EXIT_FAILURE;\n  }\n\n  // Record aggregated telemetry data
        on disk. Do this as early as possible such\n  // that the telemetry is recording
        both before starting the context and after\n  // closing it.\n  auto writeTelemetryResults
        = MakeScopeExit([&op] {\n    if (telemetryLock) {\n      const char* dir =
        op.getStringOption(\"telemetry-dir\");\n      WriteTelemetryDataToDisk(dir);\n
        \     js_free(telemetryLock);\n      telemetryLock = nullptr;\n    }\n  });\n\n
        \ if (!InitSharedObjectMailbox()) {\n    return EXIT_FAILURE;\n  }\n\n  JS::SetProcessBuildIdOp(ShellBuildId);\n\n
        \ /* Use the same parameters as the browser in xpcjsruntime.cpp. */\n  JSContext*
        const cx = JS_NewContext(JS::DefaultHeapMaxBytes);\n  if (!cx) {\n    return
        1;\n  }\n\n  // Register telemetry callbacks, if needed.\n  if (telemetryLock)
        {\n    JS_SetAccumulateTelemetryCallback(cx, AccumulateTelemetryDataCallback);\n
        \ }\n  JS_SetSetUseCounterCallback(cx, SetUseCounterCallback);\n\n  auto destroyCx
        = MakeScopeExit([cx] { JS_DestroyContext(cx); });\n\n  UniquePtr<ShellContext>
        sc =\n      MakeUnique<ShellContext>(cx, ShellContext::MainThread);\n  if
        (!sc || !sc->registerWithCx(cx)) {\n    return 1;\n  }\n\n  if (!SetContextOptions(cx,
        op)) {\n    return 1;\n  }\n\n  JS_SetTrustedPrincipals(cx, &ShellPrincipals::fullyTrusted);\n
        \ JS_SetSecurityCallbacks(cx, &ShellPrincipals::securityCallbacks);\n\n  JS_AddInterruptCallback(cx,
        ShellInterruptCallback);\n\n  JS::SetGCSliceCallback(cx, GCSliceCallback);\n\n
        \ bufferStreamState = js_new<ExclusiveWaitableData<BufferStreamState>>(\n
        \     mutexid::BufferStreamState);\n  if (!bufferStreamState) {\n    return
        1;\n  }\n  auto shutdownBufferStreams = MakeScopeExit([] {\n    ShutdownBufferStreams();\n
        \   js_delete(bufferStreamState);\n  });\n  JS::InitConsumeStreamCallback(cx,
        ConsumeBufferSource, ReportStreamError);\n\n  JS::SetPromiseRejectionTrackerCallback(\n
        \     cx, ForwardingPromiseRejectionTrackerCallback);\n\n  JS::dbg::SetDebuggerMallocSizeOf(cx,
        moz_malloc_size_of);\n\n  auto shutdownShellThreads = MakeScopeExit([cx] {\n
        \   KillWatchdog(cx);\n    KillWorkerThreads(cx);\n    DestructSharedObjectMailbox();\n
        \   CancelOffThreadJobsForRuntime(cx);\n  });\n\n  // The file content should
        stay alive as long as Worker thread can be\n  // initialized.\n  JS::SelfHostedCache
        xdrSpan = nullptr;\n  JS::SelfHostedWriter xdrWriter = nullptr;\n  if (selfHostedXDRPath)
        {\n    if (encodeSelfHostedCode) {\n      xdrWriter = WriteSelfHostedXDRFile;\n
        \   } else {\n      selfHostedXDRBuffer.emplace(cx);\n      if (ReadSelfHostedXDRFile(cx,
        *selfHostedXDRBuffer)) {\n        MOZ_ASSERT(selfHostedXDRBuffer->length()
        > 0);\n        JS::SelfHostedCache span(selfHostedXDRBuffer->begin(),\n                                 selfHostedXDRBuffer->end());\n
        \       xdrSpan = span;\n      } else {\n        fprintf(stderr, \"Falling
        back on parsing source.\\n\");\n        selfHostedXDRPath = nullptr;\n      }\n
        \   }\n  }\n\n  if (!JS::InitSelfHostedCode(cx, xdrSpan, xdrWriter)) {\n    return
        1;\n  }\n\n  EnvironmentPreparer environmentPreparer(cx);\n\n  JS::SetProcessLargeAllocationFailureCallback(my_LargeAllocFailCallback);\n\n
        \ if (op.getBoolOption(\"wasm-compile-and-serialize\")) {\n#ifdef __wasi__\n
        \   MOZ_CRASH(\"WASI doesn't support wasm\");\n#else\n    if (!WasmCompileAndSerialize(cx))
        {\n      // Errors have been printed directly to stderr.\n      MOZ_ASSERT(!cx->isExceptionPending());\n
        \     return EXIT_FAILURE;\n    }\n#endif\n    return EXIT_SUCCESS;\n  }\n\n
        \ result = Shell(cx, &op);\n\n#ifdef DEBUG\n  if (OOM_printAllocationCount)
        {\n    printf(\"OOM max count: %\" PRIu64 \"\\n\", js::oom::simulator.counter());\n
        \ }\n#endif\n\n  return result;\n}\n\nbool InitOptionParser(OptionParser&
        op) {\n  op.setDescription(\n      \"The SpiderMonkey shell provides a command
        line interface to the \"\n      \"JavaScript engine. Code and file options
        provided via the command line \"\n      \"are \"\n      \"run left to right.
        If provided, the optional script argument is run \"\n      \"after \"\n      \"all
        options have been processed. Just-In-Time compilation modes may be \"\n      \"enabled
        via \"\n      \"command line options.\");\n  op.setDescriptionWidth(72);\n
        \ op.setHelpWidth(80);\n  op.setVersion(JS_GetImplementationVersion());\n\n
        \ if (!op.addMultiStringOption(\n          'f', \"file\", \"PATH\",\n          \"File
        path to run, parsing file contents as UTF-8\") ||\n      !op.addMultiStringOption(\n
        \         'u', \"utf16-file\", \"PATH\",\n          \"File path to run, inflating
        the file's UTF-8 contents to UTF-16 and \"\n          \"then parsing that\")
        ||\n      !op.addMultiStringOption('m', \"module\", \"PATH\", \"Module path
        to run\") ||\n      !op.addMultiStringOption('p', \"prelude\", \"PATH\", \"Prelude
        path to run\") ||\n      !op.addMultiStringOption('e', \"execute\", \"CODE\",
        \"Inline code to run\") ||\n      !op.addStringOption('\\0', \"selfhosted-xdr-path\",
        \"[filename]\",\n                          \"Read/Write selfhosted script
        data from/to the given \"\n                          \"XDR file\") ||\n      !op.addStringOption('\\0',
        \"selfhosted-xdr-mode\", \"(encode,decode,off)\",\n                          \"Whether
        to encode/decode data of the file provided\"\n                          \"with
        --selfhosted-xdr-path.\") ||\n      !op.addBoolOption('i', \"shell\", \"Enter
        prompt after running code\") ||\n      !op.addBoolOption('c', \"compileonly\",\n
        \                       \"Only compile, don't run (syntax checking mode)\")
        ||\n      !op.addBoolOption('w', \"warnings\", \"Emit warnings\") ||\n      !op.addBoolOption('W',
        \"nowarnings\", \"Don't emit warnings\") ||\n      !op.addBoolOption('D',
        \"dump-bytecode\",\n                        \"Dump bytecode with exec count
        for all scripts\") ||\n      !op.addBoolOption('b', \"print-timing\",\n                        \"Print
        sub-ms runtime for each file that's run\") ||\n      !op.addBoolOption('\\0',
        \"code-coverage\",\n                        \"Enable code coverage instrumentation.\")
        ||\n      !op.addBoolOption(\n          '\\0', \"disable-parser-deferred-alloc\",\n
        \         \"Disable deferred allocation of GC objects until after parser\")
        ||\n#ifdef DEBUG\n      !op.addBoolOption('O', \"print-alloc\",\n                        \"Print
        the number of allocations at exit\") ||\n#endif\n      !op.addOptionalStringArg(\"script\",\n
        \                              \"A script to execute (after all options)\")
        ||\n      !op.addOptionalMultiStringArg(\n          \"scriptArgs\",\n          \"String
        arguments to bind as |scriptArgs| in the \"\n          \"shell's global\")
        ||\n      !op.addIntOption(\n          '\\0', \"cpu-count\", \"COUNT\",\n
        \         \"Set the number of CPUs (hardware threads) to COUNT, the \"\n          \"default
        is the actual number of CPUs. The total number of \"\n          \"background
        helper threads is the CPU count plus some constant.\",\n          -1) ||\n
        \     !op.addIntOption('\\0', \"thread-count\", \"COUNT\", \"Alias for --cpu-count.\",\n
        \                      -1) ||\n      !op.addBoolOption('\\0', \"ion\", \"Enable
        IonMonkey (default)\") ||\n      !op.addBoolOption('\\0', \"no-ion\", \"Disable
        IonMonkey\") ||\n      !op.addBoolOption('\\0', \"no-ion-for-main-context\",\n
        \                       \"Disable IonMonkey for the main context only\") ||\n
        \     !op.addIntOption('\\0', \"inlining-entry-threshold\", \"COUNT\",\n                       \"The
        minimum stub entry count before trial-inlining a\"\n                       \"
        call\",\n                       -1) ||\n      !op.addIntOption('\\0', \"small-function-length\",
        \"COUNT\",\n                       \"The maximum bytecode length of a 'small
        function' for \"\n                       \"the purpose of inlining.\",\n                       -1)
        ||\n      !op.addBoolOption('\\0', \"only-inline-selfhosted\",\n                        \"Only
        inline selfhosted functions\") ||\n      !op.addBoolOption('\\0', \"no-asmjs\",
        \"Disable asm.js compilation\") ||\n      !op.addStringOption(\n          '\\0',
        \"wasm-compiler\", \"[option]\",\n          \"Choose to enable a subset of
        the wasm compilers, valid options are \"\n          \"'none', 'baseline',
        'ion', 'optimizing', \"\n          \"'baseline+ion', 'baseline+optimizing'.\")
        ||\n      !op.addBoolOption('\\0', \"wasm-verbose\",\n                        \"Enable
        WebAssembly verbose logging\") ||\n      !op.addBoolOption('\\0', \"disable-wasm-huge-memory\",\n
        \                       \"Disable WebAssembly huge memory\") ||\n      !op.addBoolOption('\\0',
        \"test-wasm-await-tier2\",\n                        \"Forcibly activate tiering
        and block \"\n                        \"instantiation on completion of tier2\")
        ||\n      !op.addBoolOption('\\0', \"no-native-regexp\",\n                        \"Disable
        native regexp compilation\") ||\n      !op.addIntOption(\n          '\\0',
        \"regexp-warmup-threshold\", \"COUNT\",\n          \"Wait for COUNT invocations
        before compiling regexps to native code \"\n          \"(default 10)\",\n
        \         -1) ||\n      !op.addBoolOption('\\0', \"trace-regexp-parser\",
        \"Trace regexp parsing\") ||\n      !op.addBoolOption('\\0', \"trace-regexp-assembler\",\n
        \                       \"Trace regexp assembler\") ||\n      !op.addBoolOption('\\0',
        \"trace-regexp-interpreter\",\n                        \"Trace regexp interpreter\")
        ||\n      !op.addBoolOption('\\0', \"trace-regexp-peephole\",\n                        \"Trace
        regexp peephole optimization\") ||\n      !op.addBoolOption('\\0', \"less-debug-code\",\n
        \                       \"Emit less machine code for \"\n                        \"checking
        assertions under DEBUG.\") ||\n      !op.addBoolOption('\\0', \"disable-weak-refs\",
        \"Disable weak references\") ||\n      !op.addBoolOption('\\0', \"disable-tosource\",
        \"Disable toSource/uneval\") ||\n      !op.addBoolOption('\\0', \"disable-property-error-message-fix\",\n
        \                       \"Disable fix for the error message when accessing
        \"\n                        \"property of null or undefined\") ||\n      !op.addBoolOption('\\0',
        \"enable-iterator-helpers\",\n                        \"Enable iterator helpers\")
        ||\n      !op.addBoolOption('\\0', \"enable-async-iterator-helpers\",\n                        \"Enable
        async iterator helpers\") ||\n      !op.addBoolOption('\\0', \"enable-json-parse-with-source\",\n
        \                       \"Enable JSON.parse with source\") ||\n      !op.addBoolOption('\\0',
        \"enable-shadow-realms\", \"Enable ShadowRealms\") ||\n      !op.addBoolOption('\\0',
        \"disable-array-grouping\",\n                        \"Disable Object.groupBy
        and Map.groupBy\") ||\n      !op.addBoolOption('\\0', \"disable-well-formed-unicode-strings\",\n
        \                       \"Disable String.prototype.{is,to}WellFormed() methods\"\n
        \                       \"(Well-Formed Unicode Strings) (default: Enabled)\")
        ||\n      !op.addBoolOption('\\0', \"enable-new-set-methods\",\n                        \"Enable
        New Set methods\") ||\n      !op.addBoolOption('\\0', \"disable-arraybuffer-transfer\",\n
        \                       \"Disable ArrayBuffer.prototype.transfer() methods\")
        ||\n      !op.addBoolOption('\\0', \"enable-symbols-as-weakmap-keys\",\n                        \"Enable
        Symbols As WeakMap keys\") ||\n      !op.addBoolOption(\n          '\\0',
        \"enable-arraybuffer-resizable\",\n          \"Enable resizable ArrayBuffers
        and growable SharedArrayBuffers\") ||\n      !op.addBoolOption('\\0', \"enable-uint8array-base64\",\n
        \                       \"Enable Uint8Array base64/hex methods\") ||\n      !op.addBoolOption('\\0',
        \"enable-float16array\", \"Enable Float16Array\") ||\n      !op.addBoolOption('\\0',
        \"enable-regexp-duplicate-named-groups\",\n                        \"Enable
        Duplicate Named Capture Groups\") ||\n      !op.addBoolOption('\\0', \"enable-top-level-await\",\n
        \                       \"Enable top-level await\") ||\n      !op.addBoolOption('\\0',
        \"enable-import-assertions\",\n                        \"Enable import attributes
        with old assert syntax\") ||\n      !op.addBoolOption('\\0', \"enable-import-attributes\",\n
        \                       \"Enable import attributes\") ||\n      !op.addBoolOption('\\0',
        \"disable-destructuring-fuse\",\n                        \"Disable Destructuring
        Fuse\") ||\n      !op.addStringOption('\\0', \"shared-memory\", \"on/off\",\n
        \                         \"SharedArrayBuffer and Atomics \"\n#if SHARED_MEMORY_DEFAULT\n
        \                         \"(default: on, off to disable)\"\n#else\n                          \"(default:
        off, on to enable)\"\n#endif\n                          ) ||\n      !op.addStringOption('\\0',
        \"spectre-mitigations\", \"on/off\",\n                          \"Whether
        Spectre mitigations are enabled (default: \"\n                          \"off,
        on to enable)\") ||\n      !op.addStringOption('\\0', \"write-protect-code\",
        \"on/off\",\n                          \"Whether the W^X policy is enforced
        to mark JIT code \"\n                          \"pages as either writable
        or executable but never \"\n                          \"both at the same time
        (default: on, off to \"\n                          \"disable)\") ||\n      !op.addStringOption('\\0',
        \"cache-ir-stubs\", \"on/off/call\",\n                          \"Use CacheIR
        stubs (default: on, off to disable, \"\n                          \"call to
        enable work-in-progress call ICs)\") ||\n      !op.addStringOption('\\0',
        \"ion-shared-stubs\", \"on/off\",\n                          \"Use shared
        stubs (default: on, off to disable)\") ||\n      !op.addStringOption('\\0',
        \"ion-scalar-replacement\", \"on/off\",\n                          \"Scalar
        Replacement (default: on, off to disable)\") ||\n      !op.addStringOption('\\0',
        \"ion-gvn\", \"[mode]\",\n                          \"Specify Ion global value
        numbering:\\n\"\n                          \"  off: disable GVN\\n\"\n                          \"
        \ on:  enable GVN (default)\\n\") ||\n      !op.addStringOption(\n          '\\0',
        \"ion-licm\", \"on/off\",\n          \"Loop invariant code motion (default:
        on, off to disable)\") ||\n      !op.addStringOption('\\0', \"ion-edgecase-analysis\",
        \"on/off\",\n                          \"Find edge cases where Ion can avoid
        bailouts \"\n                          \"(default: on, off to disable)\")
        ||\n      !op.addStringOption('\\0', \"ion-pruning\", \"on/off\",\n                          \"Branch
        pruning (default: on, off to disable)\") ||\n      !op.addStringOption('\\0',
        \"ion-range-analysis\", \"on/off\",\n                          \"Range analysis
        (default: on, off to disable)\") ||\n      !op.addStringOption('\\0', \"ion-sink\",
        \"on/off\",\n                          \"Sink code motion (default: off, on
        to enable)\") ||\n      !op.addStringOption(\n          '\\0', \"ion-instruction-reordering\",
        \"on/off\",\n          \"Instruction reordering (default: off, on to enable)\")
        ||\n      !op.addStringOption(\n          '\\0', \"ion-optimize-shapeguards\",
        \"on/off\",\n          \"Eliminate redundant shape guards (default: on, off
        to disable)\") ||\n      !op.addStringOption(\n          '\\0', \"ion-optimize-gcbarriers\",
        \"on/off\",\n          \"Eliminate redundant GC barriers (default: on, off
        to disable)\") ||\n      !op.addStringOption('\\0', \"ion-iterator-indices\",
        \"on/off\",\n                          \"Optimize property access in for-in
        loops \"\n                          \"(default: on, off to disable)\") ||\n
        \     !op.addStringOption('\\0', \"ion-load-keys\", \"on/off\",\n                          \"Atomize
        property loads used as keys \"\n                          \"(default: on,
        off to disable)\") ||\n      !op.addBoolOption('\\0', \"ion-check-range-analysis\",\n
        \                       \"Range analysis checking\") ||\n      !op.addBoolOption('\\0',
        \"ion-extra-checks\",\n                        \"Perform extra dynamic validation
        checks\") ||\n      !op.addStringOption(\n          '\\0', \"ion-inlining\",
        \"on/off\",\n          \"Inline methods where possible (default: on, off to
        disable)\") ||\n      !op.addStringOption(\n          '\\0', \"ion-osr\",
        \"on/off\",\n          \"On-Stack Replacement (default: on, off to disable)\")
        ||\n      !op.addBoolOption('\\0', \"disable-bailout-loop-check\",\n                        \"Turn
        off bailout loop check\") ||\n      !op.addBoolOption('\\0', \"enable-ic-frame-pointers\",\n
        \                       \"Use frame pointers in all IC stubs\") ||\n      !op.addBoolOption('\\0',
        \"scalar-replace-arguments\",\n                        \"Use scalar replacement
        to optimize ArgumentsObject\") ||\n      !op.addStringOption(\n          '\\0',
        \"ion-limit-script-size\", \"on/off\",\n          \"Don't compile very large
        scripts (default: on, off to disable)\") ||\n      !op.addIntOption('\\0',
        \"ion-warmup-threshold\", \"COUNT\",\n                       \"Wait for COUNT
        calls or iterations before compiling \"\n                       \"at the normal
        optimization level (default: 1000)\",\n                       -1) ||\n      !op.addStringOption(\n
        \         '\\0', \"ion-regalloc\", \"[mode]\",\n          \"Specify Ion register
        allocation:\\n\"\n          \"  backtracking: Priority based backtracking
        register allocation \"\n          \"(default)\\n\"\n          \"  testbed:
        Backtracking allocator with experimental features\\n\"\n          \"  stupid:
        Simple block local register allocation\") ||\n      !op.addBoolOption(\n          '\\0',
        \"ion-eager\",\n          \"Always ion-compile methods (implies --baseline-eager)\")
        ||\n      !op.addBoolOption('\\0', \"fast-warmup\",\n                        \"Reduce
        warmup thresholds for each tier.\") ||\n      !op.addStringOption('\\0', \"ion-offthread-compile\",
        \"on/off\",\n                          \"Compile scripts off thread (default:
        on)\") ||\n      !op.addStringOption('\\0', \"ion-parallel-compile\", \"on/off\",\n
        \                         \"--ion-parallel compile is deprecated. Use \"\n
        \                         \"--ion-offthread-compile.\") ||\n      !op.addBoolOption('\\0',
        \"baseline\",\n                        \"Enable baseline compiler (default)\")
        ||\n      !op.addBoolOption('\\0', \"no-baseline\", \"Disable baseline compiler\")
        ||\n      !op.addBoolOption('\\0', \"baseline-eager\",\n                        \"Always
        baseline-compile methods\") ||\n#ifdef ENABLE_PORTABLE_BASELINE_INTERP\n      !op.addBoolOption('\\0',
        \"portable-baseline-eager\",\n                        \"Always use the porbale
        baseline interpreter\") ||\n      !op.addBoolOption('\\0', \"portable-baseline\",\n
        \                       \"Enable Portable Baseline Interpreter (default)\")
        ||\n      !op.addBoolOption('\\0', \"no-portable-baseline\",\n                        \"Disable
        Portable Baseline Interpreter\") ||\n#endif\n      !op.addIntOption(\n          '\\0',
        \"baseline-warmup-threshold\", \"COUNT\",\n          \"Wait for COUNT calls
        or iterations before baseline-compiling \"\n          \"(default: 10)\",\n
        \         -1) ||\n      !op.addBoolOption('\\0', \"blinterp\",\n                        \"Enable
        Baseline Interpreter (default)\") ||\n      !op.addBoolOption('\\0', \"no-blinterp\",
        \"Disable Baseline Interpreter\") ||\n      !op.addBoolOption('\\0', \"disable-jithints\",\n
        \                       \"Disable caching eager baseline compilation hints.\")
        ||\n      !op.addBoolOption(\n          '\\0', \"emit-interpreter-entry\",\n
        \         \"Emit Interpreter entry trampolines (default under --enable-perf)\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-emit-interpreter-entry\",\n
        \         \"Do not emit Interpreter entry trampolines (default).\") ||\n      !op.addBoolOption('\\0',
        \"blinterp-eager\",\n                        \"Always Baseline-interpret scripts\")
        ||\n      !op.addIntOption(\n          '\\0', \"blinterp-warmup-threshold\",
        \"COUNT\",\n          \"Wait for COUNT calls or iterations before Baseline-interpreting
        \"\n          \"(default: 10)\",\n          -1) ||\n      !op.addIntOption(\n
        \         '\\0', \"trial-inlining-warmup-threshold\", \"COUNT\",\n          \"Wait
        for COUNT calls or iterations before trial-inlining \"\n          \"(default:
        500)\",\n          -1) ||\n      !op.addStringOption(\n          '\\0', \"monomorphic-inlining\",
        \"default/always/never\",\n          \"Whether monomorphic inlining is used
        instead of trial inlining \"\n          \"always, never, or based on heuristics
        (default)\") ||\n      !op.addBoolOption(\n          '\\0', \"no-sse3\",\n
        \         \"Pretend CPU does not support SSE3 instructions and above \"\n
        \         \"to test JIT codegen (no-op on platforms other than x86 and x64).\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-ssse3\",\n          \"Pretend
        CPU does not support SSSE3 [sic] instructions and above \"\n          \"to
        test JIT codegen (no-op on platforms other than x86 and x64).\") ||\n      !op.addBoolOption(\n
        \         '\\0', \"no-sse41\",\n          \"Pretend CPU does not support SSE4.1
        instructions \"\n          \"to test JIT codegen (no-op on platforms other
        than x86 and x64).\") ||\n      !op.addBoolOption('\\0', \"no-sse4\", \"Alias
        for --no-sse41\") ||\n      !op.addBoolOption(\n          '\\0', \"no-sse42\",\n
        \         \"Pretend CPU does not support SSE4.2 instructions \"\n          \"to
        test JIT codegen (no-op on platforms other than x86 and x64).\") ||\n#ifdef
        ENABLE_WASM_AVX\n      !op.addBoolOption('\\0', \"enable-avx\",\n                        \"No-op.
        AVX is enabled by default, if available.\") ||\n      !op.addBoolOption(\n
        \         '\\0', \"no-avx\",\n          \"Pretend CPU does not support AVX
        or AVX2 instructions \"\n          \"to test JIT codegen (no-op on platforms
        other than x86 and x64).\") ||\n#else\n      !op.addBoolOption('\\0', \"enable-avx\",\n
        \                       \"AVX is disabled by default. Enable AVX. \"\n                        \"(no-op
        on platforms other than x86 and x64).\") ||\n      !op.addBoolOption('\\0',
        \"no-avx\",\n                        \"No-op. AVX is currently disabled by
        default.\") ||\n#endif\n      !op.addBoolOption('\\0', \"more-compartments\",\n
        \                       \"Make newGlobal default to creating a new \"\n                        \"compartment.\")
        ||\n      !op.addBoolOption('\\0', \"fuzzing-safe\",\n                        \"Don't
        expose functions that aren't safe for \"\n                        \"fuzzers
        to call\") ||\n#ifdef DEBUG\n      !op.addBoolOption('\\0', \"differential-testing\",\n
        \                       \"Avoid random/undefined behavior that disturbs \"\n
        \                       \"differential testing (correctness fuzzing)\") ||\n#endif\n
        \     !op.addBoolOption('\\0', \"disable-oom-functions\",\n                        \"Disable
        functions that cause \"\n                        \"artificial OOMs\") ||\n
        \     !op.addBoolOption('\\0', \"no-threads\", \"Disable helper threads\")
        ||\n      !op.addBoolOption(\n          '\\0', \"no-jit-backend\",\n          \"Disable
        the JIT backend completely for this process\") ||\n#ifdef DEBUG\n      !op.addBoolOption('\\0',
        \"dump-entrained-variables\",\n                        \"Print variables which
        are \"\n                        \"unnecessarily entrained by inner functions\")
        ||\n#endif\n      !op.addBoolOption('\\0', \"no-ggc\", \"Disable Generational
        GC\") ||\n      !op.addBoolOption('\\0', \"no-cgc\", \"Disable Compacting
        GC\") ||\n      !op.addBoolOption('\\0', \"no-incremental-gc\", \"Disable
        Incremental GC\") ||\n      !op.addBoolOption('\\0', \"no-parallel-marking\",\n
        \                       \"Disable GC parallel marking\") ||\n      !op.addBoolOption('\\0',
        \"enable-parallel-marking\",\n                        \"Enable GC parallel
        marking\") ||\n      !op.addStringOption('\\0', \"nursery-strings\", \"on/off\",\n
        \                         \"Allocate strings in the nursery\") ||\n      !op.addStringOption('\\0',
        \"nursery-bigints\", \"on/off\",\n                          \"Allocate BigInts
        in the nursery\") ||\n      !op.addIntOption('\\0', \"available-memory\",
        \"SIZE\",\n                       \"Select GC settings based on available
        memory (MB)\",\n                       0) ||\n      !op.addStringOption('\\0',
        \"arm-hwcap\", \"[features]\",\n                          \"Specify ARM code
        generation features, or 'help' to \"\n                          \"list all
        features.\") ||\n      !op.addIntOption('\\0', \"arm-asm-nop-fill\", \"SIZE\",\n
        \                      \"Insert the given number of NOP instructions at all
        \"\n                       \"possible pool locations.\",\n                       0)
        ||\n      !op.addIntOption('\\0', \"asm-pool-max-offset\", \"OFFSET\",\n                       \"The
        maximum pc relative OFFSET permitted in pool \"\n                       \"reference
        instructions.\",\n                       1024) ||\n      !op.addBoolOption('\\0',
        \"arm-sim-icache-checks\",\n                        \"Enable icache flush
        checks in the ARM \"\n                        \"simulator.\") ||\n      !op.addIntOption('\\0',
        \"arm-sim-stop-at\", \"NUMBER\",\n                       \"Stop the ARM simulator
        after the given \"\n                       \"NUMBER of instructions.\",\n
        \                      -1) ||\n      !op.addBoolOption('\\0', \"mips-sim-icache-checks\",\n
        \                       \"Enable icache flush checks in the MIPS \"\n                        \"simulator.\")
        ||\n      !op.addIntOption('\\0', \"mips-sim-stop-at\", \"NUMBER\",\n                       \"Stop
        the MIPS simulator after the given \"\n                       \"NUMBER of
        instructions.\",\n                       -1) ||\n      !op.addBoolOption('\\0',
        \"loong64-sim-icache-checks\",\n                        \"Enable icache flush
        checks in the LoongArch64 \"\n                        \"simulator.\") ||\n
        \     !op.addIntOption('\\0', \"loong64-sim-stop-at\", \"NUMBER\",\n                       \"Stop
        the LoongArch64 simulator after the given \"\n                       \"NUMBER
        of instructions.\",\n                       -1) ||\n#ifdef JS_CODEGEN_RISCV64\n
        \     !op.addBoolOption('\\0', \"riscv-debug\", \"debug print riscv info.\")
        ||\n#endif\n#ifdef JS_SIMULATOR_RISCV64\n      !op.addBoolOption('\\0', \"trace-sim\",
        \"print simulator info.\") ||\n      !op.addBoolOption('\\0', \"debug-sim\",
        \"debug simulator.\") ||\n      !op.addBoolOption('\\0', \"riscv-trap-to-simulator-debugger\",\n
        \                       \"trap into simulator debuggger.\") ||\n      !op.addIntOption('\\0',
        \"riscv-sim-stop-at\", \"NUMBER\",\n                       \"Stop the riscv
        simulator after the given \"\n                       \"NUMBER of instructions.\",\n
        \                      -1) ||\n#endif\n      !op.addIntOption('\\0', \"nursery-size\",
        \"SIZE-MB\",\n                       \"Set the maximum nursery size in MB\",\n
        \                      JS::DefaultNurseryMaxBytes / 1024 / 1024) ||\n#ifdef
        JS_GC_ZEAL\n      !op.addStringOption('z', \"gc-zeal\", \"LEVEL(;LEVEL)*[,N]\",\n
        \                         gc::ZealModeHelpText) ||\n#else\n      !op.addStringOption('z',
        \"gc-zeal\", \"LEVEL(;LEVEL)*[,N]\",\n                          \"option ignored
        in non-gc-zeal builds\") ||\n#endif\n      !op.addMultiStringOption('\\0',
        \"gc-param\", \"NAME=VALUE\",\n                               \"Set a named
        GC parameter\") ||\n      !op.addStringOption('\\0', \"module-load-path\",
        \"DIR\",\n                          \"Set directory to load modules from\")
        ||\n      !op.addBoolOption('\\0', \"no-source-pragmas\",\n                        \"Disable
        source(Mapping)URL pragma parsing\") ||\n      !op.addBoolOption('\\0', \"no-async-stacks\",
        \"Disable async stacks\") ||\n      !op.addBoolOption('\\0', \"async-stacks-capture-debuggee-only\",\n
        \                       \"Limit async stack capture to only debuggees\") ||\n
        \     !op.addMultiStringOption('\\0', \"dll\", \"LIBRARY\",\n                               \"Dynamically
        load LIBRARY\") ||\n      !op.addBoolOption('\\0', \"suppress-minidump\",\n
        \                       \"Suppress crash minidumps\") ||\n#ifdef JS_ENABLE_SMOOSH\n
        \     !op.addBoolOption('\\0', \"smoosh\", \"Use SmooshMonkey\") ||\n      !op.addStringOption('\\0',
        \"not-implemented-watchfile\", \"[filename]\",\n                          \"Track
        NotImplemented errors in the new frontend\") ||\n#else\n      !op.addBoolOption('\\0',
        \"smoosh\", \"No-op\") ||\n#endif\n      !op.addStringOption(\n          '\\0',
        \"delazification-mode\", \"[option]\",\n          \"Select one of the delazification
        mode for scripts given on the \"\n          \"command line, valid options
        are: \"\n          \"'on-demand', 'concurrent-df', 'eager', 'concurrent-df+on-demand'.
        \"\n          \"Choosing 'concurrent-df+on-demand' will run both concurrent-df
        and \"\n          \"on-demand delazification mode, and compare compilation
        outcome. \") ||\n      !op.addBoolOption('\\0', \"wasm-compile-and-serialize\",\n
        \                       \"Compile the wasm bytecode from stdin and serialize
        \"\n                        \"the results to stdout\") ||\n#ifdef FUZZING_JS_FUZZILLI\n
        \     !op.addBoolOption('\\0', \"reprl\", \"Enable REPRL mode for fuzzing\")
        ||\n#endif\n      !op.addStringOption('\\0', \"telemetry-dir\", \"[directory]\",\n
        \                         \"Output telemetry results in a directory\") ||\n
        \     !op.addMultiStringOption('P', \"setpref\", \"name[=val]\",\n                               \"Set
        the value of a JS pref. The value may \"\n                               \"be
        omitted for boolean prefs, in which case \"\n                               \"they
        default to true. Use --list-prefs \"\n                               \"to
        print all pref names.\") ||\n      !op.addBoolOption(\n          '\\0', \"list-prefs\",\n
        \         \"Print list of prefs that can be set with --setpref.\") ||\n      !op.addBoolOption('\\0',
        \"use-fdlibm-for-sin-cos-tan\",\n                        \"Use fdlibm for
        Math.sin, Math.cos, and Math.tan\") ||\n      !op.addBoolOption('\\0', \"wasm-gc\",
        \"Enable WebAssembly gc proposal.\") ||\n      !op.addBoolOption('\\0', \"wasm-relaxed-simd\",\n
        \                       \"Enable WebAssembly relaxed-simd proposal.\") ||\n
        \     !op.addBoolOption('\\0', \"wasm-multi-memory\",\n                        \"Enable
        WebAssembly multi-memory proposal.\") ||\n      !op.addBoolOption('\\0', \"wasm-memory-control\",\n
        \                       \"Enable WebAssembly memory-control proposal.\") ||\n
        \     !op.addBoolOption('\\0', \"wasm-memory64\",\n                        \"Enable
        WebAssembly memory64 proposal.\") ||\n      !op.addBoolOption('\\0', \"wasm-tail-calls\",\n
        \                       \"Enable WebAssembly tail-calls proposal.\") ||\n
        \     !op.addBoolOption('\\0', \"wasm-js-string-builtins\",\n                        \"Enable
        WebAssembly js-string-builtins proposal.\")) {\n    return false;\n  }\n\n
        \ op.setArgTerminatesOptions(\"script\", true);\n  op.setArgCapturesRest(\"scriptArgs\");\n\n
        \ // If --fuzzing-safe is used, print a warning for unknown shell flags instead\n
        \ // of aborting execution.\n  op.setIgnoresUnknownOptions(\"fuzzing-safe\",
        true);\n\n  return true;\n}\n\nbool SetGlobalOptionsPreJSInit(const OptionParser&
        op) {\n  if (op.getBoolOption(\"fuzzing-safe\")) {\n    fuzzingSafe = true;\n
        \ } else {\n    fuzzingSafe =\n        (getenv(\"MOZ_FUZZING_SAFE\") && getenv(\"MOZ_FUZZING_SAFE\")[0]
        != '0');\n  }\n\n  for (MultiStringRange args = op.getMultiStringOption(\"setpref\");\n
        \      !args.empty(); args.popFront()) {\n    if (!SetJSPref(args.front()))
        {\n      return false;\n    }\n  }\n\n  // Override pref values for prefs
        that have a custom shell flag.\n  // If you're adding a new feature, consider
        using --setpref instead.\n\n  if (op.getBoolOption(\"disable-array-grouping\"))
        {\n    JS::Prefs::setAtStartup_array_grouping(false);\n  }\n  if (op.getBoolOption(\"disable-arraybuffer-transfer\"))
        {\n    JS::Prefs::setAtStartup_arraybuffer_transfer(false);\n  }\n  if (op.getBoolOption(\"enable-shadow-realms\"))
        {\n    JS::Prefs::set_experimental_shadow_realms(true);\n  }\n  if (op.getBoolOption(\"disable-well-formed-unicode-strings\"))
        {\n    JS::Prefs::setAtStartup_well_formed_unicode_strings(false);\n  }\n
        \ if (op.getBoolOption(\"enable-arraybuffer-resizable\")) {\n    JS::Prefs::setAtStartup_experimental_arraybuffer_resizable(true);\n
        \   JS::Prefs::setAtStartup_experimental_sharedarraybuffer_growable(true);\n
        \ }\n  if (op.getBoolOption(\"enable-regexp-duplicate-named-groups\")) {\n
        \   JS::Prefs::setAtStartup_experimental_regexp_duplicate_named_groups(true);\n
        \ }\n  if (op.getBoolOption(\"enable-float16array\")) {\n    JS::Prefs::setAtStartup_experimental_float16array(true);\n
        \ }\n#ifdef NIGHTLY_BUILD\n  if (op.getBoolOption(\"enable-iterator-helpers\"))
        {\n    JS::Prefs::setAtStartup_experimental_iterator_helpers(true);\n  }\n
        \ if (op.getBoolOption(\"enable-async-iterator-helpers\")) {\n    JS::Prefs::setAtStartup_experimental_async_iterator_helpers(true);\n
        \ }\n  if (op.getBoolOption(\"enable-new-set-methods\")) {\n    JS::Prefs::setAtStartup_experimental_new_set_methods(true);\n
        \ }\n  if (op.getBoolOption(\"enable-symbols-as-weakmap-keys\")) {\n    JS::Prefs::setAtStartup_experimental_symbols_as_weakmap_keys(true);\n
        \ }\n  if (op.getBoolOption(\"enable-uint8array-base64\")) {\n    JS::Prefs::setAtStartup_experimental_uint8array_base64(true);\n
        \ }\n#endif\n#ifdef ENABLE_JSON_PARSE_WITH_SOURCE\n  if (op.getBoolOption(\"enable-json-parse-with-source\"))
        {\n    JS::Prefs::set_experimental_json_parse_with_source(true);\n  }\n#else\n
        \ if (op.getBoolOption(\"enable-json-parse-with-source\")) {\n    fprintf(stderr,
        \"JSON.parse with source is not enabled on this build.\\n\");\n  }\n#endif\n\n
        \ if (op.getBoolOption(\"disable-weak-refs\")) {\n    JS::Prefs::setAtStartup_weakrefs(false);\n
        \ }\n  JS::Prefs::setAtStartup_experimental_weakrefs_expose_cleanupSome(true);\n\n
        \ if (op.getBoolOption(\"disable-destructuring-fuse\")) {\n    JS::Prefs::setAtStartup_destructuring_fuse(false);\n
        \ }\n  if (op.getBoolOption(\"disable-property-error-message-fix\")) {\n    JS::Prefs::setAtStartup_property_error_message_fix(false);\n
        \ }\n\n  JS::Prefs::set_use_fdlibm_for_sin_cos_tan(\n      op.getBoolOption(\"use-fdlibm-for-sin-cos-tan\"));\n\n
        \ if (op.getBoolOption(\"wasm-gc\") || op.getBoolOption(\"wasm-relaxed-simd\")
        ||\n      op.getBoolOption(\"wasm-multi-memory\") ||\n      op.getBoolOption(\"wasm-memory-control\")
        ||\n      op.getBoolOption(\"wasm-memory64\") ||\n      op.getBoolOption(\"wasm-tail-calls\")
        ||\n      op.getBoolOption(\"wasm-js-string-builtins\")) {\n    fprintf(\n
        \       stderr,\n        \"Wasm shell flags are now using prefs, use -P wasm_feature
        instead.\\n\");\n    return false;\n  }\n\n  if (op.getBoolOption(\"list-prefs\"))
        {\n    ListJSPrefs();\n    return false;\n  }\n\n  // Note: DisableJitBackend
        must be called before JS_InitWithFailureDiagnostic.\n  if (op.getBoolOption(\"no-jit-backend\"))
        {\n    JS::DisableJitBackend();\n  }\n\n#if defined(JS_CODEGEN_ARM)\n  if
        (const char* str = op.getStringOption(\"arm-hwcap\")) {\n    jit::SetARMHwCapFlagsString(str);\n
        \ }\n\n  int32_t fill = op.getIntOption(\"arm-asm-nop-fill\");\n  if (fill
        >= 0) {\n    jit::Assembler::NopFill = fill;\n  }\n\n  int32_t poolMaxOffset
        = op.getIntOption(\"asm-pool-max-offset\");\n  if (poolMaxOffset >= 5 && poolMaxOffset
        <= 1024) {\n    jit::Assembler::AsmPoolMaxOffset = poolMaxOffset;\n  }\n#endif\n\n
        \ // Fish around in `op` for various important compiler-configuration flags\n
        \ // and make sure they get handed on to any child processes we might create.\n
        \ // See bug 1700900.  Semantically speaking, this is all rather dubious:\n
        \ //\n  // * What set of flags need to be propagated in order to guarantee
        that the\n  //   child produces code that is \"compatible\" (in whatever sense)
        with that\n  //   produced by the parent? This isn't always easy to determine.\n
        \ //\n  // * There's nothing that ensures that flags given to the child are\n
        \ //   presented in the same order that they exist in the parent's `argv[]`.\n
        \ //   That could be a problem in the case where two flags with contradictory\n
        \ //   meanings are given, and they are presented to the child in the opposite\n
        \ //   order.  For example: --wasm-compiler=optimizing --wasm-compiler=baseline.\n\n#if
        defined(JS_CODEGEN_X86) || defined(JS_CODEGEN_X64)\n  MOZ_ASSERT(!js::jit::CPUFlagsHaveBeenComputed());\n\n
        \ if (op.getBoolOption(\"no-sse3\")) {\n    js::jit::CPUInfo::SetSSE3Disabled();\n
        \   if (!sCompilerProcessFlags.append(\"--no-sse3\")) {\n      return false;\n
        \   }\n  }\n  if (op.getBoolOption(\"no-ssse3\")) {\n    js::jit::CPUInfo::SetSSSE3Disabled();\n
        \   if (!sCompilerProcessFlags.append(\"--no-ssse3\")) {\n      return false;\n
        \   }\n  }\n  if (op.getBoolOption(\"no-sse4\") || op.getBoolOption(\"no-sse41\"))
        {\n    js::jit::CPUInfo::SetSSE41Disabled();\n    if (!sCompilerProcessFlags.append(\"--no-sse41\"))
        {\n      return false;\n    }\n  }\n  if (op.getBoolOption(\"no-sse42\"))
        {\n    js::jit::CPUInfo::SetSSE42Disabled();\n    if (!sCompilerProcessFlags.append(\"--no-sse42\"))
        {\n      return false;\n    }\n  }\n  if (op.getBoolOption(\"no-avx\")) {\n
        \   js::jit::CPUInfo::SetAVXDisabled();\n    if (!sCompilerProcessFlags.append(\"--no-avx\"))
        {\n      return false;\n    }\n  }\n  if (op.getBoolOption(\"enable-avx\"))
        {\n    js::jit::CPUInfo::SetAVXEnabled();\n    if (!sCompilerProcessFlags.append(\"--enable-avx\"))
        {\n      return false;\n    }\n  }\n#endif\n\n  return true;\n}\n\nbool SetGlobalOptionsPostJSInit(const
        OptionParser& op) {\n  if (op.getStringOption(\"telemetry-dir\")) {\n    MOZ_ASSERT(!telemetryLock);\n
        \   telemetryLock = js_new<Mutex>(mutexid::ShellTelemetry);\n    if (!telemetryLock)
        {\n      return false;\n    }\n  }\n\n  // Allow dumping on Linux with the
        fuzzing flag set, even when running with\n  // the suid/sgid flag set on the
        shell.\n#ifdef XP_LINUX\n  if (op.getBoolOption(\"fuzzing-safe\")) {\n    prctl(PR_SET_DUMPABLE,
        1);\n  }\n#endif\n\n#ifdef DEBUG\n  /*\n   * Process OOM options as early
        as possible so that we can observe as many\n   * allocations as possible.\n
        \  */\n  OOM_printAllocationCount = op.getBoolOption('O');\n#endif\n\n  if
        (op.getBoolOption(\"no-threads\")) {\n    js::DisableExtraThreads();\n  }\n\n
        \ enableCodeCoverage = op.getBoolOption(\"code-coverage\");\n  if (enableCodeCoverage)
        {\n    js::EnableCodeCoverage();\n  }\n\n  // If LCov is enabled, then the
        default delazification mode should be changed\n  // to parse everything eagerly,
        such that we know the location of every\n  // instruction, to report them
        in the LCov summary, even if there is no uses\n  // of these instructions.\n
        \ //\n  // Note: code coverage can be enabled either using the --code-coverage
        command\n  // line, or the JS_CODE_COVERAGE_OUTPUT_DIR environment variable,
        which is\n  // processed by JS_InitWithFailureDiagnostic.\n  if (coverage::IsLCovEnabled())
        {\n    defaultDelazificationMode =\n        JS::DelazificationOption::ParseEverythingEagerly;\n
        \ }\n\n  if (const char* xdr = op.getStringOption(\"selfhosted-xdr-path\"))
        {\n    shell::selfHostedXDRPath = xdr;\n  }\n  if (const char* opt = op.getStringOption(\"selfhosted-xdr-mode\"))
        {\n    if (strcmp(opt, \"encode\") == 0) {\n      shell::encodeSelfHostedCode
        = true;\n    } else if (strcmp(opt, \"decode\") == 0) {\n      shell::encodeSelfHostedCode
        = false;\n    } else if (strcmp(opt, \"off\") == 0) {\n      shell::selfHostedXDRPath
        = nullptr;\n    } else {\n      MOZ_CRASH(\n          \"invalid option value
        for --selfhosted-xdr-mode, must be \"\n          \"encode/decode\");\n    }\n
        \ }\n\n#ifdef JS_WITHOUT_NSPR\n  if (!op.getMultiStringOption(\"dll\").empty())
        {\n    fprintf(stderr, \"Error: --dll requires NSPR support!\\n\");\n    return
        false;\n  }\n#else\n  AutoLibraryLoader loader;\n  MultiStringRange dllPaths
        = op.getMultiStringOption(\"dll\");\n  while (!dllPaths.empty()) {\n    char*
        path = dllPaths.front();\n    loader.load(path);\n    dllPaths.popFront();\n
        \ }\n#endif\n\n  if (op.getBoolOption(\"suppress-minidump\")) {\n    js::NoteIntentionalCrash();\n
        \ }\n\n  // The fake CPU count must be set before initializing the Runtime,\n
        \ // which spins up the thread pool.\n  int32_t cpuCount = op.getIntOption(\"cpu-count\");
        \ // What we're really setting\n  if (cpuCount < 0) {\n    cpuCount = op.getIntOption(\"thread-count\");
        \ // Legacy name\n  }\n  if (cpuCount >= 0 && !SetFakeCPUCount(cpuCount))
        {\n    return false;\n  }\n\n  return true;\n}\n\nbool SetContextOptions(JSContext*
        cx, const OptionParser& op) {\n  if (!SetContextWasmOptions(cx, op) || !SetContextJITOptions(cx,
        op) ||\n      !SetContextGCOptions(cx, op)) {\n    return false;\n  }\n\n
        \ enableSourcePragmas = !op.getBoolOption(\"no-source-pragmas\");\n  enableAsyncStacks
        = !op.getBoolOption(\"no-async-stacks\");\n  enableAsyncStackCaptureDebuggeeOnly
        =\n      op.getBoolOption(\"async-stacks-capture-debuggee-only\");\n  enableToSource
        = !op.getBoolOption(\"disable-tosource\");\n  enableImportAttributesAssertSyntax
        =\n      op.getBoolOption(\"enable-import-assertions\");\n  enableImportAttributes
        = op.getBoolOption(\"enable-import-attributes\") ||\n                           enableImportAttributesAssertSyntax;\n
        \ JS::ContextOptionsRef(cx)\n      .setSourcePragmas(enableSourcePragmas)\n
        \     .setAsyncStack(enableAsyncStacks)\n      .setAsyncStackCaptureDebuggeeOnly(enableAsyncStackCaptureDebuggeeOnly)\n
        \     .setImportAttributes(enableImportAttributes)\n      .setImportAttributesAssertSyntax(enableImportAttributesAssertSyntax);\n\n
        \ if (const char* str = op.getStringOption(\"shared-memory\")) {\n    if (strcmp(str,
        \"off\") == 0) {\n      enableSharedMemory = false;\n    } else if (strcmp(str,
        \"on\") == 0) {\n      enableSharedMemory = true;\n    } else {\n      return
        OptionFailure(\"shared-memory\", str);\n    }\n  }\n\n  reportWarnings = op.getBoolOption('w');\n
        \ compileOnly = op.getBoolOption('c');\n  printTiming = op.getBoolOption('b');\n
        \ enableDisassemblyDumps = op.getBoolOption('D');\n  cx->runtime()->profilingScripts
        =\n      enableCodeCoverage || enableDisassemblyDumps;\n\n#ifdef JS_ENABLE_SMOOSH\n
        \ if (op.getBoolOption(\"smoosh\")) {\n    JS::ContextOptionsRef(cx).setTrySmoosh(true);\n
        \   js::frontend::InitSmoosh();\n  }\n\n  if (const char* filename = op.getStringOption(\"not-implemented-watchfile\"))
        {\n    FILE* out = fopen(filename, \"a\");\n    MOZ_RELEASE_ASSERT(out);\n
        \   setbuf(out, nullptr);  // Make unbuffered\n    cx->runtime()->parserWatcherFile.init(out);\n
        \   JS::ContextOptionsRef(cx).setTrackNotImplemented(true);\n  }\n#endif\n\n
        \ if (const char* mode = op.getStringOption(\"delazification-mode\")) {\n
        \   if (strcmp(mode, \"on-demand\") == 0) {\n      defaultDelazificationMode
        = JS::DelazificationOption::OnDemandOnly;\n    } else if (strcmp(mode, \"concurrent-df\")
        == 0) {\n      defaultDelazificationMode =\n          JS::DelazificationOption::ConcurrentDepthFirst;\n
        \   } else if (strcmp(mode, \"eager\") == 0) {\n      defaultDelazificationMode
        =\n          JS::DelazificationOption::ParseEverythingEagerly;\n    } else
        if (strcmp(mode, \"concurrent-df+on-demand\") == 0 ||\n               strcmp(mode,
        \"on-demand+concurrent-df\") == 0) {\n      defaultDelazificationMode =\n
        \         JS::DelazificationOption::CheckConcurrentWithOnDemand;\n    } else
        {\n      return OptionFailure(\"delazification-mode\", mode);\n    }\n  }\n\n
        \ return true;\n}\n\nbool SetContextWasmOptions(JSContext* cx, const OptionParser&
        op) {\n  enableAsmJS = !op.getBoolOption(\"no-asmjs\");\n\n  enableWasm =
        true;\n  enableWasmBaseline = true;\n  enableWasmOptimizing = true;\n\n  if
        (const char* str = op.getStringOption(\"wasm-compiler\")) {\n    if (strcmp(str,
        \"none\") == 0) {\n      enableWasm = false;\n    } else if (strcmp(str, \"baseline\")
        == 0) {\n      MOZ_ASSERT(enableWasmBaseline);\n      enableWasmOptimizing
        = false;\n    } else if (strcmp(str, \"optimizing\") == 0 ||\n               strcmp(str,
        \"optimized\") == 0) {\n      enableWasmBaseline = false;\n      MOZ_ASSERT(enableWasmOptimizing);\n
        \   } else if (strcmp(str, \"baseline+optimizing\") == 0 ||\n               strcmp(str,
        \"baseline+optimized\") == 0) {\n      MOZ_ASSERT(enableWasmBaseline);\n      MOZ_ASSERT(enableWasmOptimizing);\n
        \   } else if (strcmp(str, \"ion\") == 0) {\n      enableWasmBaseline = false;\n
        \     enableWasmOptimizing = true;\n    } else if (strcmp(str, \"baseline+ion\")
        == 0) {\n      MOZ_ASSERT(enableWasmBaseline);\n      enableWasmOptimizing
        = true;\n    } else {\n      return OptionFailure(\"wasm-compiler\", str);\n
        \   }\n  }\n\n  enableWasmVerbose = op.getBoolOption(\"wasm-verbose\");\n
        \ enableTestWasmAwaitTier2 = op.getBoolOption(\"test-wasm-await-tier2\");\n\n
        \ JS::ContextOptionsRef(cx)\n      .setAsmJS(enableAsmJS)\n      .setWasm(enableWasm)\n
        \     .setWasmForTrustedPrinciples(enableWasm)\n      .setWasmBaseline(enableWasmBaseline)\n
        \     .setWasmIon(enableWasmOptimizing)\n      .setTestWasmAwaitTier2(enableTestWasmAwaitTier2);\n\n#ifndef
        __wasi__\n  // This must be set before self-hosted code is initialized, as
        self-hosted\n  // code reads the property and the property may not be changed
        later.\n  bool disabledHugeMemory = false;\n  if (op.getBoolOption(\"disable-wasm-huge-memory\"))
        {\n    disabledHugeMemory = JS::DisableWasmHugeMemory();\n    MOZ_RELEASE_ASSERT(disabledHugeMemory);\n
        \ }\n\n  // --disable-wasm-huge-memory needs to be propagated.  See bug 1518210.\n
        \ if (disabledHugeMemory &&\n      !sCompilerProcessFlags.append(\"--disable-wasm-huge-memory\"))
        {\n    return false;\n  }\n\n  // Also the following are to be propagated.\n
        \ const char* to_propagate[] = {\n      // Compiler selection options\n      \"--test-wasm-await-tier2\",\n
        \ };\n  for (const char* p : to_propagate) {\n    if (op.getBoolOption(p +
        2 /* 2 => skip the leading '--' */)) {\n      if (!sCompilerProcessFlags.append(p))
        {\n        return false;\n      }\n    }\n  }\n\n  // Also --wasm-compiler=
        is to be propagated.  This is tricky because it is\n  // necessary to reconstitute
        the --wasm-compiler=<whatever> string from its\n  // pieces, without causing
        a leak.  Hence it is copied into a static buffer.\n  // This is thread-unsafe,
        but we're in `main()` and on the process' root\n  // thread.  Also, we do
        this only once -- it wouldn't work properly if we\n  // handled multiple --wasm-compiler=
        flags in a loop.\n  const char* wasm_compiler = op.getStringOption(\"wasm-compiler\");\n
        \ if (wasm_compiler) {\n    size_t n_needed =\n        2 + strlen(\"wasm-compiler\")
        + 1 + strlen(wasm_compiler) + 1;\n    const size_t n_avail = 128;\n    static
        char buf[n_avail];\n    // `n_needed` depends on the compiler name specified.
        \ However, it can't\n    // be arbitrarily long, since previous flag-checking
        should have limited\n    // it to a set of known possibilities: \"baseline\",
        \"ion\",\n    // \"baseline+ion\",  Still, assert this for safety.\n    MOZ_RELEASE_ASSERT(n_needed
        < n_avail);\n    memset(buf, 0, sizeof(buf));\n    SprintfBuf(buf, n_avail,
        \"--%s=%s\", \"wasm-compiler\", wasm_compiler);\n    if (!sCompilerProcessFlags.append(buf))
        {\n      return false;\n    }\n  }\n#endif  // __wasi__\n\n  return true;\n}\n\nbool
        SetContextJITOptions(JSContext* cx, const OptionParser& op) {\n  // Check
        --fast-warmup first because it sets default warm-up thresholds. These\n  //
        thresholds can then be overridden below by --ion-eager and other flags.\n
        \ if (op.getBoolOption(\"fast-warmup\")) {\n    jit::JitOptions.setFastWarmUp();\n
        \ }\n\n  if (op.getBoolOption(\"no-ion-for-main-context\")) {\n    JS::ContextOptionsRef(cx).setDisableIon();\n
        \ }\n\n  if (const char* str = op.getStringOption(\"cache-ir-stubs\")) {\n
        \   if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableCacheIR
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableCacheIR
        = true;\n    } else {\n      return OptionFailure(\"cache-ir-stubs\", str);\n
        \   }\n  }\n\n  if (const char* str = op.getStringOption(\"spectre-mitigations\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.spectreIndexMasking
        = true;\n      jit::JitOptions.spectreObjectMitigations = true;\n      jit::JitOptions.spectreStringMitigations
        = true;\n      jit::JitOptions.spectreValueMasking = true;\n      jit::JitOptions.spectreJitToCxxCalls
        = true;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.spectreIndexMasking
        = false;\n      jit::JitOptions.spectreObjectMitigations = false;\n      jit::JitOptions.spectreStringMitigations
        = false;\n      jit::JitOptions.spectreValueMasking = false;\n      jit::JitOptions.spectreJitToCxxCalls
        = false;\n    } else {\n      return OptionFailure(\"spectre-mitigations\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"write-protect-code\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.maybeSetWriteProtectCode(true);\n
        \   } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.maybeSetWriteProtectCode(false);\n
        \   } else {\n      return OptionFailure(\"write-protect-code\", str);\n    }\n
        \ }\n\n  if (const char* str = op.getStringOption(\"monomorphic-inlining\"))
        {\n    if (strcmp(str, \"default\") == 0) {\n      jit::JitOptions.monomorphicInlining
        =\n          jit::UseMonomorphicInlining::Default;\n    } else if (strcmp(str,
        \"always\") == 0) {\n      jit::JitOptions.monomorphicInlining = jit::UseMonomorphicInlining::Always;\n
        \   } else if (strcmp(str, \"never\") == 0) {\n      jit::JitOptions.monomorphicInlining
        = jit::UseMonomorphicInlining::Never;\n    } else {\n      return OptionFailure(\"monomorphic-inlining\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-scalar-replacement\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableScalarReplacement
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableScalarReplacement
        = true;\n    } else {\n      return OptionFailure(\"ion-scalar-replacement\",
        str);\n    }\n  }\n\n  if (op.getStringOption(\"ion-shared-stubs\")) {\n    //
        Dead option, preserved for now for potential fuzzer interaction.\n  }\n\n
        \ if (const char* str = op.getStringOption(\"ion-gvn\")) {\n    if (strcmp(str,
        \"off\") == 0) {\n      jit::JitOptions.disableGvn = true;\n    } else if
        (strcmp(str, \"on\") != 0 && strcmp(str, \"optimistic\") != 0 &&\n               strcmp(str,
        \"pessimistic\") != 0) {\n      // We accept \"pessimistic\" and \"optimistic\"
        as synonyms for \"on\"\n      // for backwards compatibility.\n      return
        OptionFailure(\"ion-gvn\", str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-licm\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableLicm
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableLicm
        = true;\n    } else {\n      return OptionFailure(\"ion-licm\", str);\n    }\n
        \ }\n\n  if (const char* str = op.getStringOption(\"ion-edgecase-analysis\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableEdgeCaseAnalysis
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableEdgeCaseAnalysis
        = true;\n    } else {\n      return OptionFailure(\"ion-edgecase-analysis\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-pruning\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disablePruning
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disablePruning
        = true;\n    } else {\n      return OptionFailure(\"ion-pruning\", str);\n
        \   }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-range-analysis\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableRangeAnalysis
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableRangeAnalysis
        = true;\n    } else {\n      return OptionFailure(\"ion-range-analysis\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-sink\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableSink
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableSink
        = true;\n    } else {\n      return OptionFailure(\"ion-sink\", str);\n    }\n
        \ }\n\n  if (const char* str = op.getStringOption(\"ion-optimize-shapeguards\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableRedundantShapeGuards
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableRedundantShapeGuards
        = true;\n    } else {\n      return OptionFailure(\"ion-optimize-shapeguards\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-optimize-gcbarriers\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableRedundantGCBarriers
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableRedundantGCBarriers
        = true;\n    } else {\n      return OptionFailure(\"ion-optimize-gcbarriers\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-instruction-reordering\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableInstructionReordering
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableInstructionReordering
        = true;\n    } else {\n      return OptionFailure(\"ion-instruction-reordering\",
        str);\n    }\n  }\n\n  if (op.getBoolOption(\"ion-check-range-analysis\"))
        {\n    jit::JitOptions.checkRangeAnalysis = true;\n  }\n\n  if (op.getBoolOption(\"ion-extra-checks\"))
        {\n    jit::JitOptions.runExtraChecks = true;\n  }\n\n  if (const char* str
        = op.getStringOption(\"ion-inlining\")) {\n    if (strcmp(str, \"on\") ==
        0) {\n      jit::JitOptions.disableInlining = false;\n    } else if (strcmp(str,
        \"off\") == 0) {\n      jit::JitOptions.disableInlining = true;\n    } else
        {\n      return OptionFailure(\"ion-inlining\", str);\n    }\n  }\n\n  if
        (const char* str = op.getStringOption(\"ion-osr\")) {\n    if (strcmp(str,
        \"on\") == 0) {\n      jit::JitOptions.osr = true;\n    } else if (strcmp(str,
        \"off\") == 0) {\n      jit::JitOptions.osr = false;\n    } else {\n      return
        OptionFailure(\"ion-osr\", str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-limit-script-size\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.limitScriptSize
        = true;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.limitScriptSize
        = false;\n    } else {\n      return OptionFailure(\"ion-limit-script-size\",
        str);\n    }\n  }\n\n  int32_t warmUpThreshold = op.getIntOption(\"ion-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.setNormalIonWarmUpThreshold(warmUpThreshold);\n
        \ }\n\n  warmUpThreshold = op.getIntOption(\"baseline-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.baselineJitWarmUpThreshold
        = warmUpThreshold;\n  }\n\n  warmUpThreshold = op.getIntOption(\"trial-inlining-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.trialInliningWarmUpThreshold
        = warmUpThreshold;\n  }\n\n  warmUpThreshold = op.getIntOption(\"regexp-warmup-threshold\");\n
        \ if (warmUpThreshold >= 0) {\n    jit::JitOptions.regexpWarmUpThreshold =
        warmUpThreshold;\n  }\n\n  if (op.getBoolOption(\"baseline-eager\")) {\n    jit::JitOptions.setEagerBaselineCompilation();\n
        \ }\n\n#ifdef ENABLE_PORTABLE_BASELINE_INTERP\n  if (op.getBoolOption(\"portable-baseline-eager\"))
        {\n    jit::JitOptions.setEagerPortableBaselineInterpreter();\n  }\n  if (op.getBoolOption(\"portable-baseline\"))
        {\n    jit::JitOptions.portableBaselineInterpreter = true;\n  }\n  if (op.getBoolOption(\"no-portable-baseline\"))
        {\n    jit::JitOptions.portableBaselineInterpreter = false;\n  }\n#endif\n\n
        \ if (op.getBoolOption(\"blinterp\")) {\n    jit::JitOptions.baselineInterpreter
        = true;\n  }\n\n  if (op.getBoolOption(\"no-blinterp\")) {\n    jit::JitOptions.baselineInterpreter
        = false;\n  }\n\n  if (op.getBoolOption(\"disable-jithints\")) {\n    jit::JitOptions.disableJitHints
        = true;\n  }\n\n  if (op.getBoolOption(\"emit-interpreter-entry\")) {\n    jit::JitOptions.emitInterpreterEntryTrampoline
        = true;\n  }\n\n  if (op.getBoolOption(\"no-emit-interpreter-entry\")) {\n
        \   jit::JitOptions.emitInterpreterEntryTrampoline = false;\n  }\n\n  warmUpThreshold
        = op.getIntOption(\"blinterp-warmup-threshold\");\n  if (warmUpThreshold >=
        0) {\n    jit::JitOptions.baselineInterpreterWarmUpThreshold = warmUpThreshold;\n
        \ }\n\n  if (op.getBoolOption(\"blinterp-eager\")) {\n    jit::JitOptions.baselineInterpreterWarmUpThreshold
        = 0;\n  }\n\n  if (op.getBoolOption(\"no-baseline\")) {\n    jit::JitOptions.baselineJit
        = false;\n  }\n\n  if (op.getBoolOption(\"no-ion\")) {\n    jit::JitOptions.ion
        = false;\n  }\n\n  if (op.getBoolOption(\"no-native-regexp\")) {\n    jit::JitOptions.nativeRegExp
        = false;\n  }\n\n  if (op.getBoolOption(\"trace-regexp-parser\")) {\n    jit::JitOptions.trace_regexp_parser
        = true;\n  }\n  if (op.getBoolOption(\"trace-regexp-assembler\")) {\n    jit::JitOptions.trace_regexp_assembler
        = true;\n  }\n  if (op.getBoolOption(\"trace-regexp-interpreter\")) {\n    jit::JitOptions.trace_regexp_bytecodes
        = true;\n  }\n  if (op.getBoolOption(\"trace-regexp-peephole\")) {\n    jit::JitOptions.trace_regexp_peephole_optimization
        = true;\n  }\n\n  if (op.getBoolOption(\"less-debug-code\")) {\n    jit::JitOptions.lessDebugCode
        = true;\n  }\n\n  int32_t inliningEntryThreshold = op.getIntOption(\"inlining-entry-threshold\");\n
        \ if (inliningEntryThreshold > 0) {\n    jit::JitOptions.inliningEntryThreshold
        = inliningEntryThreshold;\n  }\n\n  int32_t smallFunctionLength = op.getIntOption(\"small-function-length\");\n
        \ if (smallFunctionLength > 0) {\n    jit::JitOptions.smallFunctionMaxBytecodeLength
        = smallFunctionLength;\n  }\n\n  if (const char* str = op.getStringOption(\"ion-regalloc\"))
        {\n    jit::JitOptions.forcedRegisterAllocator = jit::LookupRegisterAllocator(str);\n
        \   if (!jit::JitOptions.forcedRegisterAllocator.isSome()) {\n      return
        OptionFailure(\"ion-regalloc\", str);\n    }\n  }\n\n  if (op.getBoolOption(\"ion-eager\"))
        {\n    jit::JitOptions.setEagerIonCompilation();\n  }\n\n  offthreadCompilation
        = true;\n  if (const char* str = op.getStringOption(\"ion-offthread-compile\"))
        {\n    if (strcmp(str, \"off\") == 0) {\n      offthreadCompilation = false;\n
        \   } else if (strcmp(str, \"on\") != 0) {\n      return OptionFailure(\"ion-offthread-compile\",
        str);\n    }\n  }\n  cx->runtime()->setOffthreadIonCompilationEnabled(offthreadCompilation);\n\n
        \ if (op.getStringOption(\"ion-parallel-compile\")) {\n    fprintf(stderr,\n
        \           \"--ion-parallel-compile is deprecated. Please use \"\n            \"--ion-offthread-compile
        instead.\\n\");\n    return false;\n  }\n\n  if (op.getBoolOption(\"disable-bailout-loop-check\"))
        {\n    jit::JitOptions.disableBailoutLoopCheck = true;\n  }\n\n  if (op.getBoolOption(\"only-inline-selfhosted\"))
        {\n    jit::JitOptions.onlyInlineSelfHosted = true;\n  }\n\n  if (op.getBoolOption(\"enable-ic-frame-pointers\"))
        {\n    jit::JitOptions.enableICFramePointers = true;\n  }\n\n  if (const char*
        str = op.getStringOption(\"ion-iterator-indices\")) {\n    if (strcmp(str,
        \"on\") == 0) {\n      jit::JitOptions.disableIteratorIndices = false;\n    }
        else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableIteratorIndices
        = true;\n    } else {\n      return OptionFailure(\"ion-iterator-indices\",
        str);\n    }\n  }\n\n  if (const char* str = op.getStringOption(\"ion-load-keys\"))
        {\n    if (strcmp(str, \"on\") == 0) {\n      jit::JitOptions.disableMarkLoadsUsedAsPropertyKeys
        = false;\n    } else if (strcmp(str, \"off\") == 0) {\n      jit::JitOptions.disableMarkLoadsUsedAsPropertyKeys
        = true;\n    } else {\n      return OptionFailure(\"ion-load-keys\", str);\n
        \   }\n  }\n\n#if defined(JS_SIMULATOR_ARM)\n  if (op.getBoolOption(\"arm-sim-icache-checks\"))
        {\n    jit::SimulatorProcess::ICacheCheckingDisableCount = 0;\n  }\n\n  int32_t
        stopAt = op.getIntOption(\"arm-sim-stop-at\");\n  if (stopAt >= 0) {\n    jit::Simulator::StopSimAt
        = stopAt;\n  }\n#elif defined(JS_SIMULATOR_MIPS32) || defined(JS_SIMULATOR_MIPS64)\n
        \ if (op.getBoolOption(\"mips-sim-icache-checks\")) {\n    jit::SimulatorProcess::ICacheCheckingDisableCount
        = 0;\n  }\n\n  int32_t stopAt = op.getIntOption(\"mips-sim-stop-at\");\n  if
        (stopAt >= 0) {\n    jit::Simulator::StopSimAt = stopAt;\n  }\n#elif defined(JS_SIMULATOR_LOONG64)\n
        \ if (op.getBoolOption(\"loong64-sim-icache-checks\")) {\n    jit::SimulatorProcess::ICacheCheckingDisableCount
        = 0;\n  }\n\n  int32_t stopAt = op.getIntOption(\"loong64-sim-stop-at\");\n
        \ if (stopAt >= 0) {\n    jit::Simulator::StopSimAt = stopAt;\n  }\n#endif\n\n#ifdef
        DEBUG\n#  ifdef JS_CODEGEN_RISCV64\n  if (op.getBoolOption(\"riscv-debug\"))
        {\n    jit::Assembler::FLAG_riscv_debug = true;\n  }\n#  endif\n#  ifdef JS_SIMULATOR_RISCV64\n
        \ if (op.getBoolOption(\"trace-sim\")) {\n    jit::Simulator::FLAG_trace_sim
        = true;\n  }\n  if (op.getBoolOption(\"debug-sim\")) {\n    jit::Simulator::FLAG_debug_sim
        = true;\n  }\n  if (op.getBoolOption(\"riscv-trap-to-simulator-debugger\"))
        {\n    jit::Simulator::FLAG_riscv_trap_to_simulator_debugger = true;\n  }\n
        \ int32_t stopAt = op.getIntOption(\"riscv-sim-stop-at\");\n  if (stopAt >=
        0) {\n    jit::Simulator::StopSimAt = stopAt;\n  }\n#  endif\n#endif\n\n  if
        (op.getBoolOption(\"enable-regexp-duplicate-named-groups\")) {\n    jit::JitOptions.js_regexp_duplicate_named_groups
        = true;\n  }\n\n  return true;\n}\n\nbool SetContextGCOptions(JSContext* cx,
        const OptionParser& op) {\n  JS_SetGCParameter(cx, JSGC_MAX_BYTES, 0xffffffff);\n\n
        \ size_t nurseryBytes = op.getIntOption(\"nursery-size\") * 1024L * 1024L;\n
        \ if (nurseryBytes == 0) {\n    fprintf(stderr, \"Error: --nursery-size parameter
        must be non-zero.\\n\");\n    fprintf(stderr,\n            \"The nursery can
        be disabled by passing the --no-ggc option.\\n\");\n    return false;\n  }\n
        \ JS_SetGCParameter(cx, JSGC_MAX_NURSERY_BYTES, nurseryBytes);\n\n  size_t
        availMemMB = op.getIntOption(\"available-memory\");\n  if (availMemMB > 0)
        {\n    JS_SetGCParametersBasedOnAvailableMemory(cx, availMemMB);\n  }\n\n
        \ if (const char* opt = op.getStringOption(\"nursery-strings\")) {\n    if
        (strcmp(opt, \"on\") == 0) {\n      cx->runtime()->gc.nursery().enableStrings();\n
        \   } else if (strcmp(opt, \"off\") == 0) {\n      cx->runtime()->gc.nursery().disableStrings();\n
        \   } else {\n      MOZ_CRASH(\"invalid option value for --nursery-strings,
        must be on/off\");\n    }\n  }\n\n  if (const char* opt = op.getStringOption(\"nursery-bigints\"))
        {\n    if (strcmp(opt, \"on\") == 0) {\n      cx->runtime()->gc.nursery().enableBigInts();\n
        \   } else if (strcmp(opt, \"off\") == 0) {\n      cx->runtime()->gc.nursery().disableBigInts();\n
        \   } else {\n      MOZ_CRASH(\"invalid option value for --nursery-bigints,
        must be on/off\");\n    }\n  }\n\n  bool incrementalGC = !op.getBoolOption(\"no-incremental-gc\");\n
        \ JS_SetGCParameter(cx, JSGC_INCREMENTAL_GC_ENABLED, incrementalGC);\n\n#ifndef
        ANDROID\n  bool parallelMarking = true;\n#else\n  bool parallelMarking = false;\n#endif\n
        \ if (op.getBoolOption(\"enable-parallel-marking\")) {\n    parallelMarking
        = true;\n  }\n  if (op.getBoolOption(\"no-parallel-marking\")) {\n    parallelMarking
        = false;\n  }\n  JS_SetGCParameter(cx, JSGC_PARALLEL_MARKING_ENABLED, parallelMarking);\n\n
        \ JS_SetGCParameter(cx, JSGC_SLICE_TIME_BUDGET_MS, 5);\n\n  JS_SetGCParameter(cx,
        JSGC_PER_ZONE_GC_ENABLED, true);\n\n  for (MultiStringRange args = op.getMultiStringOption(\"gc-param\");\n
        \      !args.empty(); args.popFront()) {\n    if (!SetGCParameterFromArg(cx,
        args.front())) {\n      return false;\n    }\n  }\n\n#ifdef DEBUG\n  dumpEntrainedVariables
        = op.getBoolOption(\"dump-entrained-variables\");\n#endif\n\n#ifdef JS_GC_ZEAL\n
        \ const char* zealStr = op.getStringOption(\"gc-zeal\");\n  if (zealStr) {\n
        \   if (!cx->runtime()->gc.parseAndSetZeal(zealStr)) {\n      return false;\n
        \   }\n    uint32_t nextScheduled;\n    cx->runtime()->gc.getZealBits(&gZealBits,
        &gZealFrequency, &nextScheduled);\n  }\n#endif\n\n  return true;\n}\n\nbool
        InitModuleLoader(JSContext* cx, const OptionParser& op) {\n  RootedString
        moduleLoadPath(cx);\n  if (const char* option = op.getStringOption(\"module-load-path\"))
        {\n    UniqueChars pathUtf8 = JS::EncodeNarrowToUtf8(cx, option);\n    if
        (!pathUtf8) {\n      return false;\n    }\n\n    Rooted<JSString*> jspath(cx,
        NewStringCopyUTF8(cx, pathUtf8.get()));\n    if (!jspath) {\n      return
        false;\n    }\n\n    moduleLoadPath = js::shell::ResolvePath(cx, jspath, RootRelative);\n\n
        \   processWideModuleLoadPath = JS_EncodeStringToUTF8(cx, moduleLoadPath);\n
        \   if (!processWideModuleLoadPath) {\n      return false;\n    }\n  } else
        {\n    processWideModuleLoadPath = js::shell::GetCWD(cx);\n    if (!processWideModuleLoadPath)
        {\n      return false;\n    }\n\n    moduleLoadPath = NewStringCopyUTF8(cx,
        processWideModuleLoadPath.get());\n    if (!moduleLoadPath) {\n      return
        false;\n    }\n  }\n\n  ShellContext* sc = GetShellContext(cx);\n  sc->moduleLoader
        = js::MakeUnique<ModuleLoader>();\n  if (!sc->moduleLoader || !sc->moduleLoader->init(cx,
        moduleLoadPath)) {\n    return false;\n  }\n\n  return true;\n}\n"
    headers:
      Access-Control-Allow-Origin:
      - '*'
      Cache-Control:
      - no-cache
      Connection:
      - Keep-Alive
      Content-Disposition:
      - inline; filename="js.cpp"
      Content-Security-Policy:
      - 'default-src ''none''; connect-src ''self'' https://bugzilla.mozilla.org/;
        img-src ''self''; script-src https://hg.mozilla.org/static/ ''nonce-2ee_C5A1QCq6hQa-i0GIDw'';
        style-src ''self'' ''unsafe-inline''; upgrade-insecure-requests; frame-ancestors
        https:'
      Content-Type:
      - text/plain; charset="UTF-8"
      Date:
      - Tue, 23 Jul 2024 14:09:55 GMT
      Server:
      - Apache
      Strict-Transport-Security:
      - max-age=31536000
      Transfer-Encoding:
      - chunked
      Vary:
      - Accept-Encoding
      X-Cache-Info:
      - 'not cacheable; response specified "Cache-Control: no-cache"'
      X-Content-Type-Options:
      - nosniff
      content-length:
      - '417549'
    status:
      code: 200
      message: Script output follows
version: 1
